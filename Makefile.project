ifdef EXPERIMENT
.PHONY : clean clean-profiles $(EXPERIMENT) $(EXPERIMENT)-std \
	  $(EXPERIMENT)-jit $(EXPERIMENT)-caddy $(EXPERIMENT)-raw \
	  $(EXPERIMENT)-ext

all: raw std jit ext
raw std jit ext caddy: %: \
  $(PROJECT_OUTDIR)/.mkdir \
  $(OUTDIR)/$(PROJECT).$(EXPERIMENT).% \
  $(OUTDIR)/$(PROJECT).$(EXPERIMENT).%.likwid \
  $(OUTDIR)/$(PROJECT).$(EXPERIMENT).%.tar
endif

# Everything above us should be guarded with env variables.
default::
	$(error "Set the EXPERIMENT variable to the experiment you want to run!")

profiles-clean: clean-prof-caddy \
                clean-prof-std \
		clean-prof-jit \
		clean-prof-ext \
		clean-prof-raw

outdir-clean:
	-$(V_RM)rmdir $(OUTDIR)

clean-prof-%: profiles=$(subst %,$*,$(PROFILES))
clean-prof-%:
	$(V_RM)rm -f $(profiles)
	$(VERB)rm -f $(OUTDIR)/$(PROJECT).$(EXPERIMENT).$*
	$(VERB)rm -f $(OUTDIR)/$*.raw
	$(VERB)rm -f $(OUTPUT)/$*.$(EXPERIMENT).tar.gz

clean: clean-std clean-jit clean-ext clean-raw clean-caddy

# Empty rule by default. Projects can provide a recipe for this to clean up
# the mess they made during run-time.
clean-%-$(PROJECT): ;

clean-%: clean-%-$(PROJECT)
	$(V_RM)rm -f $(subst %,$*,$(GENERATED))

.SECONDEXPANSION:
ifdef EXPERIMENT
  include $(LEVEL)/$(EXPERIMENTS)/Exp.$(EXPERIMENT).Makefile
endif

$(OUTDIR)/$(PROJECT).$(EXPERIMENT).%.tar: prj_dir=$(subst %,$*,$(PROJECT_OUTDIR))
$(OUTDIR)/$(PROJECT).$(EXPERIMENT).%.tar: $(OUTDIR)/$(PROJECT).$(EXPERIMENT).%
	$(V_TAR)tar -czf $@ $(prj_dir)

# Make sure *$(TIME_EXT) is in the right place
$(TIME_F): $(PROFBIN_F)
	$(V_TCH)touch $@

# Rename papi call stack to the project based name.
$(CALLS_F): $(PROFILE_F)
	-$(V_MV)mv $(PAPI_CALL_STACK_FILE) $@

# Rename profile output to the "binary" name.
$(PROFILE_F): $(PROFBIN_F)
	$(V_MV)mv $^ $@

# Create a preoptimized file from the bitcode.
#
# Preoptimized files stay in top-level project dir,
# to remain "cached" between cleans.
$(PREOPT_F):
	$(V_PRE)clang -Xclang -load -Xclang $(POLLY) -O0 -mllvm \
	  -polly -mllvm -stats -S -emit-llvm $(PROJECT).bc -o $@

# Create an optimized variant of a preoptimized IR file.
$(OPT_F): $(PREOPT_F)
	$(V_OPT)opt -load $(POLLY) $(OPT_FLAGS) $(VARIANT_$*) \
	  -polly-detect -papi-prepare -S -o $@ $^

# Instrument IR with one of the variants (std/jit/ext)
$(INST_F): $(OPT_F)
	$(V_OPT)opt -load $(POLLY) -basicaa -tbaa $(VARIANT_$*) \
	  -insert-papi-region-profiling -o $@ $^

# Create an assembler file from the experiment's binary file.
#$(BIN_F): $(BIN_F)-$(EXPERIMENT)
#	$(V_CLANG)clang -B$(LINKER_DIR) -flto -march=native -O3 $^ -o $@
$(BIN_F): $(BIN_F)-$(EXPERIMENT)
	$(V_MV)mv $^ $@

# Create a test-runner to wrap the binary
$(RUN_F): $(BIN_F)
	$(VERB)cp $(LEVEL)/$(EXPERIMENTS)/$(EXPERIMENT).$(TIME_SCRIPT) $@
	$(VERB)chmod +x $@
	$(V_SED)sed -i 's/@OPT_FLAGS@/${OPT_FLAGS}/' $@
	$(V_SED)sed -i 's/@POLLI_FLAGS@/$(POLLI_FLAGS_$*)/' $@
	$(V_SED)sed -i 's/@LIKWID_BINARY@/$(LIKWID_BINARY)/' $@
	$(V_SED)sed -i 's/@LIKWID_FILTER@/$(subst /,\/,$(LIKWID_FILTER))/' $@
	$(V_SED)sed -i 's/@EXPERIMENT@/$(EXPERIMENT)/' $@

# This rule requires us to generate $(PROJECT).likwid when we execute. This
# is not enforced by make at all!
$(CSV_F): likwid_f=$(subst %,$*,$(LIKWID_F))
$(CSV_F): $(TIME_F)
	@echo "This rule requires $(PROJECT).likwid created by your experiment"
	$(V_LIKWID)$(LIKWID_FILTER) $(likwid_f) perfctr -o $@
	$(V_SED)sed -i 's/^/$(DOMAIN),/' $@
	$(V_SED)sed -i 's/^/$(PROJECT),/' $@

# Make sure *.calls is in the right place
#raw/$(CALLS_F):
#	$(V_TCH)touch $@
#
## RAW has no profiling output, so just fake it.
#raw/$(PROFILE_F): raw/$(PROFBIN_F)
#	$(V_TCH)touch $@
#
## Do not instrument raw binaries.
##
#raw/$(INST_F): raw/$(OPT_F)
#	$(V_OPT)opt -load $(POLLY) $(OPT_FLAGS) $(VARIANT_$*) \
#	  -o $@ $^


#
# Profiling stuff
#

# Create the stack management.
$(LEVEL)/stack.o: $(LEVEL)/stack.c
	$(VERB)gcc -std=c99 -c -O3 -o $@ $(PAPI_CFLAGS) $(@:%.o=%.c)
