<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>benchbuild.cli.experiment API documentation</title>
<meta name="description" content="Subcommand for experiment handling." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>benchbuild.cli.experiment</code></h1>
</header>
<section id="section-intro">
<p>Subcommand for experiment handling.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Subcommand for experiment handling.&#34;&#34;&#34;
import sqlalchemy as sa
import urwid
from jinja2 import Environment, PackageLoader
from plumbum import cli

from benchbuild import experiment, plugins
from benchbuild.cli.main import BenchBuild
from benchbuild.utils import schema


@BenchBuild.subcommand(&#34;experiment&#34;)
class BBExperiment(cli.Application):
    &#34;&#34;&#34;Manage BenchBuild&#39;s known experiments.&#34;&#34;&#34;
    def main(self):
        if not self.nested_command:
            self.help()


@BBExperiment.subcommand(&#34;view&#34;)
class BBExperimentView(cli.Application):
    &#34;&#34;&#34;View available experiments.&#34;&#34;&#34;
    def main(self):
        all_exps = experiment.discovered()
        for exp_cls in all_exps.values():
            print(exp_cls.NAME)
            docstring = exp_cls.__doc__ or &#34;-- no docstring --&#34;
            print((&#34;    &#34; + docstring))


class MenuButton(urwid.Button):
    def __init__(self, caption, callback):
        super(MenuButton, self).__init__(&#34;&#34;)
        urwid.connect_signal(self, &#39;click&#39;, callback)
        self._w = urwid.AttrMap(
            urwid.SelectableIcon([u&#39;  \N{BULLET} &#39;, caption], 2), None,
            &#39;selected&#39;)


class SubMenu(urwid.WidgetWrap):
    def __init__(self, caption, choices, top):
        super(SubMenu, self).__init__(
            MenuButton([caption, &#34;\N{HORIZONTAL ELLIPSIS}&#34;], self.open_menu))
        line = urwid.Divider(&#39;\N{LOWER ONE QUARTER BLOCK}&#39;)
        listbox = urwid.ListBox(
            urwid.SimpleFocusListWalker([
                urwid.AttrMap(urwid.Text([&#34;\n  &#34;, caption]), &#39;heading&#39;),
                urwid.AttrMap(line, &#39;line&#39;),
                urwid.Divider()
            ] + choices + [urwid.Divider()]))
        self.menu = urwid.AttrMap(listbox, &#39;options&#39;)
        self.top = top

    def open_menu(self, _):
        self.top.open_box(self.menu)


class Choice(urwid.WidgetWrap):
    def __init__(self, caption, payload, top):
        super(Choice, self).__init__(MenuButton(caption, self.item_chosen))
        self.caption = caption
        self.top = top
        self.payload = payload

    def item_chosen(self, _):
        session = schema.Session()
        session.delete(self.payload)

        def confirm(_):
            session.commit()
            self.top.clear()
            self.top.open_box(refresh_root_window(self.top))

        def cancel(_):
            session.rollback()
            self.top.clear()
            self.top.open_box(refresh_root_window(self.top))

        response = urwid.Text([
            &#39;Really delete: {name} {desc}?&#39;.format(
                name=self.payload.name, desc=self.payload.description), &#39;\n&#39;
        ])
        done = MenuButton(&#39;Ok&#39;, confirm)
        cancel = MenuButton(&#39;Cancel&#39;, cancel)
        response_box = urwid.Filler(urwid.Pile([response, done, cancel]))
        self.top.open_box(urwid.AttrMap(response_box, &#39;options&#39;))


class HorizontalBoxes(urwid.Columns):
    def __init__(self):
        super(HorizontalBoxes, self).__init__([], dividechars=1)

    def clear(self):
        self.contents = []

    def open_box(self, box):
        focus_map = {
            &#39;heading&#39;: &#39;focus heading&#39;,
            &#39;options&#39;: &#39;focus options&#39;,
            &#39;line&#39;: &#39;focus line&#39;
        }
        if self.contents:
            del self.contents[self.focus_position + 1:]
        self.contents.append(
            (urwid.AttrMap(box, &#39;options&#39;,
                           focus_map), self.options(&#39;given&#39;, 80)))
        self.focus_position = len(self.contents) - 1


@BBExperiment.subcommand(&#34;manage&#34;)
class BBExperimentShow(cli.Application):
    &#34;&#34;&#34;Show completed experiments.&#34;&#34;&#34;
    def main(self):
        def maybe_exit(key):
            if key in (&#39;q&#39;, &#39;Q&#39;):
                raise urwid.ExitMainLoop()

        # yapf: disable
        palette = [(None, &#39;light gray&#39;, &#39;black&#39;),
                   (&#39;heading&#39;, &#39;black&#39;, &#39;light gray&#39;),
                   (&#39;line&#39;, &#39;black&#39;, &#39;light gray&#39;),
                   (&#39;options&#39;, &#39;dark gray&#39;, &#39;black&#39;),
                   (&#39;focus heading&#39;, &#39;white&#39;, &#39;dark red&#39;),
                   (&#39;focus line&#39;, &#39;black&#39;, &#39;dark red&#39;),
                   (&#39;focus options&#39;, &#39;black&#39;, &#39;light gray&#39;),
                   (&#39;selected&#39;, &#39;white&#39;, &#39;dark blue&#39;)]

        # yapf: enable
        top = HorizontalBoxes()
        top.open_box(refresh_root_window(top))
        loop = urwid.MainLoop(urwid.Filler(top, &#39;top&#39;, height=48),
                              palette=palette,
                              unhandled_input=maybe_exit)
        loop.run()


def get_template():
    env = Environment(trim_blocks=True,
                      lstrip_blocks=True,
                      loader=PackageLoader(&#39;benchbuild&#39;, &#39;utils/templates&#39;))
    return env.get_template(&#39;experiment_show.txt.inc&#39;)


def render_experiment(_experiment):
    template = get_template()
    sess = schema.Session()

    return template.render(name=_experiment.name,
                           description=_experiment.description,
                           start_date=_experiment.begin,
                           end_date=_experiment.end,
                           id=_experiment.id,
                           num_completed_runs=get_completed_runs(
                               sess, _experiment),
                           num_failed_runs=get_failed_runs(sess, _experiment))


def refresh_root_window(root):
    session = schema.Session()
    all_db_exps = experiments_from_db(session)
    menu_top = SubMenu(&#39;Experiments in database&#39;, [
        SubMenu(&#34;{name} - {desc}&#34;.format(
            name=elem.name, desc=elem.description), [
                urwid.Text(render_experiment(elem)),
                urwid.Divider(),
                Choice(&#34;Delete&#34;, top=root, payload=elem)
            ],
                top=root) for elem in all_db_exps
    ],
                       top=root)
    return menu_top.menu


def experiments_from_db(session):
    return session.query(schema.Experiment).all()


def get_completed_runs(session, exp):
    return session.query(sa.func.count(schema.Run.id)).\
        filter(schema.Run.experiment_group == exp.id).\
        filter(schema.Run.status == &#39;completed&#39;).scalar()


def get_failed_runs(session, exp):
    return session.query(sa.func.count(schema.Run.id)).\
        filter(schema.Run.experiment_group == exp.id).\
        filter(schema.Run.status != &#39;completed&#39;).scalar()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="benchbuild.cli.experiment.experiments_from_db"><code class="name flex">
<span>def <span class="ident">experiments_from_db</span></span>(<span>session)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def experiments_from_db(session):
    return session.query(schema.Experiment).all()</code></pre>
</details>
</dd>
<dt id="benchbuild.cli.experiment.get_completed_runs"><code class="name flex">
<span>def <span class="ident">get_completed_runs</span></span>(<span>session, exp)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_completed_runs(session, exp):
    return session.query(sa.func.count(schema.Run.id)).\
        filter(schema.Run.experiment_group == exp.id).\
        filter(schema.Run.status == &#39;completed&#39;).scalar()</code></pre>
</details>
</dd>
<dt id="benchbuild.cli.experiment.get_failed_runs"><code class="name flex">
<span>def <span class="ident">get_failed_runs</span></span>(<span>session, exp)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_failed_runs(session, exp):
    return session.query(sa.func.count(schema.Run.id)).\
        filter(schema.Run.experiment_group == exp.id).\
        filter(schema.Run.status != &#39;completed&#39;).scalar()</code></pre>
</details>
</dd>
<dt id="benchbuild.cli.experiment.get_template"><code class="name flex">
<span>def <span class="ident">get_template</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_template():
    env = Environment(trim_blocks=True,
                      lstrip_blocks=True,
                      loader=PackageLoader(&#39;benchbuild&#39;, &#39;utils/templates&#39;))
    return env.get_template(&#39;experiment_show.txt.inc&#39;)</code></pre>
</details>
</dd>
<dt id="benchbuild.cli.experiment.refresh_root_window"><code class="name flex">
<span>def <span class="ident">refresh_root_window</span></span>(<span>root)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_root_window(root):
    session = schema.Session()
    all_db_exps = experiments_from_db(session)
    menu_top = SubMenu(&#39;Experiments in database&#39;, [
        SubMenu(&#34;{name} - {desc}&#34;.format(
            name=elem.name, desc=elem.description), [
                urwid.Text(render_experiment(elem)),
                urwid.Divider(),
                Choice(&#34;Delete&#34;, top=root, payload=elem)
            ],
                top=root) for elem in all_db_exps
    ],
                       top=root)
    return menu_top.menu</code></pre>
</details>
</dd>
<dt id="benchbuild.cli.experiment.render_experiment"><code class="name flex">
<span>def <span class="ident">render_experiment</span></span>(<span>_experiment)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render_experiment(_experiment):
    template = get_template()
    sess = schema.Session()

    return template.render(name=_experiment.name,
                           description=_experiment.description,
                           start_date=_experiment.begin,
                           end_date=_experiment.end,
                           id=_experiment.id,
                           num_completed_runs=get_completed_runs(
                               sess, _experiment),
                           num_failed_runs=get_failed_runs(sess, _experiment))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="benchbuild.cli.experiment.BBExperiment"><code class="flex name class">
<span>class <span class="ident">BBExperiment</span></span>
<span>(</span><span>executable=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Manage BenchBuild's known experiments.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BBExperiment(cli.Application):
    &#34;&#34;&#34;Manage BenchBuild&#39;s known experiments.&#34;&#34;&#34;
    def main(self):
        if not self.nested_command:
            self.help()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>plumbum.cli.application.Application</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.cli.experiment.BBExperiment.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Implement me (no need to call super)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self):
    if not self.nested_command:
        self.help()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.cli.experiment.BBExperimentShow"><code class="flex name class">
<span>class <span class="ident">BBExperimentShow</span></span>
<span>(</span><span>executable=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Show completed experiments.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BBExperimentShow(cli.Application):
    &#34;&#34;&#34;Show completed experiments.&#34;&#34;&#34;
    def main(self):
        def maybe_exit(key):
            if key in (&#39;q&#39;, &#39;Q&#39;):
                raise urwid.ExitMainLoop()

        # yapf: disable
        palette = [(None, &#39;light gray&#39;, &#39;black&#39;),
                   (&#39;heading&#39;, &#39;black&#39;, &#39;light gray&#39;),
                   (&#39;line&#39;, &#39;black&#39;, &#39;light gray&#39;),
                   (&#39;options&#39;, &#39;dark gray&#39;, &#39;black&#39;),
                   (&#39;focus heading&#39;, &#39;white&#39;, &#39;dark red&#39;),
                   (&#39;focus line&#39;, &#39;black&#39;, &#39;dark red&#39;),
                   (&#39;focus options&#39;, &#39;black&#39;, &#39;light gray&#39;),
                   (&#39;selected&#39;, &#39;white&#39;, &#39;dark blue&#39;)]

        # yapf: enable
        top = HorizontalBoxes()
        top.open_box(refresh_root_window(top))
        loop = urwid.MainLoop(urwid.Filler(top, &#39;top&#39;, height=48),
                              palette=palette,
                              unhandled_input=maybe_exit)
        loop.run()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>plumbum.cli.application.Application</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.cli.experiment.BBExperimentShow.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Implement me (no need to call super)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self):
    def maybe_exit(key):
        if key in (&#39;q&#39;, &#39;Q&#39;):
            raise urwid.ExitMainLoop()

    # yapf: disable
    palette = [(None, &#39;light gray&#39;, &#39;black&#39;),
               (&#39;heading&#39;, &#39;black&#39;, &#39;light gray&#39;),
               (&#39;line&#39;, &#39;black&#39;, &#39;light gray&#39;),
               (&#39;options&#39;, &#39;dark gray&#39;, &#39;black&#39;),
               (&#39;focus heading&#39;, &#39;white&#39;, &#39;dark red&#39;),
               (&#39;focus line&#39;, &#39;black&#39;, &#39;dark red&#39;),
               (&#39;focus options&#39;, &#39;black&#39;, &#39;light gray&#39;),
               (&#39;selected&#39;, &#39;white&#39;, &#39;dark blue&#39;)]

    # yapf: enable
    top = HorizontalBoxes()
    top.open_box(refresh_root_window(top))
    loop = urwid.MainLoop(urwid.Filler(top, &#39;top&#39;, height=48),
                          palette=palette,
                          unhandled_input=maybe_exit)
    loop.run()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.cli.experiment.BBExperimentView"><code class="flex name class">
<span>class <span class="ident">BBExperimentView</span></span>
<span>(</span><span>executable=None)</span>
</code></dt>
<dd>
<section class="desc"><p>View available experiments.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BBExperimentView(cli.Application):
    &#34;&#34;&#34;View available experiments.&#34;&#34;&#34;
    def main(self):
        all_exps = experiment.discovered()
        for exp_cls in all_exps.values():
            print(exp_cls.NAME)
            docstring = exp_cls.__doc__ or &#34;-- no docstring --&#34;
            print((&#34;    &#34; + docstring))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>plumbum.cli.application.Application</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.cli.experiment.BBExperimentView.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Implement me (no need to call super)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self):
    all_exps = experiment.discovered()
    for exp_cls in all_exps.values():
        print(exp_cls.NAME)
        docstring = exp_cls.__doc__ or &#34;-- no docstring --&#34;
        print((&#34;    &#34; + docstring))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.cli.experiment.Choice"><code class="flex name class">
<span>class <span class="ident">Choice</span></span>
<span>(</span><span>caption, payload, top)</span>
</code></dt>
<dd>
<section class="desc"><p>Widget base class</p>
<div class="admonition attribute">
<p class="admonition-title">Attribute:&ensp;_selectable</p>
<p>:annotation: = False</p>
<p>The default :meth:<code>.selectable</code> method returns this
value.</p>
</div>
<div class="admonition attribute">
<p class="admonition-title">Attribute:&ensp;_sizing</p>
<p>:annotation: = frozenset(['flow', 'box', 'fixed'])</p>
<p>The default :meth:<code>.sizing</code> method returns this value.</p>
</div>
<div class="admonition attribute">
<p class="admonition-title">Attribute:&ensp;_command_map</p>
<p>:annotation: = urwid.command_map</p>
<p>A shared :class:<code>CommandMap</code> instance. May be redefined
in subclasses or widget instances.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;render(size, focus=False)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
must be implemented by any concrete subclass</p>
</div>
<p>:param size: One of the following,
<em>maxcol</em> and <em>maxrow</em> are integers &gt; 0:</p>
<pre><code>         (*maxcol*, *maxrow*)
           for box sizing -- the parent chooses the exact
           size of this widget

         (*maxcol*,)
           for flow sizing -- the parent chooses only the
           number of columns for this widget

         ()
           for fixed sizing -- this widget is a fixed size
           which can't be adjusted by the parent
</code></pre>
<p>:type size: widget size
:param focus: set to <code>True</code> if this widget or one of its children
is in focus
:type focus: bool</p>
<p>:returns: A :class:<code>Canvas</code> subclass instance containing the
rendered content of this widget</p>
<p>:class:<code>Text</code> widgets return a :class:<code>TextCanvas</code> (arbitrary text and
display attributes), :class:<code>SolidFill</code> widgets return a
:class:<code>SolidCanvas</code> (a single character repeated across
the whole surface) and container widgets return a
:class:<code>CompositeCanvas</code> (one or more other canvases
arranged arbitrarily).</p>
<p>If <em>focus</em> is <code>False</code>, the returned canvas may not have a cursor
position set.</p>
<p>There is some metaclass magic defined in the :class:<code>Widget</code>
metaclass :class:<code>WidgetMeta</code> that causes the
result of this method to be cached by :class:<code>CanvasCache</code>.
Later calls will automatically look up the value in the cache first.</p>
<p>As a small optimization the class variable :attr:<code>ignore_focus</code>
may be defined and set to <code>True</code> if this widget renders the same
canvas regardless of the value of the <em>focus</em> parameter.</p>
<p>Any time the content of a widget changes it should call
:meth:<code>_invalidate</code> to remove any cached canvases, or the widget
may render the cached canvas instead of creating a new one.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;rows(size, focus=False)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
must be implemented by any flow widget.
See :meth:<code>.sizing</code>.</p>
</div>
<p>See :meth:<code>Widget.render</code> for parameter details.</p>
<p>:returns: The number of rows required for this widget given a number
of columns in <em>size</em></p>
<p>This is the method flow widgets use to communicate their size to other
widgets without having to render a canvas. This should be a quick
calculation as this function may be called a number of times in normal
operation. If your implementation may take a long time you should add
your own caching here.</p>
<p>There is some metaclass magic defined in the :class:<code>Widget</code>
metaclass :class:<code>WidgetMeta</code> that causes the
result of this function to be retrieved from any
canvas cached by :class:<code>CanvasCache</code>, so if your widget
has been rendered you may not receive calls to this function. The class
variable :attr:<code>ignore_focus</code> may be defined and set to <code>True</code> if this
widget renders the same size regardless of the value of the <em>focus</em>
parameter.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;keypress(size, key)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
must be implemented by any selectable widget.
See :meth:<code>.selectable</code>.</p>
</div>
<p>:param size: See :meth:<code>Widget.render</code> for details
:type size: widget size
:param key: a single keystroke value; see :ref:<code>keyboard-input</code>
:type key: bytes or unicode</p>
<p>:returns: <code>None</code> if <em>key</em> was handled by this widget or
<em>key</em> (the same value passed) if <em>key</em> was not handled
by this widget</p>
<p>Container widgets will typically call the :meth:<code>keypress</code> method on
whichever of their children is set as the focus.</p>
<p>The standard widgets use :attr:<code>_command_map</code> to
determine what action should be performed for a given <em>key</em>. You may
modify these values to your liking globally, at some level in the
widget hierarchy or on individual widgets. See :class:<code>CommandMap</code>
for the defaults.</p>
<p>In your own widgets you may use whatever logic you like: filtering or
translating keys, selectively passing along events etc.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;mouse_event(size, event, button, col, row, focus)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
may be implemented by a subclass.
Not implementing this
method is equivalent to having a method that always returns
<code>False</code>.</p>
</div>
<p>:param size: See :meth:<code>Widget.render</code> for details.
:type size: widget size
:param event: Values such as <code>'mouse press'</code>, <code>'ctrl mouse press'</code>,
<code>'mouse release'</code>, <code>'meta mouse release'</code>,
<code>'mouse drag'</code>; see :ref:<code>mouse-input</code>
:type event: mouse event
:param button: 1 through 5 for press events, often 0 for release events
(which button was released is often not known)
:type button: int
:param col: Column of the event, 0 is the left edge of this widget
:type col: int
:param row: Row of the event, 0 it the top row of this widget
:type row: int
:param focus: Set to <code>True</code> if this widget or one of its children
is in focus
:type focus: bool</p>
<p>:returns: <code>True</code> if the event was handled by this widget, <code>False</code>
otherwise</p>
<p>Container widgets will typically call the :meth:<code>mouse_event</code> method on
whichever of their children is at the position (<em>col</em>, <em>row</em>).</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;get_cursor_coords(size)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
must be implemented by any widget that may return cursor
coordinates as part of the canvas that :meth:<code>render</code> returns.</p>
</div>
<p>:param size: See :meth:<code>Widget.render</code> for details.
:type size: widget size</p>
<p>:returns: (<em>col</em>, <em>row</em>) if this widget has a cursor, <code>None</code> otherwise</p>
<p>Return the cursor coordinates (<em>col</em>, <em>row</em>) of a cursor that will appear
as part of the canvas rendered by this widget when in focus, or <code>None</code>
if no cursor is displayed.</p>
<p>The :class:<code>ListBox</code> widget
uses this method to make sure a cursor in the focus widget is not
scrolled out of view.
It is a separate method to avoid having to render
the whole widget while calculating layout.</p>
<p>Container widgets will typically call the :meth:<code>.get_cursor_coords</code>
method on their focus widget.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;get_pref_col(size)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
may be implemented by a subclass.</p>
</div>
<p>:param size: See :meth:<code>Widget.render</code> for details.
:type size: widget size</p>
<p>:returns: a column number or <code>'left'</code> for the leftmost available
column or <code>'right'</code> for the rightmost available column</p>
<p>Return the preferred column for the cursor to be displayed in this
widget. This value might not be the same as the column returned from
:meth:<code>get_cursor_coords</code>.</p>
<p>The :class:<code>ListBox</code> and :class:<code>Pile</code>
widgets call this method on a widget losing focus and use the value
returned to call :meth:<code>.move_cursor_to_coords</code> on the widget becoming
the focus. This allows the focus to move up and down through widgets
while keeping the cursor in approximately the same column on screen.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;move_cursor_to_coords(size, col, row)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
may be implemented by a subclass.
Not implementing this
method is equivalent to having a method that always returns
<code>False</code>.</p>
</div>
<p>:param size: See :meth:<code>Widget.render</code> for details.
:type size: widget size
:param col: new column for the cursor, 0 is the left edge of this widget
:type col: int
:param row: new row for the cursor, 0 it the top row of this widget
:type row: int</p>
<p>:returns: <code>True</code> if the position was set successfully anywhere on
<em>row</em>, <code>False</code> otherwise</p>
</div>
<p>w &ndash; widget to wrap, stored as self._w</p>
<p>This object will pass the functions defined in Widget interface
definition to self._w.</p>
<p>The purpose of this widget is to provide a base class for
widgets that compose other widgets for their display and
behaviour.
The details of that composition should not affect
users of the subclass.
The subclass may decide to expose some
of the wrapped widgets by behaving like a ContainerWidget or
WidgetDecoration, or it may hide them from outside access.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Choice(urwid.WidgetWrap):
    def __init__(self, caption, payload, top):
        super(Choice, self).__init__(MenuButton(caption, self.item_chosen))
        self.caption = caption
        self.top = top
        self.payload = payload

    def item_chosen(self, _):
        session = schema.Session()
        session.delete(self.payload)

        def confirm(_):
            session.commit()
            self.top.clear()
            self.top.open_box(refresh_root_window(self.top))

        def cancel(_):
            session.rollback()
            self.top.clear()
            self.top.open_box(refresh_root_window(self.top))

        response = urwid.Text([
            &#39;Really delete: {name} {desc}?&#39;.format(
                name=self.payload.name, desc=self.payload.description), &#39;\n&#39;
        ])
        done = MenuButton(&#39;Ok&#39;, confirm)
        cancel = MenuButton(&#39;Cancel&#39;, cancel)
        response_box = urwid.Filler(urwid.Pile([response, done, cancel]))
        self.top.open_box(urwid.AttrMap(response_box, &#39;options&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>urwid.widget.WidgetWrap</li>
<li>urwid.widget.delegate_to_widget_mixin.<locals>.DelegateToWidgetMixin</li>
<li>urwid.widget.Widget</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.cli.experiment.Choice.item_chosen"><code class="name flex">
<span>def <span class="ident">item_chosen</span></span>(<span>self, _)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def item_chosen(self, _):
    session = schema.Session()
    session.delete(self.payload)

    def confirm(_):
        session.commit()
        self.top.clear()
        self.top.open_box(refresh_root_window(self.top))

    def cancel(_):
        session.rollback()
        self.top.clear()
        self.top.open_box(refresh_root_window(self.top))

    response = urwid.Text([
        &#39;Really delete: {name} {desc}?&#39;.format(
            name=self.payload.name, desc=self.payload.description), &#39;\n&#39;
    ])
    done = MenuButton(&#39;Ok&#39;, confirm)
    cancel = MenuButton(&#39;Cancel&#39;, cancel)
    response_box = urwid.Filler(urwid.Pile([response, done, cancel]))
    self.top.open_box(urwid.AttrMap(response_box, &#39;options&#39;))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.cli.experiment.HorizontalBoxes"><code class="flex name class">
<span>class <span class="ident">HorizontalBoxes</span></span>
</code></dt>
<dd>
<section class="desc"><p>Widgets arranged horizontally in columns from left to right</p>
<p>:param widget_list: iterable of flow or box widgets
:param dividechars: number of blank characters between columns
:param focus_column: index into widget_list of column in focus,
if <code>None</code> the first selectable widget will be chosen.
:param min_width: minimum width for each column which is not
calling widget.pack() in <em>widget_list</em>.
:param box_columns: a list of column indexes containing box widgets
whose height is set to the maximum of the rows
required by columns not listed in <em>box_columns</em>.</p>
<p><em>widget_list</em> may also contain tuples such as:</p>
<p>(<em>given_width</em>, <em>widget</em>)
make this column <em>given_width</em> screen columns wide, where <em>given_width</em>
is an int
(<code>'pack'</code>, <em>widget</em>)
call :meth:<code>pack() &lt;Widget.pack&gt;</code> to calculate the width of this column
(<code>'weight'</code>, <em>weight</em>, <em>widget</em>)
give this column a relative <em>weight</em> (number) to calculate its width from the
screen columns remaining</p>
<p>Widgets not in a tuple are the same as (<code>'weight'</code>, <code>1</code>, <em>widget</em>)</p>
<p>If the Columns widget is treated as a box widget then all children
are treated as box widgets, and <em>box_columns</em> is ignored.</p>
<p>If the Columns widget is treated as a flow widget then the rows
are calculated as the largest rows() returned from all columns
except the ones listed in <em>box_columns</em>.
The box widgets in
<em>box_columns</em> will be displayed with this calculated number of rows,
filling the full height.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HorizontalBoxes(urwid.Columns):
    def __init__(self):
        super(HorizontalBoxes, self).__init__([], dividechars=1)

    def clear(self):
        self.contents = []

    def open_box(self, box):
        focus_map = {
            &#39;heading&#39;: &#39;focus heading&#39;,
            &#39;options&#39;: &#39;focus options&#39;,
            &#39;line&#39;: &#39;focus line&#39;
        }
        if self.contents:
            del self.contents[self.focus_position + 1:]
        self.contents.append(
            (urwid.AttrMap(box, &#39;options&#39;,
                           focus_map), self.options(&#39;given&#39;, 80)))
        self.focus_position = len(self.contents) - 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>urwid.container.Columns</li>
<li>urwid.widget.Widget</li>
<li>urwid.container.WidgetContainerMixin</li>
<li>urwid.container.WidgetContainerListContentsMixin</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.cli.experiment.HorizontalBoxes.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    self.contents = []</code></pre>
</details>
</dd>
<dt id="benchbuild.cli.experiment.HorizontalBoxes.open_box"><code class="name flex">
<span>def <span class="ident">open_box</span></span>(<span>self, box)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_box(self, box):
    focus_map = {
        &#39;heading&#39;: &#39;focus heading&#39;,
        &#39;options&#39;: &#39;focus options&#39;,
        &#39;line&#39;: &#39;focus line&#39;
    }
    if self.contents:
        del self.contents[self.focus_position + 1:]
    self.contents.append(
        (urwid.AttrMap(box, &#39;options&#39;,
                       focus_map), self.options(&#39;given&#39;, 80)))
    self.focus_position = len(self.contents) - 1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.cli.experiment.MenuButton"><code class="flex name class">
<span>class <span class="ident">MenuButton</span></span>
<span>(</span><span>caption, callback)</span>
</code></dt>
<dd>
<section class="desc"><p>Widget base class</p>
<div class="admonition attribute">
<p class="admonition-title">Attribute:&ensp;_selectable</p>
<p>:annotation: = False</p>
<p>The default :meth:<code>.selectable</code> method returns this
value.</p>
</div>
<div class="admonition attribute">
<p class="admonition-title">Attribute:&ensp;_sizing</p>
<p>:annotation: = frozenset(['flow', 'box', 'fixed'])</p>
<p>The default :meth:<code>.sizing</code> method returns this value.</p>
</div>
<div class="admonition attribute">
<p class="admonition-title">Attribute:&ensp;_command_map</p>
<p>:annotation: = urwid.command_map</p>
<p>A shared :class:<code>CommandMap</code> instance. May be redefined
in subclasses or widget instances.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;render(size, focus=False)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
must be implemented by any concrete subclass</p>
</div>
<p>:param size: One of the following,
<em>maxcol</em> and <em>maxrow</em> are integers &gt; 0:</p>
<pre><code>         (*maxcol*, *maxrow*)
           for box sizing -- the parent chooses the exact
           size of this widget

         (*maxcol*,)
           for flow sizing -- the parent chooses only the
           number of columns for this widget

         ()
           for fixed sizing -- this widget is a fixed size
           which can't be adjusted by the parent
</code></pre>
<p>:type size: widget size
:param focus: set to <code>True</code> if this widget or one of its children
is in focus
:type focus: bool</p>
<p>:returns: A :class:<code>Canvas</code> subclass instance containing the
rendered content of this widget</p>
<p>:class:<code>Text</code> widgets return a :class:<code>TextCanvas</code> (arbitrary text and
display attributes), :class:<code>SolidFill</code> widgets return a
:class:<code>SolidCanvas</code> (a single character repeated across
the whole surface) and container widgets return a
:class:<code>CompositeCanvas</code> (one or more other canvases
arranged arbitrarily).</p>
<p>If <em>focus</em> is <code>False</code>, the returned canvas may not have a cursor
position set.</p>
<p>There is some metaclass magic defined in the :class:<code>Widget</code>
metaclass :class:<code>WidgetMeta</code> that causes the
result of this method to be cached by :class:<code>CanvasCache</code>.
Later calls will automatically look up the value in the cache first.</p>
<p>As a small optimization the class variable :attr:<code>ignore_focus</code>
may be defined and set to <code>True</code> if this widget renders the same
canvas regardless of the value of the <em>focus</em> parameter.</p>
<p>Any time the content of a widget changes it should call
:meth:<code>_invalidate</code> to remove any cached canvases, or the widget
may render the cached canvas instead of creating a new one.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;rows(size, focus=False)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
must be implemented by any flow widget.
See :meth:<code>.sizing</code>.</p>
</div>
<p>See :meth:<code>Widget.render</code> for parameter details.</p>
<p>:returns: The number of rows required for this widget given a number
of columns in <em>size</em></p>
<p>This is the method flow widgets use to communicate their size to other
widgets without having to render a canvas. This should be a quick
calculation as this function may be called a number of times in normal
operation. If your implementation may take a long time you should add
your own caching here.</p>
<p>There is some metaclass magic defined in the :class:<code>Widget</code>
metaclass :class:<code>WidgetMeta</code> that causes the
result of this function to be retrieved from any
canvas cached by :class:<code>CanvasCache</code>, so if your widget
has been rendered you may not receive calls to this function. The class
variable :attr:<code>ignore_focus</code> may be defined and set to <code>True</code> if this
widget renders the same size regardless of the value of the <em>focus</em>
parameter.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;keypress(size, key)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
must be implemented by any selectable widget.
See :meth:<code>.selectable</code>.</p>
</div>
<p>:param size: See :meth:<code>Widget.render</code> for details
:type size: widget size
:param key: a single keystroke value; see :ref:<code>keyboard-input</code>
:type key: bytes or unicode</p>
<p>:returns: <code>None</code> if <em>key</em> was handled by this widget or
<em>key</em> (the same value passed) if <em>key</em> was not handled
by this widget</p>
<p>Container widgets will typically call the :meth:<code>keypress</code> method on
whichever of their children is set as the focus.</p>
<p>The standard widgets use :attr:<code>_command_map</code> to
determine what action should be performed for a given <em>key</em>. You may
modify these values to your liking globally, at some level in the
widget hierarchy or on individual widgets. See :class:<code>CommandMap</code>
for the defaults.</p>
<p>In your own widgets you may use whatever logic you like: filtering or
translating keys, selectively passing along events etc.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;mouse_event(size, event, button, col, row, focus)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
may be implemented by a subclass.
Not implementing this
method is equivalent to having a method that always returns
<code>False</code>.</p>
</div>
<p>:param size: See :meth:<code>Widget.render</code> for details.
:type size: widget size
:param event: Values such as <code>'mouse press'</code>, <code>'ctrl mouse press'</code>,
<code>'mouse release'</code>, <code>'meta mouse release'</code>,
<code>'mouse drag'</code>; see :ref:<code>mouse-input</code>
:type event: mouse event
:param button: 1 through 5 for press events, often 0 for release events
(which button was released is often not known)
:type button: int
:param col: Column of the event, 0 is the left edge of this widget
:type col: int
:param row: Row of the event, 0 it the top row of this widget
:type row: int
:param focus: Set to <code>True</code> if this widget or one of its children
is in focus
:type focus: bool</p>
<p>:returns: <code>True</code> if the event was handled by this widget, <code>False</code>
otherwise</p>
<p>Container widgets will typically call the :meth:<code>mouse_event</code> method on
whichever of their children is at the position (<em>col</em>, <em>row</em>).</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;get_cursor_coords(size)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
must be implemented by any widget that may return cursor
coordinates as part of the canvas that :meth:<code>render</code> returns.</p>
</div>
<p>:param size: See :meth:<code>Widget.render</code> for details.
:type size: widget size</p>
<p>:returns: (<em>col</em>, <em>row</em>) if this widget has a cursor, <code>None</code> otherwise</p>
<p>Return the cursor coordinates (<em>col</em>, <em>row</em>) of a cursor that will appear
as part of the canvas rendered by this widget when in focus, or <code>None</code>
if no cursor is displayed.</p>
<p>The :class:<code>ListBox</code> widget
uses this method to make sure a cursor in the focus widget is not
scrolled out of view.
It is a separate method to avoid having to render
the whole widget while calculating layout.</p>
<p>Container widgets will typically call the :meth:<code>.get_cursor_coords</code>
method on their focus widget.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;get_pref_col(size)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
may be implemented by a subclass.</p>
</div>
<p>:param size: See :meth:<code>Widget.render</code> for details.
:type size: widget size</p>
<p>:returns: a column number or <code>'left'</code> for the leftmost available
column or <code>'right'</code> for the rightmost available column</p>
<p>Return the preferred column for the cursor to be displayed in this
widget. This value might not be the same as the column returned from
:meth:<code>get_cursor_coords</code>.</p>
<p>The :class:<code>ListBox</code> and :class:<code>Pile</code>
widgets call this method on a widget losing focus and use the value
returned to call :meth:<code>.move_cursor_to_coords</code> on the widget becoming
the focus. This allows the focus to move up and down through widgets
while keeping the cursor in approximately the same column on screen.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;move_cursor_to_coords(size, col, row)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
may be implemented by a subclass.
Not implementing this
method is equivalent to having a method that always returns
<code>False</code>.</p>
</div>
<p>:param size: See :meth:<code>Widget.render</code> for details.
:type size: widget size
:param col: new column for the cursor, 0 is the left edge of this widget
:type col: int
:param row: new row for the cursor, 0 it the top row of this widget
:type row: int</p>
<p>:returns: <code>True</code> if the position was set successfully anywhere on
<em>row</em>, <code>False</code> otherwise</p>
</div>
<p>:param label: markup for button label
:param on_press: shorthand for connect_signal()
function call for a single callback
:param user_data: user_data for on_press</p>
<p>Signals supported: <code>'click'</code></p>
<p>Register signal handler with::</p>
<p>urwid.connect_signal(button, 'click', callback, user_data)</p>
<p>where callback is callback(button [,user_data])
Unregister signal handlers with::</p>
<p>urwid.disconnect_signal(button, 'click', callback, user_data)</p>
<pre><code>&gt;&gt;&gt; Button(u"Ok")
&lt;Button selectable flow widget 'Ok'&gt;
&gt;&gt;&gt; b = Button("Cancel")
&gt;&gt;&gt; b.render((15,), focus=True).text # ... = b in Python 3
[...'&lt; Cancel      &gt;']
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MenuButton(urwid.Button):
    def __init__(self, caption, callback):
        super(MenuButton, self).__init__(&#34;&#34;)
        urwid.connect_signal(self, &#39;click&#39;, callback)
        self._w = urwid.AttrMap(
            urwid.SelectableIcon([u&#39;  \N{BULLET} &#39;, caption], 2), None,
            &#39;selected&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>urwid.wimp.Button</li>
<li>urwid.widget.WidgetWrap</li>
<li>urwid.widget.delegate_to_widget_mixin.<locals>.DelegateToWidgetMixin</li>
<li>urwid.widget.Widget</li>
</ul>
</dd>
<dt id="benchbuild.cli.experiment.SubMenu"><code class="flex name class">
<span>class <span class="ident">SubMenu</span></span>
<span>(</span><span>caption, choices, top)</span>
</code></dt>
<dd>
<section class="desc"><p>Widget base class</p>
<div class="admonition attribute">
<p class="admonition-title">Attribute:&ensp;_selectable</p>
<p>:annotation: = False</p>
<p>The default :meth:<code>.selectable</code> method returns this
value.</p>
</div>
<div class="admonition attribute">
<p class="admonition-title">Attribute:&ensp;_sizing</p>
<p>:annotation: = frozenset(['flow', 'box', 'fixed'])</p>
<p>The default :meth:<code>.sizing</code> method returns this value.</p>
</div>
<div class="admonition attribute">
<p class="admonition-title">Attribute:&ensp;_command_map</p>
<p>:annotation: = urwid.command_map</p>
<p>A shared :class:<code>CommandMap</code> instance. May be redefined
in subclasses or widget instances.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;render(size, focus=False)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
must be implemented by any concrete subclass</p>
</div>
<p>:param size: One of the following,
<em>maxcol</em> and <em>maxrow</em> are integers &gt; 0:</p>
<pre><code>         (*maxcol*, *maxrow*)
           for box sizing -- the parent chooses the exact
           size of this widget

         (*maxcol*,)
           for flow sizing -- the parent chooses only the
           number of columns for this widget

         ()
           for fixed sizing -- this widget is a fixed size
           which can't be adjusted by the parent
</code></pre>
<p>:type size: widget size
:param focus: set to <code>True</code> if this widget or one of its children
is in focus
:type focus: bool</p>
<p>:returns: A :class:<code>Canvas</code> subclass instance containing the
rendered content of this widget</p>
<p>:class:<code>Text</code> widgets return a :class:<code>TextCanvas</code> (arbitrary text and
display attributes), :class:<code>SolidFill</code> widgets return a
:class:<code>SolidCanvas</code> (a single character repeated across
the whole surface) and container widgets return a
:class:<code>CompositeCanvas</code> (one or more other canvases
arranged arbitrarily).</p>
<p>If <em>focus</em> is <code>False</code>, the returned canvas may not have a cursor
position set.</p>
<p>There is some metaclass magic defined in the :class:<code>Widget</code>
metaclass :class:<code>WidgetMeta</code> that causes the
result of this method to be cached by :class:<code>CanvasCache</code>.
Later calls will automatically look up the value in the cache first.</p>
<p>As a small optimization the class variable :attr:<code>ignore_focus</code>
may be defined and set to <code>True</code> if this widget renders the same
canvas regardless of the value of the <em>focus</em> parameter.</p>
<p>Any time the content of a widget changes it should call
:meth:<code>_invalidate</code> to remove any cached canvases, or the widget
may render the cached canvas instead of creating a new one.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;rows(size, focus=False)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
must be implemented by any flow widget.
See :meth:<code>.sizing</code>.</p>
</div>
<p>See :meth:<code>Widget.render</code> for parameter details.</p>
<p>:returns: The number of rows required for this widget given a number
of columns in <em>size</em></p>
<p>This is the method flow widgets use to communicate their size to other
widgets without having to render a canvas. This should be a quick
calculation as this function may be called a number of times in normal
operation. If your implementation may take a long time you should add
your own caching here.</p>
<p>There is some metaclass magic defined in the :class:<code>Widget</code>
metaclass :class:<code>WidgetMeta</code> that causes the
result of this function to be retrieved from any
canvas cached by :class:<code>CanvasCache</code>, so if your widget
has been rendered you may not receive calls to this function. The class
variable :attr:<code>ignore_focus</code> may be defined and set to <code>True</code> if this
widget renders the same size regardless of the value of the <em>focus</em>
parameter.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;keypress(size, key)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
must be implemented by any selectable widget.
See :meth:<code>.selectable</code>.</p>
</div>
<p>:param size: See :meth:<code>Widget.render</code> for details
:type size: widget size
:param key: a single keystroke value; see :ref:<code>keyboard-input</code>
:type key: bytes or unicode</p>
<p>:returns: <code>None</code> if <em>key</em> was handled by this widget or
<em>key</em> (the same value passed) if <em>key</em> was not handled
by this widget</p>
<p>Container widgets will typically call the :meth:<code>keypress</code> method on
whichever of their children is set as the focus.</p>
<p>The standard widgets use :attr:<code>_command_map</code> to
determine what action should be performed for a given <em>key</em>. You may
modify these values to your liking globally, at some level in the
widget hierarchy or on individual widgets. See :class:<code>CommandMap</code>
for the defaults.</p>
<p>In your own widgets you may use whatever logic you like: filtering or
translating keys, selectively passing along events etc.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;mouse_event(size, event, button, col, row, focus)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
may be implemented by a subclass.
Not implementing this
method is equivalent to having a method that always returns
<code>False</code>.</p>
</div>
<p>:param size: See :meth:<code>Widget.render</code> for details.
:type size: widget size
:param event: Values such as <code>'mouse press'</code>, <code>'ctrl mouse press'</code>,
<code>'mouse release'</code>, <code>'meta mouse release'</code>,
<code>'mouse drag'</code>; see :ref:<code>mouse-input</code>
:type event: mouse event
:param button: 1 through 5 for press events, often 0 for release events
(which button was released is often not known)
:type button: int
:param col: Column of the event, 0 is the left edge of this widget
:type col: int
:param row: Row of the event, 0 it the top row of this widget
:type row: int
:param focus: Set to <code>True</code> if this widget or one of its children
is in focus
:type focus: bool</p>
<p>:returns: <code>True</code> if the event was handled by this widget, <code>False</code>
otherwise</p>
<p>Container widgets will typically call the :meth:<code>mouse_event</code> method on
whichever of their children is at the position (<em>col</em>, <em>row</em>).</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;get_cursor_coords(size)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
must be implemented by any widget that may return cursor
coordinates as part of the canvas that :meth:<code>render</code> returns.</p>
</div>
<p>:param size: See :meth:<code>Widget.render</code> for details.
:type size: widget size</p>
<p>:returns: (<em>col</em>, <em>row</em>) if this widget has a cursor, <code>None</code> otherwise</p>
<p>Return the cursor coordinates (<em>col</em>, <em>row</em>) of a cursor that will appear
as part of the canvas rendered by this widget when in focus, or <code>None</code>
if no cursor is displayed.</p>
<p>The :class:<code>ListBox</code> widget
uses this method to make sure a cursor in the focus widget is not
scrolled out of view.
It is a separate method to avoid having to render
the whole widget while calculating layout.</p>
<p>Container widgets will typically call the :meth:<code>.get_cursor_coords</code>
method on their focus widget.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;get_pref_col(size)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
may be implemented by a subclass.</p>
</div>
<p>:param size: See :meth:<code>Widget.render</code> for details.
:type size: widget size</p>
<p>:returns: a column number or <code>'left'</code> for the leftmost available
column or <code>'right'</code> for the rightmost available column</p>
<p>Return the preferred column for the cursor to be displayed in this
widget. This value might not be the same as the column returned from
:meth:<code>get_cursor_coords</code>.</p>
<p>The :class:<code>ListBox</code> and :class:<code>Pile</code>
widgets call this method on a widget losing focus and use the value
returned to call :meth:<code>.move_cursor_to_coords</code> on the widget becoming
the focus. This allows the focus to move up and down through widgets
while keeping the cursor in approximately the same column on screen.</p>
</div>
<div class="admonition method">
<p class="admonition-title">Method:&ensp;move_cursor_to_coords(size, col, row)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is not implemented in :class:<code>.Widget</code> but
may be implemented by a subclass.
Not implementing this
method is equivalent to having a method that always returns
<code>False</code>.</p>
</div>
<p>:param size: See :meth:<code>Widget.render</code> for details.
:type size: widget size
:param col: new column for the cursor, 0 is the left edge of this widget
:type col: int
:param row: new row for the cursor, 0 it the top row of this widget
:type row: int</p>
<p>:returns: <code>True</code> if the position was set successfully anywhere on
<em>row</em>, <code>False</code> otherwise</p>
</div>
<p>w &ndash; widget to wrap, stored as self._w</p>
<p>This object will pass the functions defined in Widget interface
definition to self._w.</p>
<p>The purpose of this widget is to provide a base class for
widgets that compose other widgets for their display and
behaviour.
The details of that composition should not affect
users of the subclass.
The subclass may decide to expose some
of the wrapped widgets by behaving like a ContainerWidget or
WidgetDecoration, or it may hide them from outside access.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubMenu(urwid.WidgetWrap):
    def __init__(self, caption, choices, top):
        super(SubMenu, self).__init__(
            MenuButton([caption, &#34;\N{HORIZONTAL ELLIPSIS}&#34;], self.open_menu))
        line = urwid.Divider(&#39;\N{LOWER ONE QUARTER BLOCK}&#39;)
        listbox = urwid.ListBox(
            urwid.SimpleFocusListWalker([
                urwid.AttrMap(urwid.Text([&#34;\n  &#34;, caption]), &#39;heading&#39;),
                urwid.AttrMap(line, &#39;line&#39;),
                urwid.Divider()
            ] + choices + [urwid.Divider()]))
        self.menu = urwid.AttrMap(listbox, &#39;options&#39;)
        self.top = top

    def open_menu(self, _):
        self.top.open_box(self.menu)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>urwid.widget.WidgetWrap</li>
<li>urwid.widget.delegate_to_widget_mixin.<locals>.DelegateToWidgetMixin</li>
<li>urwid.widget.Widget</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.cli.experiment.SubMenu.open_menu"><code class="name flex">
<span>def <span class="ident">open_menu</span></span>(<span>self, _)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_menu(self, _):
    self.top.open_box(self.menu)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="benchbuild.cli" href="index.html">benchbuild.cli</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="benchbuild.cli.experiment.experiments_from_db" href="#benchbuild.cli.experiment.experiments_from_db">experiments_from_db</a></code></li>
<li><code><a title="benchbuild.cli.experiment.get_completed_runs" href="#benchbuild.cli.experiment.get_completed_runs">get_completed_runs</a></code></li>
<li><code><a title="benchbuild.cli.experiment.get_failed_runs" href="#benchbuild.cli.experiment.get_failed_runs">get_failed_runs</a></code></li>
<li><code><a title="benchbuild.cli.experiment.get_template" href="#benchbuild.cli.experiment.get_template">get_template</a></code></li>
<li><code><a title="benchbuild.cli.experiment.refresh_root_window" href="#benchbuild.cli.experiment.refresh_root_window">refresh_root_window</a></code></li>
<li><code><a title="benchbuild.cli.experiment.render_experiment" href="#benchbuild.cli.experiment.render_experiment">render_experiment</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="benchbuild.cli.experiment.BBExperiment" href="#benchbuild.cli.experiment.BBExperiment">BBExperiment</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.cli.experiment.BBExperiment.main" href="#benchbuild.cli.experiment.BBExperiment.main">main</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.cli.experiment.BBExperimentShow" href="#benchbuild.cli.experiment.BBExperimentShow">BBExperimentShow</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.cli.experiment.BBExperimentShow.main" href="#benchbuild.cli.experiment.BBExperimentShow.main">main</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.cli.experiment.BBExperimentView" href="#benchbuild.cli.experiment.BBExperimentView">BBExperimentView</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.cli.experiment.BBExperimentView.main" href="#benchbuild.cli.experiment.BBExperimentView.main">main</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.cli.experiment.Choice" href="#benchbuild.cli.experiment.Choice">Choice</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.cli.experiment.Choice.item_chosen" href="#benchbuild.cli.experiment.Choice.item_chosen">item_chosen</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.cli.experiment.HorizontalBoxes" href="#benchbuild.cli.experiment.HorizontalBoxes">HorizontalBoxes</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.cli.experiment.HorizontalBoxes.clear" href="#benchbuild.cli.experiment.HorizontalBoxes.clear">clear</a></code></li>
<li><code><a title="benchbuild.cli.experiment.HorizontalBoxes.open_box" href="#benchbuild.cli.experiment.HorizontalBoxes.open_box">open_box</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.cli.experiment.MenuButton" href="#benchbuild.cli.experiment.MenuButton">MenuButton</a></code></h4>
</li>
<li>
<h4><code><a title="benchbuild.cli.experiment.SubMenu" href="#benchbuild.cli.experiment.SubMenu">SubMenu</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.cli.experiment.SubMenu.open_menu" href="#benchbuild.cli.experiment.SubMenu.open_menu">open_menu</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>