<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>benchbuild.container API documentation</title>
<meta name="description" content="Container construction tool â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>benchbuild.container</code></h1>
</header>
<section id="section-intro">
<p>Container construction tool.</p>
<p>This tool assists in the creation of customized uchroot containers.
You can define strategies and apply them on a given container base-image
to have a fixed way of creating a user-space environment.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Container construction tool.

This tool assists in the creation of customized uchroot containers.
You can define strategies and apply them on a given container base-image
to have a fixed way of creating a user-space environment.
&#34;&#34;&#34;
import logging
import os
import sys
from abc import abstractmethod

from plumbum import FG, TF, ProcessExecutionError, cli, local

from benchbuild.settings import CFG
from benchbuild.utils import bootstrap, container, download, log, run, uchroot
from benchbuild.utils import user_interface as ui
from benchbuild.utils.cmd import bash, mkdir, mv, rm, tar

LOG = logging.getLogger(__name__)


def clean_directories(builddir, in_dir=True, out_dir=True):
    &#34;&#34;&#34;Remove the in and out of the container if confirmed by the user.&#34;&#34;&#34;
    container_in = local.path(builddir) / &#34;container-in&#34;
    container_out = local.path(builddir) / &#34;container-out&#34;

    if in_dir and container_in.exists():
        if ui.ask(&#34;Should I delete &#39;{0}&#39;?&#34;.format(container_in)):
            container_in.delete()
    if out_dir and container_out.exists():
        if ui.ask(&#34;Should I delete &#39;{0}&#39;?&#34;.format(container_out)):
            container_out.delete()


def setup_directories(builddir):
    &#34;&#34;&#34;Create the in and out directories of the container.&#34;&#34;&#34;
    build_dir = local.path(builddir)
    in_dir = build_dir / &#34;container-in&#34;
    out_dir = build_dir / &#34;container-out&#34;

    if not in_dir.exists():
        in_dir.mkdir()
    if not out_dir.exists():
        out_dir.mkdir()


def setup_container(builddir, _container):
    &#34;&#34;&#34;Prepare the container and returns the path where it can be found.&#34;&#34;&#34;
    build_dir = local.path(builddir)
    in_dir = build_dir / &#34;container-in&#34;
    container_path = local.path(_container)
    with local.cwd(builddir):
        container_bin = container_path.basename
        container_in = in_dir / container_bin
        download.Copy(_container, container_in)
        uchrt = uchroot.no_args()

        with local.cwd(&#34;container-in&#34;):
            uchrt = uchrt[&#34;-E&#34;, &#34;-A&#34;, &#34;-u&#34;, &#34;0&#34;, &#34;-g&#34;, &#34;0&#34;, &#34;-C&#34;, &#34;-r&#34;, &#34;/&#34;,
                          &#34;-w&#34;,
                          os.path.abspath(&#34;.&#34;), &#34;--&#34;]

        # Check, if we need erlent support for this archive.
        has_erlent = bash[
            &#34;-c&#34;, &#34;tar --list -f &#39;./{0}&#39; | grep --silent &#39;.erlent&#39;&#34;.format(
                container_in)]
        has_erlent = (has_erlent &amp; TF)

        # Unpack input container to: container-in
        if not has_erlent:
            cmd = local[&#34;/bin/tar&#34;][&#34;xf&#34;]
            cmd = uchrt[cmd[container_bin]]
        else:
            cmd = tar[&#34;xf&#34;]
            cmd = cmd[container_in]

        with local.cwd(&#34;container-in&#34;):
            cmd(&#34;--exclude=dev/*&#34;)
        rm(container_in)
    return in_dir


def run_in_container(command, container_dir):
    &#34;&#34;&#34;
    Run a given command inside a container.

    Mounts a directory as a container at the given mountpoint and tries to run
    the given command inside the new container.
    &#34;&#34;&#34;
    container_p = local.path(container_dir)
    with local.cwd(container_p):
        uchrt = uchroot.with_mounts()
        uchrt = uchrt[&#34;-E&#34;, &#34;-A&#34;, &#34;-u&#34;, &#34;0&#34;, &#34;-g&#34;, &#34;0&#34;, &#34;-C&#34;, &#34;-w&#34;, &#34;/&#34;, &#34;-r&#34;,
                      container_p]
        uchrt = uchrt[&#34;--&#34;]

        cmd_path = container_p / command[0].lstrip(&#39;/&#39;)
        if not cmd_path.exists():
            LOG.error(&#34;The command does not exist inside the container! %s&#34;,
                      cmd_path)
            return

        cmd = uchrt[command]
        return cmd &amp; FG


def pack_container(in_container, out_file):
    &#34;&#34;&#34;
    Pack a container image into a .tar.bz2 archive.

    Args:
        in_container (str): Path string to the container image.
        out_file (str): Output file name.
    &#34;&#34;&#34;
    container_filename = local.path(out_file).basename
    out_container = local.cwd / &#34;container-out&#34; / container_filename
    out_dir = out_container.dirname

    # Pack the results to: container-out
    with local.cwd(in_container):
        tar(&#34;cjf&#34;, out_container, &#34;.&#34;)
    c_hash = download.update_hash(out_container)
    if out_dir.exists():
        mkdir(&#34;-p&#34;, out_dir)
    mv(out_container, out_file)
    mv(out_container + &#34;.hash&#34;, out_file + &#34;.hash&#34;)

    new_container = {&#34;path&#34;: out_file, &#34;hash&#34;: str(c_hash)}
    CFG[&#34;container&#34;][&#34;known&#34;] += new_container


def setup_bash_in_container(builddir, _container, outfile, shell):
    &#34;&#34;&#34;
    Setup a bash environment inside a container.

    Creates a new chroot, which the user can use as a bash to run the wanted
    projects inside the mounted container, that also gets returned afterwards.
    &#34;&#34;&#34;
    with local.cwd(builddir):
        # Switch to bash inside uchroot
        print(&#34;Entering bash inside User-Chroot. Prepare your image and &#34;
              &#34;type &#39;exit&#39; when you are done. If bash exits with a non-zero&#34;
              &#34;exit code, no new container will be stored.&#34;)
        store_new_container = True
        try:
            run_in_container(shell, _container)
        except ProcessExecutionError:
            store_new_container = False

        if store_new_container:
            print(&#34;Packing new container image.&#34;)
            pack_container(_container, outfile)
            config_path = str(CFG[&#34;config_file&#34;])
            CFG.store(config_path)
            print(&#34;Storing config in {0}&#34;.format(os.path.abspath(config_path)))


def find_hash(container_db, key):
    &#34;&#34;&#34;Find the first container in the database with the given key.&#34;&#34;&#34;
    for keyvalue in container_db:
        if keyvalue[&#34;hash&#34;].startswith(key):
            return keyvalue[&#34;path&#34;]
    return None


def set_input_container(_container, cfg):
    &#34;&#34;&#34;Save the input for the container in the configurations.&#34;&#34;&#34;
    if not _container:
        return False
    if _container.exists():
        cfg[&#34;container&#34;][&#34;input&#34;] = str(_container)
        return True
    return False


class MockObj:
    &#34;&#34;&#34;Context object to be used in strategies.

    This object&#39;s attributes are initialized on construction.
    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)


class ContainerStrategy:
    &#34;&#34;&#34;Interfaces for the different containers chosen by the experiment.&#34;&#34;&#34;

    @abstractmethod
    def run(self, context):
        &#34;&#34;&#34;Execute a container strategy.

        Args:
            context: A context object with attributes used for the strategy.
        &#34;&#34;&#34;
        pass


class BashStrategy(ContainerStrategy):
    &#34;&#34;&#34;The user interface for setting up a bash inside the container.&#34;&#34;&#34;

    def run(self, context):
        print(&#34;Entering a shell in the container.\nUse the exit &#34;
              &#34;command to leave the container.&#34;)
        setup_bash_in_container(context.builddir, context.in_container,
                                context.out_container, context.shell)


class SetupPolyJITGentooStrategy(ContainerStrategy):
    &#34;&#34;&#34;Interface of using gentoo as a container for an experiment.&#34;&#34;&#34;

    def run(self, context):
        &#34;&#34;&#34;Setup a gentoo container suitable for PolyJIT.&#34;&#34;&#34;
        # Don&#39;t do something when running non-interactive.
        if not sys.stdout.isatty():
            return

        with local.cwd(context.in_container):
            from benchbuild.projects.gentoo import gentoo
            gentoo.setup_networking()
            gentoo.configure_portage()

            sed_in_chroot = uchroot.uchroot()[&#34;/bin/sed&#34;]
            sed_in_chroot = run.watch(sed_in_chroot)
            emerge_in_chroot = uchroot.uchroot()[&#34;/usr/bin/emerge&#34;]
            emerge_in_chroot = run.watch(emerge_in_chroot)
            has_pkg = uchroot.uchroot()[&#34;/usr/bin/qlist&#34;, &#34;-I&#34;]

            sed_in_chroot(&#34;-i&#34;, &#39;/CC=/d&#39;, &#34;/etc/portage/make.conf&#34;)
            sed_in_chroot(&#34;-i&#34;, &#39;/CXX=/d&#39;, &#34;/etc/portage/make.conf&#34;)

            want_sync = bool(CFG[&#34;container&#34;][&#34;strategy&#34;][&#34;polyjit&#34;][&#34;sync&#34;])
            want_upgrade = bool(
                CFG[&#34;container&#34;][&#34;strategy&#34;][&#34;polyjit&#34;][&#34;upgrade&#34;])

            packages = \
                CFG[&#34;container&#34;][&#34;strategy&#34;][&#34;polyjit&#34;][&#34;packages&#34;].value
            with local.env(MAKEOPTS=&#34;-j{0}&#34;.format(int(CFG[&#34;jobs&#34;]))):
                if want_sync:
                    LOG.debug(&#34;Synchronizing portage.&#34;)
                    emerge_in_chroot(&#34;--sync&#34;)
                if want_upgrade:
                    LOG.debug(&#34;Upgrading world.&#34;)
                    emerge_in_chroot(&#34;--autounmask-only=y&#34;, &#34;-uUDN&#34;,
                                     &#34;--with-bdeps=y&#34;, &#34;@world&#34;)
                for pkg in packages:
                    if has_pkg[pkg[&#34;name&#34;]] &amp; TF:
                        continue
                    env = pkg[&#34;env&#34;]
                    with local.env(**env):
                        emerge_in_chroot(pkg[&#34;name&#34;])

            gentoo.setup_benchbuild()

        print(&#34;Packing new container image.&#34;)
        with local.cwd(context.builddir):
            pack_container(context.in_container, context.out_container)


class Container(cli.Application):
    &#34;&#34;&#34;Manage uchroot containers.&#34;&#34;&#34;

    VERSION = str(CFG[&#34;version&#34;])

    @cli.switch([&#34;-i&#34;, &#34;--input-file&#34;], str, help=&#34;Input container path&#34;)
    def input_file(self, _container):
        &#34;&#34;&#34;Find the input path of a uchroot container.&#34;&#34;&#34;
        p = local.path(_container)
        if set_input_container(p, CFG):
            return

        p = find_hash(CFG[&#34;container&#34;][&#34;known&#34;].value, container)
        if set_input_container(p, CFG):
            return

        raise ValueError(&#34;The path &#39;{0}&#39; does not exist.&#34;.format(p))

    @cli.switch([&#34;-o&#34;, &#34;--output-file&#34;], str, help=&#34;Output container path&#34;)
    def output_file(self, _container):
        &#34;&#34;&#34;Find and writes the output path of a chroot container.&#34;&#34;&#34;
        p = local.path(_container)
        if p.exists():
            if not ui.ask(&#34;Path &#39;{0}&#39; already exists.&#34;
                          &#34; Overwrite?&#34;.format(p)):
                sys.exit(0)
        CFG[&#34;container&#34;][&#34;output&#34;] = str(p)

    @cli.switch(
        [&#34;-s&#34;, &#34;--shell&#34;],
        str,
        help=&#34;The shell command we invoke inside the container.&#34;)
    def shell(self, custom_shell):
        &#34;&#34;&#34;The command to run inside the container.&#34;&#34;&#34;
        CFG[&#34;container&#34;][&#34;shell&#34;] = custom_shell

    @cli.switch(
        [&#34;-t&#34;, &#34;-tmp-dir&#34;], cli.ExistingDirectory, help=&#34;Temporary directory&#34;)
    def builddir(self, tmpdir):
        &#34;&#34;&#34;Set the current builddir of the container.&#34;&#34;&#34;
        CFG[&#34;build_dir&#34;] = tmpdir

    @cli.switch(
        [&#34;m&#34;, &#34;--mount&#34;],
        cli.ExistingDirectory,
        list=True,
        help=&#34;Mount the given directory under / inside the uchroot container&#34;)
    def mounts(self, user_mount):
        &#34;&#34;&#34;Save the current mount of the container into the settings.&#34;&#34;&#34;
        CFG[&#34;container&#34;][&#34;mounts&#34;] = user_mount

    verbosity = cli.CountOf(&#39;-v&#39;, help=&#34;Enable verbose output&#34;)

    def main(self, *args):
        log.configure()
        builddir = local.path(str(CFG[&#34;build_dir&#34;]))
        if not builddir.exists():
            response = ui.ask(
                &#34;The build directory {dirname} does not exist yet. &#34;
                &#34;Should I create it?&#34;.format(dirname=builddir))

            if response:
                mkdir(&#34;-p&#34;, builddir)
                print(&#34;Created directory {0}.&#34;.format(builddir))

        setup_directories(builddir)


@Container.subcommand(&#34;run&#34;)
class ContainerRun(cli.Application):
    &#34;&#34;&#34;Execute commannds inside a prebuilt container.&#34;&#34;&#34;

    def main(self, *args):
        builddir = str(CFG[&#34;build_dir&#34;])
        in_container = str(CFG[&#34;container&#34;][&#34;input&#34;])

        if (in_container is None) or not os.path.exists(in_container):
            in_is_file = False
            in_container = container.Gentoo().local
        else:
            in_is_file = os.path.isfile(in_container)
            if in_is_file:
                clean_directories(builddir)
                setup_directories(builddir)
                in_container = setup_container(builddir, in_container)

        run_in_container(args, in_container)
        clean_directories(builddir, in_is_file, False)


@Container.subcommand(&#34;create&#34;)
class ContainerCreate(cli.Application):
    &#34;&#34;&#34;
    Create a new container with a predefined strategy.

    We offer a variety of creation policies for a new container. By default a
    basic &#39;spawn a bash&#39; policy is used. This just leaves you inside a bash
    that is started in the extracted container. After customization you can
    exit the bash and pack up the result.
    &#34;&#34;&#34;

    _strategy = BashStrategy()

    @cli.switch(
        [&#34;-S&#34;, &#34;--strategy&#34;],
        cli.Set(&#34;bash&#34;, &#34;polyjit&#34;, case_sensitive=False),
        help=&#34;Defines the strategy used to create a new container.&#34;,
        mandatory=False)
    def strategy(self, strategy):
        &#34;&#34;&#34;Select strategy based on key.

        Args:
            strategy (str): The strategy to select.

        Returns:
            A strategy object.
        &#34;&#34;&#34;
        self._strategy = {
            &#34;bash&#34;: BashStrategy(),
            &#34;polyjit&#34;: SetupPolyJITGentooStrategy()
        }[strategy]

    def main(self, *args):
        builddir = str(CFG[&#34;build_dir&#34;])
        in_container = str(CFG[&#34;container&#34;][&#34;input&#34;])
        out_container = str(CFG[&#34;container&#34;][&#34;output&#34;])
        mounts = CFG[&#34;container&#34;][&#34;mounts&#34;].value
        shell = str(CFG[&#34;container&#34;][&#34;shell&#34;])

        if (in_container is None) or not os.path.exists(in_container):
            in_container = container.Gentoo().local

        in_is_file = os.path.isfile(in_container)
        if in_is_file:
            in_container = setup_container(builddir, in_container)

        self._strategy.run(
            MockObj(
                builddir=builddir,
                in_container=in_container,
                out_container=out_container,
                mounts=mounts,
                shell=shell))
        clean_directories(builddir, in_is_file, True)


@Container.subcommand(&#34;bootstrap&#34;)
class ContainerBootstrap(cli.Application):
    &#34;&#34;&#34;Check for the needed files.&#34;&#34;&#34;

    def install_cmake_and_exit(self):
        &#34;&#34;&#34;Tell the user to install cmake and aborts the current process.&#34;&#34;&#34;
        print(&#34;You need to  install cmake via your package manager manually.&#34;
              &#34; Exiting.&#34;)
        sys.exit(-1)

    def main(self, *args):
        print(&#34;Checking container binary dependencies...&#34;)
        if not bootstrap.find_package(&#34;uchroot&#34;):
            if not bootstrap.find_package(&#34;cmake&#34;):
                self.install_cmake_and_exit()
            bootstrap.install_uchroot()
        print(&#34;...OK&#34;)
        config_file = str(CFG[&#34;config_file&#34;])
        if not (config_file and os.path.exists(config_file)):
            config_file = &#34;.benchbuild.json&#34;
        CFG.store(config_file)
        print(&#34;Storing config in {0}&#34;.format(os.path.abspath(config_file)))
        print(
            &#34;Future container commands from this directory will automatically&#34;
            &#34; source the config file.&#34;)


@Container.subcommand(&#34;list&#34;)
class ContainerList(cli.Application):
    &#34;&#34;&#34;Prints a list of the known containers.&#34;&#34;&#34;

    def main(self, *args):
        containers = CFG[&#34;container&#34;][&#34;known&#34;].value
        for c in containers:
            print(&#34;[{1:.8s}] {0}&#34;.format(c[&#34;path&#34;], str(c[&#34;hash&#34;])))


def main(*args):
    &#34;&#34;&#34;Main entry point for the container tool.&#34;&#34;&#34;
    return Container.run(*args)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="benchbuild.container.clean_directories"><code class="name flex">
<span>def <span class="ident">clean_directories</span></span>(<span>builddir, in_dir=True, out_dir=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove the in and out of the container if confirmed by the user.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_directories(builddir, in_dir=True, out_dir=True):
    &#34;&#34;&#34;Remove the in and out of the container if confirmed by the user.&#34;&#34;&#34;
    container_in = local.path(builddir) / &#34;container-in&#34;
    container_out = local.path(builddir) / &#34;container-out&#34;

    if in_dir and container_in.exists():
        if ui.ask(&#34;Should I delete &#39;{0}&#39;?&#34;.format(container_in)):
            container_in.delete()
    if out_dir and container_out.exists():
        if ui.ask(&#34;Should I delete &#39;{0}&#39;?&#34;.format(container_out)):
            container_out.delete()</code></pre>
</details>
</dd>
<dt id="benchbuild.container.find_hash"><code class="name flex">
<span>def <span class="ident">find_hash</span></span>(<span>container_db, key)</span>
</code></dt>
<dd>
<section class="desc"><p>Find the first container in the database with the given key.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_hash(container_db, key):
    &#34;&#34;&#34;Find the first container in the database with the given key.&#34;&#34;&#34;
    for keyvalue in container_db:
        if keyvalue[&#34;hash&#34;].startswith(key):
            return keyvalue[&#34;path&#34;]
    return None</code></pre>
</details>
</dd>
<dt id="benchbuild.container.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>*args)</span>
</code></dt>
<dd>
<section class="desc"><p>Main entry point for the container tool.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(*args):
    &#34;&#34;&#34;Main entry point for the container tool.&#34;&#34;&#34;
    return Container.run(*args)</code></pre>
</details>
</dd>
<dt id="benchbuild.container.pack_container"><code class="name flex">
<span>def <span class="ident">pack_container</span></span>(<span>in_container, out_file)</span>
</code></dt>
<dd>
<section class="desc"><p>Pack a container image into a .tar.bz2 archive.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>in_container</code></strong> :&ensp;<code>str</code></dt>
<dd>Path string to the container image.</dd>
<dt><strong><code>out_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Output file name.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pack_container(in_container, out_file):
    &#34;&#34;&#34;
    Pack a container image into a .tar.bz2 archive.

    Args:
        in_container (str): Path string to the container image.
        out_file (str): Output file name.
    &#34;&#34;&#34;
    container_filename = local.path(out_file).basename
    out_container = local.cwd / &#34;container-out&#34; / container_filename
    out_dir = out_container.dirname

    # Pack the results to: container-out
    with local.cwd(in_container):
        tar(&#34;cjf&#34;, out_container, &#34;.&#34;)
    c_hash = download.update_hash(out_container)
    if out_dir.exists():
        mkdir(&#34;-p&#34;, out_dir)
    mv(out_container, out_file)
    mv(out_container + &#34;.hash&#34;, out_file + &#34;.hash&#34;)

    new_container = {&#34;path&#34;: out_file, &#34;hash&#34;: str(c_hash)}
    CFG[&#34;container&#34;][&#34;known&#34;] += new_container</code></pre>
</details>
</dd>
<dt id="benchbuild.container.run_in_container"><code class="name flex">
<span>def <span class="ident">run_in_container</span></span>(<span>command, container_dir)</span>
</code></dt>
<dd>
<section class="desc"><p>Run a given command inside a container.</p>
<p>Mounts a directory as a container at the given mountpoint and tries to run
the given command inside the new container.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_in_container(command, container_dir):
    &#34;&#34;&#34;
    Run a given command inside a container.

    Mounts a directory as a container at the given mountpoint and tries to run
    the given command inside the new container.
    &#34;&#34;&#34;
    container_p = local.path(container_dir)
    with local.cwd(container_p):
        uchrt = uchroot.with_mounts()
        uchrt = uchrt[&#34;-E&#34;, &#34;-A&#34;, &#34;-u&#34;, &#34;0&#34;, &#34;-g&#34;, &#34;0&#34;, &#34;-C&#34;, &#34;-w&#34;, &#34;/&#34;, &#34;-r&#34;,
                      container_p]
        uchrt = uchrt[&#34;--&#34;]

        cmd_path = container_p / command[0].lstrip(&#39;/&#39;)
        if not cmd_path.exists():
            LOG.error(&#34;The command does not exist inside the container! %s&#34;,
                      cmd_path)
            return

        cmd = uchrt[command]
        return cmd &amp; FG</code></pre>
</details>
</dd>
<dt id="benchbuild.container.set_input_container"><code class="name flex">
<span>def <span class="ident">set_input_container</span></span>(<span>_container, cfg)</span>
</code></dt>
<dd>
<section class="desc"><p>Save the input for the container in the configurations.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_input_container(_container, cfg):
    &#34;&#34;&#34;Save the input for the container in the configurations.&#34;&#34;&#34;
    if not _container:
        return False
    if _container.exists():
        cfg[&#34;container&#34;][&#34;input&#34;] = str(_container)
        return True
    return False</code></pre>
</details>
</dd>
<dt id="benchbuild.container.setup_bash_in_container"><code class="name flex">
<span>def <span class="ident">setup_bash_in_container</span></span>(<span>builddir, _container, outfile, shell)</span>
</code></dt>
<dd>
<section class="desc"><p>Setup a bash environment inside a container.</p>
<p>Creates a new chroot, which the user can use as a bash to run the wanted
projects inside the mounted container, that also gets returned afterwards.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_bash_in_container(builddir, _container, outfile, shell):
    &#34;&#34;&#34;
    Setup a bash environment inside a container.

    Creates a new chroot, which the user can use as a bash to run the wanted
    projects inside the mounted container, that also gets returned afterwards.
    &#34;&#34;&#34;
    with local.cwd(builddir):
        # Switch to bash inside uchroot
        print(&#34;Entering bash inside User-Chroot. Prepare your image and &#34;
              &#34;type &#39;exit&#39; when you are done. If bash exits with a non-zero&#34;
              &#34;exit code, no new container will be stored.&#34;)
        store_new_container = True
        try:
            run_in_container(shell, _container)
        except ProcessExecutionError:
            store_new_container = False

        if store_new_container:
            print(&#34;Packing new container image.&#34;)
            pack_container(_container, outfile)
            config_path = str(CFG[&#34;config_file&#34;])
            CFG.store(config_path)
            print(&#34;Storing config in {0}&#34;.format(os.path.abspath(config_path)))</code></pre>
</details>
</dd>
<dt id="benchbuild.container.setup_container"><code class="name flex">
<span>def <span class="ident">setup_container</span></span>(<span>builddir, _container)</span>
</code></dt>
<dd>
<section class="desc"><p>Prepare the container and returns the path where it can be found.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_container(builddir, _container):
    &#34;&#34;&#34;Prepare the container and returns the path where it can be found.&#34;&#34;&#34;
    build_dir = local.path(builddir)
    in_dir = build_dir / &#34;container-in&#34;
    container_path = local.path(_container)
    with local.cwd(builddir):
        container_bin = container_path.basename
        container_in = in_dir / container_bin
        download.Copy(_container, container_in)
        uchrt = uchroot.no_args()

        with local.cwd(&#34;container-in&#34;):
            uchrt = uchrt[&#34;-E&#34;, &#34;-A&#34;, &#34;-u&#34;, &#34;0&#34;, &#34;-g&#34;, &#34;0&#34;, &#34;-C&#34;, &#34;-r&#34;, &#34;/&#34;,
                          &#34;-w&#34;,
                          os.path.abspath(&#34;.&#34;), &#34;--&#34;]

        # Check, if we need erlent support for this archive.
        has_erlent = bash[
            &#34;-c&#34;, &#34;tar --list -f &#39;./{0}&#39; | grep --silent &#39;.erlent&#39;&#34;.format(
                container_in)]
        has_erlent = (has_erlent &amp; TF)

        # Unpack input container to: container-in
        if not has_erlent:
            cmd = local[&#34;/bin/tar&#34;][&#34;xf&#34;]
            cmd = uchrt[cmd[container_bin]]
        else:
            cmd = tar[&#34;xf&#34;]
            cmd = cmd[container_in]

        with local.cwd(&#34;container-in&#34;):
            cmd(&#34;--exclude=dev/*&#34;)
        rm(container_in)
    return in_dir</code></pre>
</details>
</dd>
<dt id="benchbuild.container.setup_directories"><code class="name flex">
<span>def <span class="ident">setup_directories</span></span>(<span>builddir)</span>
</code></dt>
<dd>
<section class="desc"><p>Create the in and out directories of the container.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_directories(builddir):
    &#34;&#34;&#34;Create the in and out directories of the container.&#34;&#34;&#34;
    build_dir = local.path(builddir)
    in_dir = build_dir / &#34;container-in&#34;
    out_dir = build_dir / &#34;container-out&#34;

    if not in_dir.exists():
        in_dir.mkdir()
    if not out_dir.exists():
        out_dir.mkdir()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="benchbuild.container.BashStrategy"><code class="flex name class">
<span>class <span class="ident">BashStrategy</span></span>
</code></dt>
<dd>
<section class="desc"><p>The user interface for setting up a bash inside the container.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BashStrategy(ContainerStrategy):
    &#34;&#34;&#34;The user interface for setting up a bash inside the container.&#34;&#34;&#34;

    def run(self, context):
        print(&#34;Entering a shell in the container.\nUse the exit &#34;
              &#34;command to leave the container.&#34;)
        setup_bash_in_container(context.builddir, context.in_container,
                                context.out_container, context.shell)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="benchbuild.container.ContainerStrategy" href="#benchbuild.container.ContainerStrategy">ContainerStrategy</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="benchbuild.container.ContainerStrategy" href="#benchbuild.container.ContainerStrategy">ContainerStrategy</a></b></code>:
<ul class="hlist">
<li><code><a title="benchbuild.container.ContainerStrategy.run" href="#benchbuild.container.ContainerStrategy.run">run</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="benchbuild.container.Container"><code class="flex name class">
<span>class <span class="ident">Container</span></span>
<span>(</span><span>executable=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Manage uchroot containers.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Container(cli.Application):
    &#34;&#34;&#34;Manage uchroot containers.&#34;&#34;&#34;

    VERSION = str(CFG[&#34;version&#34;])

    @cli.switch([&#34;-i&#34;, &#34;--input-file&#34;], str, help=&#34;Input container path&#34;)
    def input_file(self, _container):
        &#34;&#34;&#34;Find the input path of a uchroot container.&#34;&#34;&#34;
        p = local.path(_container)
        if set_input_container(p, CFG):
            return

        p = find_hash(CFG[&#34;container&#34;][&#34;known&#34;].value, container)
        if set_input_container(p, CFG):
            return

        raise ValueError(&#34;The path &#39;{0}&#39; does not exist.&#34;.format(p))

    @cli.switch([&#34;-o&#34;, &#34;--output-file&#34;], str, help=&#34;Output container path&#34;)
    def output_file(self, _container):
        &#34;&#34;&#34;Find and writes the output path of a chroot container.&#34;&#34;&#34;
        p = local.path(_container)
        if p.exists():
            if not ui.ask(&#34;Path &#39;{0}&#39; already exists.&#34;
                          &#34; Overwrite?&#34;.format(p)):
                sys.exit(0)
        CFG[&#34;container&#34;][&#34;output&#34;] = str(p)

    @cli.switch(
        [&#34;-s&#34;, &#34;--shell&#34;],
        str,
        help=&#34;The shell command we invoke inside the container.&#34;)
    def shell(self, custom_shell):
        &#34;&#34;&#34;The command to run inside the container.&#34;&#34;&#34;
        CFG[&#34;container&#34;][&#34;shell&#34;] = custom_shell

    @cli.switch(
        [&#34;-t&#34;, &#34;-tmp-dir&#34;], cli.ExistingDirectory, help=&#34;Temporary directory&#34;)
    def builddir(self, tmpdir):
        &#34;&#34;&#34;Set the current builddir of the container.&#34;&#34;&#34;
        CFG[&#34;build_dir&#34;] = tmpdir

    @cli.switch(
        [&#34;m&#34;, &#34;--mount&#34;],
        cli.ExistingDirectory,
        list=True,
        help=&#34;Mount the given directory under / inside the uchroot container&#34;)
    def mounts(self, user_mount):
        &#34;&#34;&#34;Save the current mount of the container into the settings.&#34;&#34;&#34;
        CFG[&#34;container&#34;][&#34;mounts&#34;] = user_mount

    verbosity = cli.CountOf(&#39;-v&#39;, help=&#34;Enable verbose output&#34;)

    def main(self, *args):
        log.configure()
        builddir = local.path(str(CFG[&#34;build_dir&#34;]))
        if not builddir.exists():
            response = ui.ask(
                &#34;The build directory {dirname} does not exist yet. &#34;
                &#34;Should I create it?&#34;.format(dirname=builddir))

            if response:
                mkdir(&#34;-p&#34;, builddir)
                print(&#34;Created directory {0}.&#34;.format(builddir))

        setup_directories(builddir)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>plumbum.cli.application.Application</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="benchbuild.container.Container.VERSION"><code class="name">var <span class="ident">VERSION</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="benchbuild.container.Container.verbosity"><code class="name">var <span class="ident">verbosity</span></code></dt>
<dd>
<section class="desc"><p>Sets an attribute</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, inst, cls):
    if inst is None:
        return self
    else:
        return getattr(inst, self.ATTR_NAME, {}).get(
            self, self._default_value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.container.Container.builddir"><code class="name flex">
<span>def <span class="ident">builddir</span></span>(<span>self, tmpdir)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the current builddir of the container.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cli.switch(
    [&#34;-t&#34;, &#34;-tmp-dir&#34;], cli.ExistingDirectory, help=&#34;Temporary directory&#34;)
def builddir(self, tmpdir):
    &#34;&#34;&#34;Set the current builddir of the container.&#34;&#34;&#34;
    CFG[&#34;build_dir&#34;] = tmpdir</code></pre>
</details>
</dd>
<dt id="benchbuild.container.Container.input_file"><code class="name flex">
<span>def <span class="ident">input_file</span></span>(<span>self, _container)</span>
</code></dt>
<dd>
<section class="desc"><p>Find the input path of a uchroot container.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cli.switch([&#34;-i&#34;, &#34;--input-file&#34;], str, help=&#34;Input container path&#34;)
def input_file(self, _container):
    &#34;&#34;&#34;Find the input path of a uchroot container.&#34;&#34;&#34;
    p = local.path(_container)
    if set_input_container(p, CFG):
        return

    p = find_hash(CFG[&#34;container&#34;][&#34;known&#34;].value, container)
    if set_input_container(p, CFG):
        return

    raise ValueError(&#34;The path &#39;{0}&#39; does not exist.&#34;.format(p))</code></pre>
</details>
</dd>
<dt id="benchbuild.container.Container.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>Implement me (no need to call super)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self, *args):
    log.configure()
    builddir = local.path(str(CFG[&#34;build_dir&#34;]))
    if not builddir.exists():
        response = ui.ask(
            &#34;The build directory {dirname} does not exist yet. &#34;
            &#34;Should I create it?&#34;.format(dirname=builddir))

        if response:
            mkdir(&#34;-p&#34;, builddir)
            print(&#34;Created directory {0}.&#34;.format(builddir))

    setup_directories(builddir)</code></pre>
</details>
</dd>
<dt id="benchbuild.container.Container.mounts"><code class="name flex">
<span>def <span class="ident">mounts</span></span>(<span>self, user_mount)</span>
</code></dt>
<dd>
<section class="desc"><p>Save the current mount of the container into the settings.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cli.switch(
    [&#34;m&#34;, &#34;--mount&#34;],
    cli.ExistingDirectory,
    list=True,
    help=&#34;Mount the given directory under / inside the uchroot container&#34;)
def mounts(self, user_mount):
    &#34;&#34;&#34;Save the current mount of the container into the settings.&#34;&#34;&#34;
    CFG[&#34;container&#34;][&#34;mounts&#34;] = user_mount</code></pre>
</details>
</dd>
<dt id="benchbuild.container.Container.output_file"><code class="name flex">
<span>def <span class="ident">output_file</span></span>(<span>self, _container)</span>
</code></dt>
<dd>
<section class="desc"><p>Find and writes the output path of a chroot container.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cli.switch([&#34;-o&#34;, &#34;--output-file&#34;], str, help=&#34;Output container path&#34;)
def output_file(self, _container):
    &#34;&#34;&#34;Find and writes the output path of a chroot container.&#34;&#34;&#34;
    p = local.path(_container)
    if p.exists():
        if not ui.ask(&#34;Path &#39;{0}&#39; already exists.&#34;
                      &#34; Overwrite?&#34;.format(p)):
            sys.exit(0)
    CFG[&#34;container&#34;][&#34;output&#34;] = str(p)</code></pre>
</details>
</dd>
<dt id="benchbuild.container.Container.shell"><code class="name flex">
<span>def <span class="ident">shell</span></span>(<span>self, custom_shell)</span>
</code></dt>
<dd>
<section class="desc"><p>The command to run inside the container.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cli.switch(
    [&#34;-s&#34;, &#34;--shell&#34;],
    str,
    help=&#34;The shell command we invoke inside the container.&#34;)
def shell(self, custom_shell):
    &#34;&#34;&#34;The command to run inside the container.&#34;&#34;&#34;
    CFG[&#34;container&#34;][&#34;shell&#34;] = custom_shell</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.container.ContainerBootstrap"><code class="flex name class">
<span>class <span class="ident">ContainerBootstrap</span></span>
<span>(</span><span>executable=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Check for the needed files.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContainerBootstrap(cli.Application):
    &#34;&#34;&#34;Check for the needed files.&#34;&#34;&#34;

    def install_cmake_and_exit(self):
        &#34;&#34;&#34;Tell the user to install cmake and aborts the current process.&#34;&#34;&#34;
        print(&#34;You need to  install cmake via your package manager manually.&#34;
              &#34; Exiting.&#34;)
        sys.exit(-1)

    def main(self, *args):
        print(&#34;Checking container binary dependencies...&#34;)
        if not bootstrap.find_package(&#34;uchroot&#34;):
            if not bootstrap.find_package(&#34;cmake&#34;):
                self.install_cmake_and_exit()
            bootstrap.install_uchroot()
        print(&#34;...OK&#34;)
        config_file = str(CFG[&#34;config_file&#34;])
        if not (config_file and os.path.exists(config_file)):
            config_file = &#34;.benchbuild.json&#34;
        CFG.store(config_file)
        print(&#34;Storing config in {0}&#34;.format(os.path.abspath(config_file)))
        print(
            &#34;Future container commands from this directory will automatically&#34;
            &#34; source the config file.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>plumbum.cli.application.Application</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.container.ContainerBootstrap.install_cmake_and_exit"><code class="name flex">
<span>def <span class="ident">install_cmake_and_exit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Tell the user to install cmake and aborts the current process.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def install_cmake_and_exit(self):
    &#34;&#34;&#34;Tell the user to install cmake and aborts the current process.&#34;&#34;&#34;
    print(&#34;You need to  install cmake via your package manager manually.&#34;
          &#34; Exiting.&#34;)
    sys.exit(-1)</code></pre>
</details>
</dd>
<dt id="benchbuild.container.ContainerBootstrap.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>Implement me (no need to call super)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self, *args):
    print(&#34;Checking container binary dependencies...&#34;)
    if not bootstrap.find_package(&#34;uchroot&#34;):
        if not bootstrap.find_package(&#34;cmake&#34;):
            self.install_cmake_and_exit()
        bootstrap.install_uchroot()
    print(&#34;...OK&#34;)
    config_file = str(CFG[&#34;config_file&#34;])
    if not (config_file and os.path.exists(config_file)):
        config_file = &#34;.benchbuild.json&#34;
    CFG.store(config_file)
    print(&#34;Storing config in {0}&#34;.format(os.path.abspath(config_file)))
    print(
        &#34;Future container commands from this directory will automatically&#34;
        &#34; source the config file.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.container.ContainerCreate"><code class="flex name class">
<span>class <span class="ident">ContainerCreate</span></span>
<span>(</span><span>executable=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a new container with a predefined strategy.</p>
<p>We offer a variety of creation policies for a new container. By default a
basic 'spawn a bash' policy is used. This just leaves you inside a bash
that is started in the extracted container. After customization you can
exit the bash and pack up the result.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContainerCreate(cli.Application):
    &#34;&#34;&#34;
    Create a new container with a predefined strategy.

    We offer a variety of creation policies for a new container. By default a
    basic &#39;spawn a bash&#39; policy is used. This just leaves you inside a bash
    that is started in the extracted container. After customization you can
    exit the bash and pack up the result.
    &#34;&#34;&#34;

    _strategy = BashStrategy()

    @cli.switch(
        [&#34;-S&#34;, &#34;--strategy&#34;],
        cli.Set(&#34;bash&#34;, &#34;polyjit&#34;, case_sensitive=False),
        help=&#34;Defines the strategy used to create a new container.&#34;,
        mandatory=False)
    def strategy(self, strategy):
        &#34;&#34;&#34;Select strategy based on key.

        Args:
            strategy (str): The strategy to select.

        Returns:
            A strategy object.
        &#34;&#34;&#34;
        self._strategy = {
            &#34;bash&#34;: BashStrategy(),
            &#34;polyjit&#34;: SetupPolyJITGentooStrategy()
        }[strategy]

    def main(self, *args):
        builddir = str(CFG[&#34;build_dir&#34;])
        in_container = str(CFG[&#34;container&#34;][&#34;input&#34;])
        out_container = str(CFG[&#34;container&#34;][&#34;output&#34;])
        mounts = CFG[&#34;container&#34;][&#34;mounts&#34;].value
        shell = str(CFG[&#34;container&#34;][&#34;shell&#34;])

        if (in_container is None) or not os.path.exists(in_container):
            in_container = container.Gentoo().local

        in_is_file = os.path.isfile(in_container)
        if in_is_file:
            in_container = setup_container(builddir, in_container)

        self._strategy.run(
            MockObj(
                builddir=builddir,
                in_container=in_container,
                out_container=out_container,
                mounts=mounts,
                shell=shell))
        clean_directories(builddir, in_is_file, True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>plumbum.cli.application.Application</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.container.ContainerCreate.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>Implement me (no need to call super)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self, *args):
    builddir = str(CFG[&#34;build_dir&#34;])
    in_container = str(CFG[&#34;container&#34;][&#34;input&#34;])
    out_container = str(CFG[&#34;container&#34;][&#34;output&#34;])
    mounts = CFG[&#34;container&#34;][&#34;mounts&#34;].value
    shell = str(CFG[&#34;container&#34;][&#34;shell&#34;])

    if (in_container is None) or not os.path.exists(in_container):
        in_container = container.Gentoo().local

    in_is_file = os.path.isfile(in_container)
    if in_is_file:
        in_container = setup_container(builddir, in_container)

    self._strategy.run(
        MockObj(
            builddir=builddir,
            in_container=in_container,
            out_container=out_container,
            mounts=mounts,
            shell=shell))
    clean_directories(builddir, in_is_file, True)</code></pre>
</details>
</dd>
<dt id="benchbuild.container.ContainerCreate.strategy"><code class="name flex">
<span>def <span class="ident">strategy</span></span>(<span>self, strategy)</span>
</code></dt>
<dd>
<section class="desc"><p>Select strategy based on key.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>strategy</code></strong> :&ensp;<code>str</code></dt>
<dd>The strategy to select.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A strategy object.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cli.switch(
    [&#34;-S&#34;, &#34;--strategy&#34;],
    cli.Set(&#34;bash&#34;, &#34;polyjit&#34;, case_sensitive=False),
    help=&#34;Defines the strategy used to create a new container.&#34;,
    mandatory=False)
def strategy(self, strategy):
    &#34;&#34;&#34;Select strategy based on key.

    Args:
        strategy (str): The strategy to select.

    Returns:
        A strategy object.
    &#34;&#34;&#34;
    self._strategy = {
        &#34;bash&#34;: BashStrategy(),
        &#34;polyjit&#34;: SetupPolyJITGentooStrategy()
    }[strategy]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.container.ContainerList"><code class="flex name class">
<span>class <span class="ident">ContainerList</span></span>
<span>(</span><span>executable=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Prints a list of the known containers.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContainerList(cli.Application):
    &#34;&#34;&#34;Prints a list of the known containers.&#34;&#34;&#34;

    def main(self, *args):
        containers = CFG[&#34;container&#34;][&#34;known&#34;].value
        for c in containers:
            print(&#34;[{1:.8s}] {0}&#34;.format(c[&#34;path&#34;], str(c[&#34;hash&#34;])))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>plumbum.cli.application.Application</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.container.ContainerList.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>Implement me (no need to call super)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self, *args):
    containers = CFG[&#34;container&#34;][&#34;known&#34;].value
    for c in containers:
        print(&#34;[{1:.8s}] {0}&#34;.format(c[&#34;path&#34;], str(c[&#34;hash&#34;])))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.container.ContainerRun"><code class="flex name class">
<span>class <span class="ident">ContainerRun</span></span>
<span>(</span><span>executable=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Execute commannds inside a prebuilt container.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContainerRun(cli.Application):
    &#34;&#34;&#34;Execute commannds inside a prebuilt container.&#34;&#34;&#34;

    def main(self, *args):
        builddir = str(CFG[&#34;build_dir&#34;])
        in_container = str(CFG[&#34;container&#34;][&#34;input&#34;])

        if (in_container is None) or not os.path.exists(in_container):
            in_is_file = False
            in_container = container.Gentoo().local
        else:
            in_is_file = os.path.isfile(in_container)
            if in_is_file:
                clean_directories(builddir)
                setup_directories(builddir)
                in_container = setup_container(builddir, in_container)

        run_in_container(args, in_container)
        clean_directories(builddir, in_is_file, False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>plumbum.cli.application.Application</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.container.ContainerRun.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>Implement me (no need to call super)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self, *args):
    builddir = str(CFG[&#34;build_dir&#34;])
    in_container = str(CFG[&#34;container&#34;][&#34;input&#34;])

    if (in_container is None) or not os.path.exists(in_container):
        in_is_file = False
        in_container = container.Gentoo().local
    else:
        in_is_file = os.path.isfile(in_container)
        if in_is_file:
            clean_directories(builddir)
            setup_directories(builddir)
            in_container = setup_container(builddir, in_container)

    run_in_container(args, in_container)
    clean_directories(builddir, in_is_file, False)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.container.ContainerStrategy"><code class="flex name class">
<span>class <span class="ident">ContainerStrategy</span></span>
</code></dt>
<dd>
<section class="desc"><p>Interfaces for the different containers chosen by the experiment.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContainerStrategy:
    &#34;&#34;&#34;Interfaces for the different containers chosen by the experiment.&#34;&#34;&#34;

    @abstractmethod
    def run(self, context):
        &#34;&#34;&#34;Execute a container strategy.

        Args:
            context: A context object with attributes used for the strategy.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="benchbuild.container.BashStrategy" href="#benchbuild.container.BashStrategy">BashStrategy</a></li>
<li><a title="benchbuild.container.SetupPolyJITGentooStrategy" href="#benchbuild.container.SetupPolyJITGentooStrategy">SetupPolyJITGentooStrategy</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.container.ContainerStrategy.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<section class="desc"><p>Execute a container strategy.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong></dt>
<dd>A context object with attributes used for the strategy.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def run(self, context):
    &#34;&#34;&#34;Execute a container strategy.

    Args:
        context: A context object with attributes used for the strategy.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.container.MockObj"><code class="flex name class">
<span>class <span class="ident">MockObj</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Context object to be used in strategies.</p>
<p>This object's attributes are initialized on construction.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MockObj:
    &#34;&#34;&#34;Context object to be used in strategies.

    This object&#39;s attributes are initialized on construction.
    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)</code></pre>
</details>
</dd>
<dt id="benchbuild.container.SetupPolyJITGentooStrategy"><code class="flex name class">
<span>class <span class="ident">SetupPolyJITGentooStrategy</span></span>
</code></dt>
<dd>
<section class="desc"><p>Interface of using gentoo as a container for an experiment.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SetupPolyJITGentooStrategy(ContainerStrategy):
    &#34;&#34;&#34;Interface of using gentoo as a container for an experiment.&#34;&#34;&#34;

    def run(self, context):
        &#34;&#34;&#34;Setup a gentoo container suitable for PolyJIT.&#34;&#34;&#34;
        # Don&#39;t do something when running non-interactive.
        if not sys.stdout.isatty():
            return

        with local.cwd(context.in_container):
            from benchbuild.projects.gentoo import gentoo
            gentoo.setup_networking()
            gentoo.configure_portage()

            sed_in_chroot = uchroot.uchroot()[&#34;/bin/sed&#34;]
            sed_in_chroot = run.watch(sed_in_chroot)
            emerge_in_chroot = uchroot.uchroot()[&#34;/usr/bin/emerge&#34;]
            emerge_in_chroot = run.watch(emerge_in_chroot)
            has_pkg = uchroot.uchroot()[&#34;/usr/bin/qlist&#34;, &#34;-I&#34;]

            sed_in_chroot(&#34;-i&#34;, &#39;/CC=/d&#39;, &#34;/etc/portage/make.conf&#34;)
            sed_in_chroot(&#34;-i&#34;, &#39;/CXX=/d&#39;, &#34;/etc/portage/make.conf&#34;)

            want_sync = bool(CFG[&#34;container&#34;][&#34;strategy&#34;][&#34;polyjit&#34;][&#34;sync&#34;])
            want_upgrade = bool(
                CFG[&#34;container&#34;][&#34;strategy&#34;][&#34;polyjit&#34;][&#34;upgrade&#34;])

            packages = \
                CFG[&#34;container&#34;][&#34;strategy&#34;][&#34;polyjit&#34;][&#34;packages&#34;].value
            with local.env(MAKEOPTS=&#34;-j{0}&#34;.format(int(CFG[&#34;jobs&#34;]))):
                if want_sync:
                    LOG.debug(&#34;Synchronizing portage.&#34;)
                    emerge_in_chroot(&#34;--sync&#34;)
                if want_upgrade:
                    LOG.debug(&#34;Upgrading world.&#34;)
                    emerge_in_chroot(&#34;--autounmask-only=y&#34;, &#34;-uUDN&#34;,
                                     &#34;--with-bdeps=y&#34;, &#34;@world&#34;)
                for pkg in packages:
                    if has_pkg[pkg[&#34;name&#34;]] &amp; TF:
                        continue
                    env = pkg[&#34;env&#34;]
                    with local.env(**env):
                        emerge_in_chroot(pkg[&#34;name&#34;])

            gentoo.setup_benchbuild()

        print(&#34;Packing new container image.&#34;)
        with local.cwd(context.builddir):
            pack_container(context.in_container, context.out_container)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="benchbuild.container.ContainerStrategy" href="#benchbuild.container.ContainerStrategy">ContainerStrategy</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.container.SetupPolyJITGentooStrategy.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, context)</span>
</code></dt>
<dd>
<section class="desc"><p>Setup a gentoo container suitable for PolyJIT.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, context):
    &#34;&#34;&#34;Setup a gentoo container suitable for PolyJIT.&#34;&#34;&#34;
    # Don&#39;t do something when running non-interactive.
    if not sys.stdout.isatty():
        return

    with local.cwd(context.in_container):
        from benchbuild.projects.gentoo import gentoo
        gentoo.setup_networking()
        gentoo.configure_portage()

        sed_in_chroot = uchroot.uchroot()[&#34;/bin/sed&#34;]
        sed_in_chroot = run.watch(sed_in_chroot)
        emerge_in_chroot = uchroot.uchroot()[&#34;/usr/bin/emerge&#34;]
        emerge_in_chroot = run.watch(emerge_in_chroot)
        has_pkg = uchroot.uchroot()[&#34;/usr/bin/qlist&#34;, &#34;-I&#34;]

        sed_in_chroot(&#34;-i&#34;, &#39;/CC=/d&#39;, &#34;/etc/portage/make.conf&#34;)
        sed_in_chroot(&#34;-i&#34;, &#39;/CXX=/d&#39;, &#34;/etc/portage/make.conf&#34;)

        want_sync = bool(CFG[&#34;container&#34;][&#34;strategy&#34;][&#34;polyjit&#34;][&#34;sync&#34;])
        want_upgrade = bool(
            CFG[&#34;container&#34;][&#34;strategy&#34;][&#34;polyjit&#34;][&#34;upgrade&#34;])

        packages = \
            CFG[&#34;container&#34;][&#34;strategy&#34;][&#34;polyjit&#34;][&#34;packages&#34;].value
        with local.env(MAKEOPTS=&#34;-j{0}&#34;.format(int(CFG[&#34;jobs&#34;]))):
            if want_sync:
                LOG.debug(&#34;Synchronizing portage.&#34;)
                emerge_in_chroot(&#34;--sync&#34;)
            if want_upgrade:
                LOG.debug(&#34;Upgrading world.&#34;)
                emerge_in_chroot(&#34;--autounmask-only=y&#34;, &#34;-uUDN&#34;,
                                 &#34;--with-bdeps=y&#34;, &#34;@world&#34;)
            for pkg in packages:
                if has_pkg[pkg[&#34;name&#34;]] &amp; TF:
                    continue
                env = pkg[&#34;env&#34;]
                with local.env(**env):
                    emerge_in_chroot(pkg[&#34;name&#34;])

        gentoo.setup_benchbuild()

    print(&#34;Packing new container image.&#34;)
    with local.cwd(context.builddir):
        pack_container(context.in_container, context.out_container)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="benchbuild" href="index.html">benchbuild</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="benchbuild.container.clean_directories" href="#benchbuild.container.clean_directories">clean_directories</a></code></li>
<li><code><a title="benchbuild.container.find_hash" href="#benchbuild.container.find_hash">find_hash</a></code></li>
<li><code><a title="benchbuild.container.main" href="#benchbuild.container.main">main</a></code></li>
<li><code><a title="benchbuild.container.pack_container" href="#benchbuild.container.pack_container">pack_container</a></code></li>
<li><code><a title="benchbuild.container.run_in_container" href="#benchbuild.container.run_in_container">run_in_container</a></code></li>
<li><code><a title="benchbuild.container.set_input_container" href="#benchbuild.container.set_input_container">set_input_container</a></code></li>
<li><code><a title="benchbuild.container.setup_bash_in_container" href="#benchbuild.container.setup_bash_in_container">setup_bash_in_container</a></code></li>
<li><code><a title="benchbuild.container.setup_container" href="#benchbuild.container.setup_container">setup_container</a></code></li>
<li><code><a title="benchbuild.container.setup_directories" href="#benchbuild.container.setup_directories">setup_directories</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="benchbuild.container.BashStrategy" href="#benchbuild.container.BashStrategy">BashStrategy</a></code></h4>
</li>
<li>
<h4><code><a title="benchbuild.container.Container" href="#benchbuild.container.Container">Container</a></code></h4>
<ul class="two-column">
<li><code><a title="benchbuild.container.Container.VERSION" href="#benchbuild.container.Container.VERSION">VERSION</a></code></li>
<li><code><a title="benchbuild.container.Container.builddir" href="#benchbuild.container.Container.builddir">builddir</a></code></li>
<li><code><a title="benchbuild.container.Container.input_file" href="#benchbuild.container.Container.input_file">input_file</a></code></li>
<li><code><a title="benchbuild.container.Container.main" href="#benchbuild.container.Container.main">main</a></code></li>
<li><code><a title="benchbuild.container.Container.mounts" href="#benchbuild.container.Container.mounts">mounts</a></code></li>
<li><code><a title="benchbuild.container.Container.output_file" href="#benchbuild.container.Container.output_file">output_file</a></code></li>
<li><code><a title="benchbuild.container.Container.shell" href="#benchbuild.container.Container.shell">shell</a></code></li>
<li><code><a title="benchbuild.container.Container.verbosity" href="#benchbuild.container.Container.verbosity">verbosity</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.container.ContainerBootstrap" href="#benchbuild.container.ContainerBootstrap">ContainerBootstrap</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.container.ContainerBootstrap.install_cmake_and_exit" href="#benchbuild.container.ContainerBootstrap.install_cmake_and_exit">install_cmake_and_exit</a></code></li>
<li><code><a title="benchbuild.container.ContainerBootstrap.main" href="#benchbuild.container.ContainerBootstrap.main">main</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.container.ContainerCreate" href="#benchbuild.container.ContainerCreate">ContainerCreate</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.container.ContainerCreate.main" href="#benchbuild.container.ContainerCreate.main">main</a></code></li>
<li><code><a title="benchbuild.container.ContainerCreate.strategy" href="#benchbuild.container.ContainerCreate.strategy">strategy</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.container.ContainerList" href="#benchbuild.container.ContainerList">ContainerList</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.container.ContainerList.main" href="#benchbuild.container.ContainerList.main">main</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.container.ContainerRun" href="#benchbuild.container.ContainerRun">ContainerRun</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.container.ContainerRun.main" href="#benchbuild.container.ContainerRun.main">main</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.container.ContainerStrategy" href="#benchbuild.container.ContainerStrategy">ContainerStrategy</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.container.ContainerStrategy.run" href="#benchbuild.container.ContainerStrategy.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.container.MockObj" href="#benchbuild.container.MockObj">MockObj</a></code></h4>
</li>
<li>
<h4><code><a title="benchbuild.container.SetupPolyJITGentooStrategy" href="#benchbuild.container.SetupPolyJITGentooStrategy">SetupPolyJITGentooStrategy</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.container.SetupPolyJITGentooStrategy.run" href="#benchbuild.container.SetupPolyJITGentooStrategy.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
