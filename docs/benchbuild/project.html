<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>benchbuild.project API documentation</title>
<meta name="description" content="Project â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>benchbuild.project</code></h1>
</header>
<section id="section-intro">
<p>Project</p>
<p>A project in benchbuild is an abstract representation of a software
system that can live in various stages throughout an experiment.
It defines two extension points for an experiment to attach on, the
compile-time phase and the (optional) run-time phase.</p>
<p>An experiment can intercept the compilation phase of a project and perform
any experiment that requires the source artifacts as input.</p>
<p>Furthermore, it is possible to intercept a project's run-time pahse with
a measurement.</p>
<p>The project definition ensures that all experiments run through the same
series of commands in both phases and that all experiments run inside
a separate build directory in isolation of one another.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Project

A project in benchbuild is an abstract representation of a software
system that can live in various stages throughout an experiment.
It defines two extension points for an experiment to attach on, the
compile-time phase and the (optional) run-time phase.

An experiment can intercept the compilation phase of a project and perform
any experiment that requires the source artifacts as input.

Furthermore, it is possible to intercept a project&#39;s run-time pahse with
a measurement.

The project definition ensures that all experiments run through the same
series of commands in both phases and that all experiments run inside
a separate build directory in isolation of one another.
&#34;&#34;&#34;
import copy
import logging
from typing import Tuple, Optional, Mapping, Type
import uuid
from abc import abstractmethod
from functools import partial
from os import getenv

import attr
from plumbum import ProcessExecutionError, local
from pygtrie import StringTrie

from benchbuild import signals
from benchbuild.extensions import compiler
from benchbuild.extensions import run as ext_run
from benchbuild.settings import CFG
from benchbuild.utils import db, run, unionfs, wrapping

LOG = logging.getLogger(__name__)


class ProjectRegistry(type):
    &#34;&#34;&#34;Registry for benchbuild projects.&#34;&#34;&#34;

    projects = StringTrie()

    def __init__(cls, name, bases, attrs):
        &#34;&#34;&#34;Register a project in the registry.&#34;&#34;&#34;
        super(ProjectRegistry, cls).__init__(name, bases, attrs)

        if None not in {cls.NAME, cls.DOMAIN, cls.GROUP}:
            key = &#34;{name}/{group}&#34;.format(name=cls.NAME, group=cls.GROUP)
            ProjectRegistry.projects[key] = cls


class ProjectDecorator(ProjectRegistry):
    &#34;&#34;&#34;
    Decorate the interface of a project with the in_builddir decorator.

    This is just a small safety net for benchbuild users, because we make
    sure to run every project method in the project&#39;s build directory.
    &#34;&#34;&#34;

    decorated_methods = [&#34;redirect&#34;, &#34;compile&#34;, &#34;run_tests&#34;]

    def __init__(cls, name, bases, attrs):
        unionfs_deco = None
        if CFG[&#34;unionfs&#34;][&#34;enable&#34;]:
            rw_dir = str(CFG[&#34;unionfs&#34;][&#34;rw&#34;])
            unionfs_deco = partial(unionfs.unionfs, rw=rw_dir)
        config_deco = run.store_config

        methods = ProjectDecorator.decorated_methods
        for key, value in attrs.items():
            if (key in methods) and hasattr(cls, key):
                wrapped_fun = value
                wrapped_fun = config_deco(wrapped_fun)

                if unionfs_deco is not None:
                    wrapped_fun = unionfs_deco()(wrapped_fun)

                wrapped_fun = run.in_builddir(&#39;.&#39;)(wrapped_fun)
                setattr(cls, key, wrapped_fun)

        super(ProjectDecorator, cls).__init__(name, bases, attrs)


@attr.s
class Project(metaclass=ProjectDecorator):
    &#34;&#34;&#34;Abstract class for benchbuild projects.

    A project is an arbitrary software system usable by benchbuild in
    experiments.
    Subclasses of Project are registered automatically by benchbuild, if
    imported in the same interpreter session. For this to happen, you must list
    the in the settings under plugins -&gt; projects.

    A project implementation *must* provide the following method:
        compile: Downloads &amp; Compiles the source.

    A project implementation *may* provide the following functions:
        run_tests: Wrap any binary that has to be run under the
            runtime_extension wrapper and execute an implementation defined
            set of run-time tests.
            Defaults to a call of a binary with the name `run_f` in the
            build directory without arguments.
        clean: Clean the project&#39;s build directory. Defaults to
            recursive &#39;rm&#39; on the build directory and can be disabled
            by setting the environment variable ``BB_CLEAN=false``.

    Raises:
        AttributeError: Class definition raises an attribute error, if
            the implementation does not provide a value for the attributes
            `NAME`, `DOMAIN`, and `GROUP`
        TypeError: Validation of properties may throw a TypeError.

    Attributes:
        experiment (benchbuild.experiment.Experiment):
            The experiment this project is assigned to.
        name (str, optional):
            The name of this project. Defaults to `NAME`.
        domain (str, optional):
            The application domain of this project. Defaults to `DOMAIN`.
        group (str, optional):
            The group this project belongs to. Defaults to `GROUP`.
        src_file (str, optional):
            A main src_file this project is assigned to. Defaults to `SRC_FILE`
        container (benchbuild.utils.container.Container, optional):
            A uchroot compatible container that we can use for this project.
            Defaults to `benchbuild.utils.container.Gentoo`.
        version (str, optional):
            A version information for this project. Defaults to `VERSION`.
        builddir (str, optional):
            The build directory for this project. Auto generated, if not set.
        testdir (str, optional):
            The location of any additional test-files for this project,
            usually stored out of tree. Auto generated, if not set. Usually a
            project implementation
            will define this itself.
        cflags (:obj:`list` of :obj:`str`, optional)
            A list of cflags used, for compilation of this project.
        ldflags (:obj:`list` of :obj:`str`, optional)
            A list of ldflags used, for compilation of this project.
        run_f (str, optional):
            A filename that points to the binary we want to track.
            Usually a project implementation will define this itself.
        run_uuid (uuid.UUID, optional):
            An UUID that identifies all binaries executed by a single run of
            this project. In the database schema this is named the &#39;run_group&#39;.
        compiler_extension (Callable[str, iterable[str], RunInfo], optional):
            A composable extension that will be used in place of the real
            compiler. Defaults to running the compiler with a timeout command
            wrapped around it.
        runtime_extension (Callable[str, iterable[str], RunInfo], optional):
            A composable extension that will be used in place of any binary
            this project
            wants to execute. Which binaries to replace is defined by the
            implementation using `benchbuild.utils.wrapping.wrap`.
            Defaults to None.
    &#34;&#34;&#34;
    NAME = None
    DOMAIN = None
    GROUP = None
    VERSION = None
    SRC_FILE = None
    CONTAINER = None

    def __new__(cls, *args, **kwargs):
        &#34;&#34;&#34;Create a new project instance and set some defaults.&#34;&#34;&#34;
        new_self = super(Project, cls).__new__(cls)
        if cls.NAME is None:
            raise AttributeError(
                &#34;{0} @ {1} does not define a NAME class attribute.&#34;.format(
                    cls.__name__, cls.__module__))
        if cls.DOMAIN is None:
            raise AttributeError(
                &#34;{0} @ {1} does not define a DOMAIN class attribute.&#34;.format(
                    cls.__name__, cls.__module__))
        if cls.GROUP is None:
            raise AttributeError(
                &#34;{0} @ {1} does not define a GROUP class attribute.&#34;.format(
                    cls.__name__, cls.__module__))
        return new_self

    experiment = attr.ib()

    name = attr.ib(
        default=attr.Factory(lambda self: type(self).NAME, takes_self=True))

    domain = attr.ib(
        default=attr.Factory(lambda self: type(self).DOMAIN, takes_self=True))

    group = attr.ib(
        default=attr.Factory(lambda self: type(self).GROUP, takes_self=True))

    src_file = attr.ib(
        default=attr.Factory(
            lambda self: type(self).SRC_FILE, takes_self=True))

    container = attr.ib(
        default=attr.Factory(
            lambda self: type(self).CONTAINER, takes_self=True))

    version = attr.ib(
        default=attr.Factory(lambda self: type(self).VERSION, takes_self=True))

    testdir = attr.ib()

    @testdir.default
    def __default_testdir(self):
        if self.group:
            return local.path(str(
                CFG[&#34;test_dir&#34;])) / self.domain / self.group / self.name
        return local.path(str(CFG[&#34;test_dir&#34;])) / self.domain / self.name

    cflags = attr.ib(default=attr.Factory(list))

    ldflags = attr.ib(default=attr.Factory(list))

    run_uuid = attr.ib()

    @run_uuid.default
    def __default_run_uuid(self):
        run_group = getenv(&#34;BB_DB_RUN_GROUP&#34;, None)
        if run_group:
            return uuid.UUID(run_group)
        return uuid.uuid4()

    @run_uuid.validator
    def __check_if_uuid(self, _, value):
        if not isinstance(value, uuid.UUID):
            raise TypeError(&#34;{attribute} must be a valid UUID object&#34;)

    builddir = attr.ib(default=attr.Factory(
        lambda self: local.path(str(CFG[&#34;build_dir&#34;])) /
        &#34;{}-{}&#34;.format(
            self.experiment.name, self.id),
        takes_self=True))

    run_f = attr.ib(
        default=attr.Factory(
            lambda self: local.path(self.builddir) / self.name,
            takes_self=True))

    compiler_extension = attr.ib(default=attr.Factory(
        lambda self: ext_run.WithTimeout(
            compiler.RunCompiler(self, self.experiment)), takes_self=True))

    runtime_extension = attr.ib(default=None)

    def __attrs_post_init__(self):
        db.persist_project(self)

    def run_tests(self, runner):
        &#34;&#34;&#34;
        Run the tests of this project.

        Clients override this method to provide customized run-time tests.

        Args:
            experiment: The experiment we run this project under
            run: A function that takes the run command.
        &#34;&#34;&#34;
        exp = wrapping.wrap(self.run_f, self)
        runner(exp)

    def run(self):
        &#34;&#34;&#34;Run the tests of this project.

        This method initializes the default environment and takes care of
        cleaning up the mess we made, after a successfull run.

        Args:
            experiment: The experiment we run this project under
        &#34;&#34;&#34;
        from benchbuild.utils.run import (begin_run_group, end_run_group,
                                          fail_run_group)
        CFG[&#34;experiment&#34;] = self.experiment.name
        CFG[&#34;project&#34;] = self.NAME
        CFG[&#34;domain&#34;] = self.DOMAIN
        CFG[&#34;group&#34;] = self.GROUP
        CFG[&#34;version&#34;] = self.VERSION
        CFG[&#34;db&#34;][&#34;run_group&#34;] = str(self.run_uuid)

        group, session = begin_run_group(self)
        signals.handlers.register(fail_run_group, group, session)

        try:
            self.run_tests(run.run)
            end_run_group(group, session)
        except ProcessExecutionError:
            fail_run_group(group, session)
            raise
        except KeyboardInterrupt:
            fail_run_group(group, session)
            raise
        finally:
            signals.handlers.deregister(fail_run_group)

    def clean(self):
        &#34;&#34;&#34;Clean the project build directory.&#34;&#34;&#34;
        builddir_p = local.path(self.builddir)
        builddir_p.delete()

    def prepare(self):
        &#34;&#34;&#34;Prepare the build diretory.&#34;&#34;&#34;
        builddir_p = local.path(self.builddir)
        if not builddir_p.exists():
            builddir_p.mkdir()

    @abstractmethod
    def compile(self):
        &#34;&#34;&#34;Compile the project.&#34;&#34;&#34;

    def download(self, version=None):
        &#34;&#34;&#34;Auto-generated by with_* decorators.&#34;&#34;&#34;
        del version
        LOG.error(&#34;Not implemented.&#34;)

    def redirect(self):
        &#34;&#34;&#34;Redirect execution to a containerized benchbuild instance.&#34;&#34;&#34;
        LOG.error(&#34;Redirection not supported by project.&#34;)

    def clone(self):
        &#34;&#34;&#34;Create a deepcopy of ourself.&#34;&#34;&#34;
        new_p = copy.deepcopy(self)
        new_p.run_uuid = uuid.uuid4()
        return new_p

    @property
    def id(self):
        return &#34;{name}-{group}@{version}_uuid_{id}&#34;.format(
            name=self.name,
            group=self.group,
            version=self.version,
            id=self.run_uuid)

    @classmethod
    def versions(cls):
        &#34;&#34;&#34;Return all available versions.&#34;&#34;&#34;
        if cls.VERSION:
            return [cls.VERSION]
        return [&#34;unknown&#34;]

def __split_project_input__(project_input: str) -&gt; Tuple[str, Optional[str]]:
    split_input = project_input.rsplit(&#39;@&#39;, maxsplit=1)
    first = split_input[0]
    second = split_input[1] if len(split_input) &gt; 1 else None

    return (first, second)


def populate(projects_to_filter=None,
             group=None) -&gt; Mapping[str, Tuple[Type[Project], Optional[str]]]:
    &#34;&#34;&#34;
    Populate the list of projects that belong to this experiment.

    Args:
        projects_to_filter (list(Project)):
            List of projects we want to assign to this experiment.
            We intersect the list of projects with the list of supported
            projects to get the list of projects that belong to this
            experiment.
        group (list(str)):
            In addition to the project filter, we provide a way to filter
            whole groups.
    Returns:
        a dictionary of (project name, project class) pairs.
    &#34;&#34;&#34;
    if projects_to_filter is None:
        projects_to_filter = []

    import benchbuild.projects as all_projects
    all_projects.discover()

    prjs = ProjectRegistry.projects
    if projects_to_filter:
        prjs = {}
        def single_version_impl(version):
            return lambda: [version]

        for filter_project in set(projects_to_filter):
            project_str, version = __split_project_input__(filter_project)
            try:
                for name, project_type in ProjectRegistry.projects.items(
                        prefix=project_str):
                    if version:
                        project_type.versions = single_version_impl(version)
                    prjs.update({name: project_type})
            except KeyError:
                pass

    if group:
        groupkeys = set(group)
        prjs = {
            name: cls
            for name, cls in prjs.items() if cls.GROUP in groupkeys
        }

    return {
        x: prjs[x]
        for x in prjs if prjs[x].DOMAIN != &#34;debug&#34; or x in projects_to_filter
    }</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="benchbuild.project.populate"><code class="name flex">
<span>def <span class="ident">populate</span></span>(<span>projects_to_filter=None, group=None) ->Â Mapping[str,Â Tuple[Type[<a title="benchbuild.project.Project" href="#benchbuild.project.Project">Project</a>],Â Union[str,Â NoneType]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Populate the list of projects that belong to this experiment.</p>
<h2 id="args">Args</h2>
<p>projects_to_filter (list(Project)):
List of projects we want to assign to this experiment.
We intersect the list of projects with the list of supported
projects to get the list of projects that belong to this
experiment.
group (list(str)):
In addition to the project filter, we provide a way to filter
whole groups.</p>
<h2 id="returns">Returns</h2>
<p>a dictionary of (project name, project class) pairs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate(projects_to_filter=None,
             group=None) -&gt; Mapping[str, Tuple[Type[Project], Optional[str]]]:
    &#34;&#34;&#34;
    Populate the list of projects that belong to this experiment.

    Args:
        projects_to_filter (list(Project)):
            List of projects we want to assign to this experiment.
            We intersect the list of projects with the list of supported
            projects to get the list of projects that belong to this
            experiment.
        group (list(str)):
            In addition to the project filter, we provide a way to filter
            whole groups.
    Returns:
        a dictionary of (project name, project class) pairs.
    &#34;&#34;&#34;
    if projects_to_filter is None:
        projects_to_filter = []

    import benchbuild.projects as all_projects
    all_projects.discover()

    prjs = ProjectRegistry.projects
    if projects_to_filter:
        prjs = {}
        def single_version_impl(version):
            return lambda: [version]

        for filter_project in set(projects_to_filter):
            project_str, version = __split_project_input__(filter_project)
            try:
                for name, project_type in ProjectRegistry.projects.items(
                        prefix=project_str):
                    if version:
                        project_type.versions = single_version_impl(version)
                    prjs.update({name: project_type})
            except KeyError:
                pass

    if group:
        groupkeys = set(group)
        prjs = {
            name: cls
            for name, cls in prjs.items() if cls.GROUP in groupkeys
        }

    return {
        x: prjs[x]
        for x in prjs if prjs[x].DOMAIN != &#34;debug&#34; or x in projects_to_filter
    }</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="benchbuild.project.Project"><code class="flex name class">
<span>class <span class="ident">Project</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class for benchbuild projects.</p>
<p>A project is an arbitrary software system usable by benchbuild in
experiments.
Subclasses of Project are registered automatically by benchbuild, if
imported in the same interpreter session. For this to happen, you must list
the in the settings under plugins -&gt; projects.</p>
<p>A project implementation <em>must</em> provide the following method:
compile: Downloads &amp; Compiles the source.</p>
<p>A project implementation <em>may</em> provide the following functions:
run_tests: Wrap any binary that has to be run under the
runtime_extension wrapper and execute an implementation defined
set of run-time tests.
Defaults to a call of a binary with the name <code>run_f</code> in the
build directory without arguments.
clean: Clean the project's build directory. Defaults to
recursive 'rm' on the build directory and can be disabled
by setting the environment variable <code>BB_CLEAN=false</code>.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>Class definition raises an attribute error, if
the implementation does not provide a value for the attributes
<code>NAME</code>, <code>DOMAIN</code>, and <code>GROUP</code></dd>
<dt><code>TypeError</code></dt>
<dd>Validation of properties may throw a TypeError.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<p>experiment (benchbuild.experiment.Experiment):
The experiment this project is assigned to.
name (str, optional):
The name of this project. Defaults to <code>NAME</code>.
domain (str, optional):
The application domain of this project. Defaults to <code>DOMAIN</code>.
group (str, optional):
The group this project belongs to. Defaults to <code>GROUP</code>.
src_file (str, optional):
A main src_file this project is assigned to. Defaults to <code>SRC_FILE</code>
container (benchbuild.utils.container.Container, optional):
A uchroot compatible container that we can use for this project.
Defaults to <code><a title="benchbuild.utils.container.Gentoo" href="utils/container.html#benchbuild.utils.container.Gentoo">Gentoo</a></code>.
version (str, optional):
A version information for this project. Defaults to <code>VERSION</code>.
builddir (str, optional):
The build directory for this project. Auto generated, if not set.
testdir (str, optional):
The location of any additional test-files for this project,
usually stored out of tree. Auto generated, if not set. Usually a
project implementation
will define this itself.
cflags (:obj:<code>list</code> of :obj:<code>str</code>, optional)
A list of cflags used, for compilation of this project.
ldflags (:obj:<code>list</code> of :obj:<code>str</code>, optional)
A list of ldflags used, for compilation of this project.
run_f (str, optional):
A filename that points to the binary we want to track.
Usually a project implementation will define this itself.
run_uuid (uuid.UUID, optional):
An UUID that identifies all binaries executed by a single run of
this project. In the database schema this is named the 'run_group'.
compiler_extension (Callable[str, iterable[str], RunInfo], optional):
A composable extension that will be used in place of the real
compiler. Defaults to running the compiler with a timeout command
wrapped around it.
runtime_extension (Callable[str, iterable[str], RunInfo], optional):
A composable extension that will be used in place of any binary
this project
wants to execute. Which binaries to replace is defined by the
implementation using <code><a title="benchbuild.utils.wrapping.wrap" href="utils/wrapping.html#benchbuild.utils.wrapping.wrap">wrap()</a></code>.
Defaults to None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Project(metaclass=ProjectDecorator):
    &#34;&#34;&#34;Abstract class for benchbuild projects.

    A project is an arbitrary software system usable by benchbuild in
    experiments.
    Subclasses of Project are registered automatically by benchbuild, if
    imported in the same interpreter session. For this to happen, you must list
    the in the settings under plugins -&gt; projects.

    A project implementation *must* provide the following method:
        compile: Downloads &amp; Compiles the source.

    A project implementation *may* provide the following functions:
        run_tests: Wrap any binary that has to be run under the
            runtime_extension wrapper and execute an implementation defined
            set of run-time tests.
            Defaults to a call of a binary with the name `run_f` in the
            build directory without arguments.
        clean: Clean the project&#39;s build directory. Defaults to
            recursive &#39;rm&#39; on the build directory and can be disabled
            by setting the environment variable ``BB_CLEAN=false``.

    Raises:
        AttributeError: Class definition raises an attribute error, if
            the implementation does not provide a value for the attributes
            `NAME`, `DOMAIN`, and `GROUP`
        TypeError: Validation of properties may throw a TypeError.

    Attributes:
        experiment (benchbuild.experiment.Experiment):
            The experiment this project is assigned to.
        name (str, optional):
            The name of this project. Defaults to `NAME`.
        domain (str, optional):
            The application domain of this project. Defaults to `DOMAIN`.
        group (str, optional):
            The group this project belongs to. Defaults to `GROUP`.
        src_file (str, optional):
            A main src_file this project is assigned to. Defaults to `SRC_FILE`
        container (benchbuild.utils.container.Container, optional):
            A uchroot compatible container that we can use for this project.
            Defaults to `benchbuild.utils.container.Gentoo`.
        version (str, optional):
            A version information for this project. Defaults to `VERSION`.
        builddir (str, optional):
            The build directory for this project. Auto generated, if not set.
        testdir (str, optional):
            The location of any additional test-files for this project,
            usually stored out of tree. Auto generated, if not set. Usually a
            project implementation
            will define this itself.
        cflags (:obj:`list` of :obj:`str`, optional)
            A list of cflags used, for compilation of this project.
        ldflags (:obj:`list` of :obj:`str`, optional)
            A list of ldflags used, for compilation of this project.
        run_f (str, optional):
            A filename that points to the binary we want to track.
            Usually a project implementation will define this itself.
        run_uuid (uuid.UUID, optional):
            An UUID that identifies all binaries executed by a single run of
            this project. In the database schema this is named the &#39;run_group&#39;.
        compiler_extension (Callable[str, iterable[str], RunInfo], optional):
            A composable extension that will be used in place of the real
            compiler. Defaults to running the compiler with a timeout command
            wrapped around it.
        runtime_extension (Callable[str, iterable[str], RunInfo], optional):
            A composable extension that will be used in place of any binary
            this project
            wants to execute. Which binaries to replace is defined by the
            implementation using `benchbuild.utils.wrapping.wrap`.
            Defaults to None.
    &#34;&#34;&#34;
    NAME = None
    DOMAIN = None
    GROUP = None
    VERSION = None
    SRC_FILE = None
    CONTAINER = None

    def __new__(cls, *args, **kwargs):
        &#34;&#34;&#34;Create a new project instance and set some defaults.&#34;&#34;&#34;
        new_self = super(Project, cls).__new__(cls)
        if cls.NAME is None:
            raise AttributeError(
                &#34;{0} @ {1} does not define a NAME class attribute.&#34;.format(
                    cls.__name__, cls.__module__))
        if cls.DOMAIN is None:
            raise AttributeError(
                &#34;{0} @ {1} does not define a DOMAIN class attribute.&#34;.format(
                    cls.__name__, cls.__module__))
        if cls.GROUP is None:
            raise AttributeError(
                &#34;{0} @ {1} does not define a GROUP class attribute.&#34;.format(
                    cls.__name__, cls.__module__))
        return new_self

    experiment = attr.ib()

    name = attr.ib(
        default=attr.Factory(lambda self: type(self).NAME, takes_self=True))

    domain = attr.ib(
        default=attr.Factory(lambda self: type(self).DOMAIN, takes_self=True))

    group = attr.ib(
        default=attr.Factory(lambda self: type(self).GROUP, takes_self=True))

    src_file = attr.ib(
        default=attr.Factory(
            lambda self: type(self).SRC_FILE, takes_self=True))

    container = attr.ib(
        default=attr.Factory(
            lambda self: type(self).CONTAINER, takes_self=True))

    version = attr.ib(
        default=attr.Factory(lambda self: type(self).VERSION, takes_self=True))

    testdir = attr.ib()

    @testdir.default
    def __default_testdir(self):
        if self.group:
            return local.path(str(
                CFG[&#34;test_dir&#34;])) / self.domain / self.group / self.name
        return local.path(str(CFG[&#34;test_dir&#34;])) / self.domain / self.name

    cflags = attr.ib(default=attr.Factory(list))

    ldflags = attr.ib(default=attr.Factory(list))

    run_uuid = attr.ib()

    @run_uuid.default
    def __default_run_uuid(self):
        run_group = getenv(&#34;BB_DB_RUN_GROUP&#34;, None)
        if run_group:
            return uuid.UUID(run_group)
        return uuid.uuid4()

    @run_uuid.validator
    def __check_if_uuid(self, _, value):
        if not isinstance(value, uuid.UUID):
            raise TypeError(&#34;{attribute} must be a valid UUID object&#34;)

    builddir = attr.ib(default=attr.Factory(
        lambda self: local.path(str(CFG[&#34;build_dir&#34;])) /
        &#34;{}-{}&#34;.format(
            self.experiment.name, self.id),
        takes_self=True))

    run_f = attr.ib(
        default=attr.Factory(
            lambda self: local.path(self.builddir) / self.name,
            takes_self=True))

    compiler_extension = attr.ib(default=attr.Factory(
        lambda self: ext_run.WithTimeout(
            compiler.RunCompiler(self, self.experiment)), takes_self=True))

    runtime_extension = attr.ib(default=None)

    def __attrs_post_init__(self):
        db.persist_project(self)

    def run_tests(self, runner):
        &#34;&#34;&#34;
        Run the tests of this project.

        Clients override this method to provide customized run-time tests.

        Args:
            experiment: The experiment we run this project under
            run: A function that takes the run command.
        &#34;&#34;&#34;
        exp = wrapping.wrap(self.run_f, self)
        runner(exp)

    def run(self):
        &#34;&#34;&#34;Run the tests of this project.

        This method initializes the default environment and takes care of
        cleaning up the mess we made, after a successfull run.

        Args:
            experiment: The experiment we run this project under
        &#34;&#34;&#34;
        from benchbuild.utils.run import (begin_run_group, end_run_group,
                                          fail_run_group)
        CFG[&#34;experiment&#34;] = self.experiment.name
        CFG[&#34;project&#34;] = self.NAME
        CFG[&#34;domain&#34;] = self.DOMAIN
        CFG[&#34;group&#34;] = self.GROUP
        CFG[&#34;version&#34;] = self.VERSION
        CFG[&#34;db&#34;][&#34;run_group&#34;] = str(self.run_uuid)

        group, session = begin_run_group(self)
        signals.handlers.register(fail_run_group, group, session)

        try:
            self.run_tests(run.run)
            end_run_group(group, session)
        except ProcessExecutionError:
            fail_run_group(group, session)
            raise
        except KeyboardInterrupt:
            fail_run_group(group, session)
            raise
        finally:
            signals.handlers.deregister(fail_run_group)

    def clean(self):
        &#34;&#34;&#34;Clean the project build directory.&#34;&#34;&#34;
        builddir_p = local.path(self.builddir)
        builddir_p.delete()

    def prepare(self):
        &#34;&#34;&#34;Prepare the build diretory.&#34;&#34;&#34;
        builddir_p = local.path(self.builddir)
        if not builddir_p.exists():
            builddir_p.mkdir()

    @abstractmethod
    def compile(self):
        &#34;&#34;&#34;Compile the project.&#34;&#34;&#34;

    def download(self, version=None):
        &#34;&#34;&#34;Auto-generated by with_* decorators.&#34;&#34;&#34;
        del version
        LOG.error(&#34;Not implemented.&#34;)

    def redirect(self):
        &#34;&#34;&#34;Redirect execution to a containerized benchbuild instance.&#34;&#34;&#34;
        LOG.error(&#34;Redirection not supported by project.&#34;)

    def clone(self):
        &#34;&#34;&#34;Create a deepcopy of ourself.&#34;&#34;&#34;
        new_p = copy.deepcopy(self)
        new_p.run_uuid = uuid.uuid4()
        return new_p

    @property
    def id(self):
        return &#34;{name}-{group}@{version}_uuid_{id}&#34;.format(
            name=self.name,
            group=self.group,
            version=self.version,
            id=self.run_uuid)

    @classmethod
    def versions(cls):
        &#34;&#34;&#34;Return all available versions.&#34;&#34;&#34;
        if cls.VERSION:
            return [cls.VERSION]
        return [&#34;unknown&#34;]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="benchbuild.projects.apollo.rodinia.RodiniaGroup" href="projects/apollo/rodinia.html#benchbuild.projects.apollo.rodinia.RodiniaGroup">RodiniaGroup</a></li>
<li><a title="benchbuild.projects.apollo.scimark.SciMark" href="projects/apollo/scimark.html#benchbuild.projects.apollo.scimark.SciMark">SciMark</a></li>
<li><a title="benchbuild.projects.benchbuild.bots.BOTSGroup" href="projects/benchbuild/bots.html#benchbuild.projects.benchbuild.bots.BOTSGroup">BOTSGroup</a></li>
<li><a title="benchbuild.projects.benchbuild.bzip2.Bzip2" href="projects/benchbuild/bzip2.html#benchbuild.projects.benchbuild.bzip2.Bzip2">Bzip2</a></li>
<li><a title="benchbuild.projects.benchbuild.ccrypt.Ccrypt" href="projects/benchbuild/ccrypt.html#benchbuild.projects.benchbuild.ccrypt.Ccrypt">Ccrypt</a></li>
<li><a title="benchbuild.projects.benchbuild.crafty.Crafty" href="projects/benchbuild/crafty.html#benchbuild.projects.benchbuild.crafty.Crafty">Crafty</a></li>
<li><a title="benchbuild.projects.benchbuild.crocopat.Crocopat" href="projects/benchbuild/crocopat.html#benchbuild.projects.benchbuild.crocopat.Crocopat">Crocopat</a></li>
<li><a title="benchbuild.projects.benchbuild.ffmpeg.LibAV" href="projects/benchbuild/ffmpeg.html#benchbuild.projects.benchbuild.ffmpeg.LibAV">LibAV</a></li>
<li><a title="benchbuild.projects.benchbuild.gzip.Gzip" href="projects/benchbuild/gzip.html#benchbuild.projects.benchbuild.gzip.Gzip">Gzip</a></li>
<li><a title="benchbuild.projects.benchbuild.js.SpiderMonkey" href="projects/benchbuild/js.html#benchbuild.projects.benchbuild.js.SpiderMonkey">SpiderMonkey</a></li>
<li><a title="benchbuild.projects.benchbuild.lammps.Lammps" href="projects/benchbuild/lammps.html#benchbuild.projects.benchbuild.lammps.Lammps">Lammps</a></li>
<li><a title="benchbuild.projects.benchbuild.lapack.Lapack" href="projects/benchbuild/lapack.html#benchbuild.projects.benchbuild.lapack.Lapack">Lapack</a></li>
<li><a title="benchbuild.projects.benchbuild.lapack.OpenBlas" href="projects/benchbuild/lapack.html#benchbuild.projects.benchbuild.lapack.OpenBlas">OpenBlas</a></li>
<li><a title="benchbuild.projects.benchbuild.leveldb.LevelDB" href="projects/benchbuild/leveldb.html#benchbuild.projects.benchbuild.leveldb.LevelDB">LevelDB</a></li>
<li><a title="benchbuild.projects.benchbuild.linpack.Linpack" href="projects/benchbuild/linpack.html#benchbuild.projects.benchbuild.linpack.Linpack">Linpack</a></li>
<li><a title="benchbuild.projects.benchbuild.lulesh.Lulesh" href="projects/benchbuild/lulesh.html#benchbuild.projects.benchbuild.lulesh.Lulesh">Lulesh</a></li>
<li><a title="benchbuild.projects.benchbuild.lulesh.LuleshOMP" href="projects/benchbuild/lulesh.html#benchbuild.projects.benchbuild.lulesh.LuleshOMP">LuleshOMP</a></li>
<li><a title="benchbuild.projects.benchbuild.mcrypt.MCrypt" href="projects/benchbuild/mcrypt.html#benchbuild.projects.benchbuild.mcrypt.MCrypt">MCrypt</a></li>
<li><a title="benchbuild.projects.benchbuild.minisat.Minisat" href="projects/benchbuild/minisat.html#benchbuild.projects.benchbuild.minisat.Minisat">Minisat</a></li>
<li><a title="benchbuild.projects.benchbuild.openssl.LibreSSL" href="projects/benchbuild/openssl.html#benchbuild.projects.benchbuild.openssl.LibreSSL">LibreSSL</a></li>
<li><a title="benchbuild.projects.benchbuild.povray.Povray" href="projects/benchbuild/povray.html#benchbuild.projects.benchbuild.povray.Povray">Povray</a></li>
<li><a title="benchbuild.projects.benchbuild.python.Python" href="projects/benchbuild/python.html#benchbuild.projects.benchbuild.python.Python">Python</a></li>
<li><a title="benchbuild.projects.benchbuild.rasdaman.Rasdaman" href="projects/benchbuild/rasdaman.html#benchbuild.projects.benchbuild.rasdaman.Rasdaman">Rasdaman</a></li>
<li><a title="benchbuild.projects.benchbuild.ruby.Ruby" href="projects/benchbuild/ruby.html#benchbuild.projects.benchbuild.ruby.Ruby">Ruby</a></li>
<li><a title="benchbuild.projects.benchbuild.sdcc.SDCC" href="projects/benchbuild/sdcc.html#benchbuild.projects.benchbuild.sdcc.SDCC">SDCC</a></li>
<li><a title="benchbuild.projects.benchbuild.sevenz.SevenZip" href="projects/benchbuild/sevenz.html#benchbuild.projects.benchbuild.sevenz.SevenZip">SevenZip</a></li>
<li><a title="benchbuild.projects.benchbuild.sqlite3.SQLite3" href="projects/benchbuild/sqlite3.html#benchbuild.projects.benchbuild.sqlite3.SQLite3">SQLite3</a></li>
<li><a title="benchbuild.projects.benchbuild.tcc.TCC" href="projects/benchbuild/tcc.html#benchbuild.projects.benchbuild.tcc.TCC">TCC</a></li>
<li><a title="benchbuild.projects.benchbuild.x264.X264" href="projects/benchbuild/x264.html#benchbuild.projects.benchbuild.x264.X264">X264</a></li>
<li><a title="benchbuild.projects.benchbuild.xz.XZ" href="projects/benchbuild/xz.html#benchbuild.projects.benchbuild.xz.XZ">XZ</a></li>
<li><a title="benchbuild.projects.gentoo.gentoo.GentooGroup" href="projects/gentoo/gentoo.html#benchbuild.projects.gentoo.gentoo.GentooGroup">GentooGroup</a></li>
<li><a title="benchbuild.projects.lnt.lnt.LNTGroup" href="projects/lnt/lnt.html#benchbuild.projects.lnt.lnt.LNTGroup">LNTGroup</a></li>
<li><a title="benchbuild.projects.polybench.polybench.PolyBenchGroup" href="projects/polybench/polybench.html#benchbuild.projects.polybench.polybench.PolyBenchGroup">PolyBenchGroup</a></li>
<li><a title="benchbuild.projects.test.test.TestProject" href="projects/test/test.html#benchbuild.projects.test.test.TestProject">TestProject</a></li>
<li><a title="benchbuild.projects.test.test.TestProjectRuntimeFail" href="projects/test/test.html#benchbuild.projects.test.test.TestProjectRuntimeFail">TestProjectRuntimeFail</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="benchbuild.project.Project.CONTAINER"><code class="name">var <span class="ident">CONTAINER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="benchbuild.project.Project.DOMAIN"><code class="name">var <span class="ident">DOMAIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="benchbuild.project.Project.GROUP"><code class="name">var <span class="ident">GROUP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="benchbuild.project.Project.NAME"><code class="name">var <span class="ident">NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="benchbuild.project.Project.SRC_FILE"><code class="name">var <span class="ident">SRC_FILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="benchbuild.project.Project.VERSION"><code class="name">var <span class="ident">VERSION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="benchbuild.project.Project.versions"><code class="name flex">
<span>def <span class="ident">versions</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all available versions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def versions(cls):
    &#34;&#34;&#34;Return all available versions.&#34;&#34;&#34;
    if cls.VERSION:
        return [cls.VERSION]
    return [&#34;unknown&#34;]</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="benchbuild.project.Project.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self):
    return &#34;{name}-{group}@{version}_uuid_{id}&#34;.format(
        name=self.name,
        group=self.group,
        version=self.version,
        id=self.run_uuid)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.project.Project.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clean the project build directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self):
    &#34;&#34;&#34;Clean the project build directory.&#34;&#34;&#34;
    builddir_p = local.path(self.builddir)
    builddir_p.delete()</code></pre>
</details>
</dd>
<dt id="benchbuild.project.Project.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a deepcopy of ourself.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone(self):
    &#34;&#34;&#34;Create a deepcopy of ourself.&#34;&#34;&#34;
    new_p = copy.deepcopy(self)
    new_p.run_uuid = uuid.uuid4()
    return new_p</code></pre>
</details>
</dd>
<dt id="benchbuild.project.Project.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compile the project.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def compile(self):
    &#34;&#34;&#34;Compile the project.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="benchbuild.project.Project.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, version=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Auto-generated by with_* decorators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self, version=None):
    &#34;&#34;&#34;Auto-generated by with_* decorators.&#34;&#34;&#34;
    del version
    LOG.error(&#34;Not implemented.&#34;)</code></pre>
</details>
</dd>
<dt id="benchbuild.project.Project.prepare"><code class="name flex">
<span>def <span class="ident">prepare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare the build diretory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare(self):
    &#34;&#34;&#34;Prepare the build diretory.&#34;&#34;&#34;
    builddir_p = local.path(self.builddir)
    if not builddir_p.exists():
        builddir_p.mkdir()</code></pre>
</details>
</dd>
<dt id="benchbuild.project.Project.redirect"><code class="name flex">
<span>def <span class="ident">redirect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Redirect execution to a containerized benchbuild instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redirect(self):
    &#34;&#34;&#34;Redirect execution to a containerized benchbuild instance.&#34;&#34;&#34;
    LOG.error(&#34;Redirection not supported by project.&#34;)</code></pre>
</details>
</dd>
<dt id="benchbuild.project.Project.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the tests of this project.</p>
<p>This method initializes the default environment and takes care of
cleaning up the mess we made, after a successfull run.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>experiment</code></strong></dt>
<dd>The experiment we run this project under</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;Run the tests of this project.

    This method initializes the default environment and takes care of
    cleaning up the mess we made, after a successfull run.

    Args:
        experiment: The experiment we run this project under
    &#34;&#34;&#34;
    from benchbuild.utils.run import (begin_run_group, end_run_group,
                                      fail_run_group)
    CFG[&#34;experiment&#34;] = self.experiment.name
    CFG[&#34;project&#34;] = self.NAME
    CFG[&#34;domain&#34;] = self.DOMAIN
    CFG[&#34;group&#34;] = self.GROUP
    CFG[&#34;version&#34;] = self.VERSION
    CFG[&#34;db&#34;][&#34;run_group&#34;] = str(self.run_uuid)

    group, session = begin_run_group(self)
    signals.handlers.register(fail_run_group, group, session)

    try:
        self.run_tests(run.run)
        end_run_group(group, session)
    except ProcessExecutionError:
        fail_run_group(group, session)
        raise
    except KeyboardInterrupt:
        fail_run_group(group, session)
        raise
    finally:
        signals.handlers.deregister(fail_run_group)</code></pre>
</details>
</dd>
<dt id="benchbuild.project.Project.run_tests"><code class="name flex">
<span>def <span class="ident">run_tests</span></span>(<span>self, runner)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the tests of this project.</p>
<p>Clients override this method to provide customized run-time tests.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>experiment</code></strong></dt>
<dd>The experiment we run this project under</dd>
<dt><strong><code>run</code></strong></dt>
<dd>A function that takes the run command.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_tests(self, runner):
    &#34;&#34;&#34;
    Run the tests of this project.

    Clients override this method to provide customized run-time tests.

    Args:
        experiment: The experiment we run this project under
        run: A function that takes the run command.
    &#34;&#34;&#34;
    exp = wrapping.wrap(self.run_f, self)
    runner(exp)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.project.ProjectDecorator"><code class="flex name class">
<span>class <span class="ident">ProjectDecorator</span></span>
<span>(</span><span>name, bases, attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorate the interface of a project with the in_builddir decorator.</p>
<p>This is just a small safety net for benchbuild users, because we make
sure to run every project method in the project's build directory.</p>
<p>Register a project in the registry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProjectDecorator(ProjectRegistry):
    &#34;&#34;&#34;
    Decorate the interface of a project with the in_builddir decorator.

    This is just a small safety net for benchbuild users, because we make
    sure to run every project method in the project&#39;s build directory.
    &#34;&#34;&#34;

    decorated_methods = [&#34;redirect&#34;, &#34;compile&#34;, &#34;run_tests&#34;]

    def __init__(cls, name, bases, attrs):
        unionfs_deco = None
        if CFG[&#34;unionfs&#34;][&#34;enable&#34;]:
            rw_dir = str(CFG[&#34;unionfs&#34;][&#34;rw&#34;])
            unionfs_deco = partial(unionfs.unionfs, rw=rw_dir)
        config_deco = run.store_config

        methods = ProjectDecorator.decorated_methods
        for key, value in attrs.items():
            if (key in methods) and hasattr(cls, key):
                wrapped_fun = value
                wrapped_fun = config_deco(wrapped_fun)

                if unionfs_deco is not None:
                    wrapped_fun = unionfs_deco()(wrapped_fun)

                wrapped_fun = run.in_builddir(&#39;.&#39;)(wrapped_fun)
                setattr(cls, key, wrapped_fun)

        super(ProjectDecorator, cls).__init__(name, bases, attrs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="benchbuild.project.ProjectRegistry" href="#benchbuild.project.ProjectRegistry">ProjectRegistry</a></li>
<li>builtins.type</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="benchbuild.project.ProjectDecorator.decorated_methods"><code class="name">var <span class="ident">decorated_methods</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="benchbuild.project.ProjectRegistry"><code class="flex name class">
<span>class <span class="ident">ProjectRegistry</span></span>
<span>(</span><span>name, bases, attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>Registry for benchbuild projects.</p>
<p>Register a project in the registry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProjectRegistry(type):
    &#34;&#34;&#34;Registry for benchbuild projects.&#34;&#34;&#34;

    projects = StringTrie()

    def __init__(cls, name, bases, attrs):
        &#34;&#34;&#34;Register a project in the registry.&#34;&#34;&#34;
        super(ProjectRegistry, cls).__init__(name, bases, attrs)

        if None not in {cls.NAME, cls.DOMAIN, cls.GROUP}:
            key = &#34;{name}/{group}&#34;.format(name=cls.NAME, group=cls.GROUP)
            ProjectRegistry.projects[key] = cls</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="benchbuild.project.ProjectDecorator" href="#benchbuild.project.ProjectDecorator">ProjectDecorator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="benchbuild.project.ProjectRegistry.projects"><code class="name">var <span class="ident">projects</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="benchbuild" href="index.html">benchbuild</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="benchbuild.project.populate" href="#benchbuild.project.populate">populate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="benchbuild.project.Project" href="#benchbuild.project.Project">Project</a></code></h4>
<ul class="two-column">
<li><code><a title="benchbuild.project.Project.CONTAINER" href="#benchbuild.project.Project.CONTAINER">CONTAINER</a></code></li>
<li><code><a title="benchbuild.project.Project.DOMAIN" href="#benchbuild.project.Project.DOMAIN">DOMAIN</a></code></li>
<li><code><a title="benchbuild.project.Project.GROUP" href="#benchbuild.project.Project.GROUP">GROUP</a></code></li>
<li><code><a title="benchbuild.project.Project.NAME" href="#benchbuild.project.Project.NAME">NAME</a></code></li>
<li><code><a title="benchbuild.project.Project.SRC_FILE" href="#benchbuild.project.Project.SRC_FILE">SRC_FILE</a></code></li>
<li><code><a title="benchbuild.project.Project.VERSION" href="#benchbuild.project.Project.VERSION">VERSION</a></code></li>
<li><code><a title="benchbuild.project.Project.clean" href="#benchbuild.project.Project.clean">clean</a></code></li>
<li><code><a title="benchbuild.project.Project.clone" href="#benchbuild.project.Project.clone">clone</a></code></li>
<li><code><a title="benchbuild.project.Project.compile" href="#benchbuild.project.Project.compile">compile</a></code></li>
<li><code><a title="benchbuild.project.Project.download" href="#benchbuild.project.Project.download">download</a></code></li>
<li><code><a title="benchbuild.project.Project.id" href="#benchbuild.project.Project.id">id</a></code></li>
<li><code><a title="benchbuild.project.Project.prepare" href="#benchbuild.project.Project.prepare">prepare</a></code></li>
<li><code><a title="benchbuild.project.Project.redirect" href="#benchbuild.project.Project.redirect">redirect</a></code></li>
<li><code><a title="benchbuild.project.Project.run" href="#benchbuild.project.Project.run">run</a></code></li>
<li><code><a title="benchbuild.project.Project.run_tests" href="#benchbuild.project.Project.run_tests">run_tests</a></code></li>
<li><code><a title="benchbuild.project.Project.versions" href="#benchbuild.project.Project.versions">versions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.project.ProjectDecorator" href="#benchbuild.project.ProjectDecorator">ProjectDecorator</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.project.ProjectDecorator.decorated_methods" href="#benchbuild.project.ProjectDecorator.decorated_methods">decorated_methods</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.project.ProjectRegistry" href="#benchbuild.project.ProjectRegistry">ProjectRegistry</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.project.ProjectRegistry.projects" href="#benchbuild.project.ProjectRegistry.projects">projects</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>