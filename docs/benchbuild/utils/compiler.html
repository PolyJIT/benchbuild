<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>benchbuild.utils.compiler API documentation</title>
<meta name="description" content="Helper functions for dealing with compiler replacement â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>benchbuild.utils.compiler</code></h1>
</header>
<section id="section-intro">
<p>Helper functions for dealing with compiler replacement.</p>
<p>This provides a few key functions to deal with varying/measuring the compilers
used inside the benchbuild study.
From a high-level view, there are 2 interesting functions:
* cc(project, detect_project=True)
* cxx(project, detect_project=True)</p>
<p>These generate a wrapped clang/clang++ in the current working directory and
hide the given cflags/ldflags from the calling build system. Both will
give you a working plumbum command and call a python script that redirects
to the real clang/clang++ given the additional cflags&amp;ldflags.</p>
<p>The wrapper-script generated for both functions can be found inside:
* wrap_cc()</p>
<p>Are just convencience methods that can be used when interacting with the
configured llvm/clang source directories.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Helper functions for dealing with compiler replacement.

This provides a few key functions to deal with varying/measuring the compilers
used inside the benchbuild study.
From a high-level view, there are 2 interesting functions:
    * cc(project, detect_project=True)
    * cxx(project, detect_project=True)

These generate a wrapped clang/clang++ in the current working directory and
hide the given cflags/ldflags from the calling build system. Both will
give you a working plumbum command and call a python script that redirects
to the real clang/clang++ given the additional cflags&amp;ldflags.

The wrapper-script generated for both functions can be found inside:
    * wrap_cc()

Are just convencience methods that can be used when interacting with the
configured llvm/clang source directories.
&#34;&#34;&#34;
from plumbum import local

from benchbuild.settings import CFG
from benchbuild.utils.wrapping import wrap_cc


def cc(project, detect_project=False):
    &#34;&#34;&#34;
    Return a clang that hides CFLAGS and LDFLAGS.

    This will generate a wrapper script in the current directory
    and return a complete plumbum command to it.

    Args:
        cflags: The CFLAGS we want to hide.
        ldflags: The LDFLAGS we want to hide.
        func (optional): A function that will be pickled alongside the compiler.
            It will be called before the actual compilation took place. This
            way you can intercept the compilation process with arbitrary python
            code.

    Returns (benchbuild.utils.cmd):
        Path to the new clang command.
    &#34;&#34;&#34;
    from benchbuild.utils import cmd

    cc_name = str(CFG[&#34;compiler&#34;][&#34;c&#34;])
    wrap_cc(cc_name, compiler(cc_name), project, detect_project=detect_project)
    return cmd[&#34;./{}&#34;.format(cc_name)]


def cxx(project, detect_project=False):
    &#34;&#34;&#34;
    Return a clang++ that hides CFLAGS and LDFLAGS.

    This will generate a wrapper script in the current directory
    and return a complete plumbum command to it.

    Args:
        cflags: The CFLAGS we want to hide.
        ldflags: The LDFLAGS we want to hide.
        func (optional): A function that will be pickled alongside the compiler.
            It will be called before the actual compilation took place. This
            way you can intercept the compilation process with arbitrary python
            code.

    Returns (benchbuild.utils.cmd):
        Path to the new clang command.
    &#34;&#34;&#34;
    from benchbuild.utils import cmd

    cxx_name = str(CFG[&#34;compiler&#34;][&#34;cxx&#34;])
    wrap_cc(
        cxx_name, compiler(cxx_name), project, detect_project=detect_project)
    return cmd[&#34;./{name}&#34;.format(name=cxx_name)]


def __get_paths():
    from os import getenv
    from benchbuild.utils.path import list_to_path

    path = getenv(&#34;PATH&#34;, &#34;&#34;)
    lib_path = getenv(&#34;LD_LIBRARY_PATH&#34;, &#34;&#34;)
    env = CFG[&#34;env&#34;].value

    _lib_path = env.get(&#34;LD_LIBRARY_PATH&#34;, &#34;&#34;)
    _path = env.get(&#34;PATH&#34;, &#34;&#34;)

    _lib_path = list_to_path(_lib_path)
    _path = list_to_path(_path)

    path = list_to_path([_path, path])
    lib_path = list_to_path([_lib_path, lib_path])

    home = env.get(&#34;HOME&#34;, getenv(&#34;HOME&#34;, &#34;&#34;))

    return {&#34;ld_library_path&#34;: lib_path, &#34;path&#34;: path, &#34;home&#34;: home}


def compiler(name):
    &#34;&#34;&#34;
    Get a usable clang++ plumbum command.

    This searches for a usable clang++ in the llvm binary path

    Returns:
        plumbum Command that executes clang++
    &#34;&#34;&#34;
    pinfo = __get_paths()
    _compiler = local[name]
    _compiler = _compiler.setenv(
        PATH=pinfo[&#34;path&#34;], LD_LIBRARY_PATH=pinfo[&#34;ld_library_path&#34;],
        HOME=pinfo[&#34;home&#34;])
    return _compiler</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="benchbuild.utils.compiler.cc"><code class="name flex">
<span>def <span class="ident">cc</span></span>(<span>project, detect_project=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a clang that hides CFLAGS and LDFLAGS.</p>
<p>This will generate a wrapper script in the current directory
and return a complete plumbum command to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cflags</code></strong></dt>
<dd>The CFLAGS we want to hide.</dd>
<dt><strong><code>ldflags</code></strong></dt>
<dd>The LDFLAGS we want to hide.</dd>
<dt><strong><code>func</code></strong> :&ensp;optional</dt>
<dd>A function that will be pickled alongside the compiler.
It will be called before the actual compilation took place. This
way you can intercept the compilation process with arbitrary python
code.</dd>
</dl>
<p>Returns (benchbuild.utils.cmd):
Path to the new clang command.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cc(project, detect_project=False):
    &#34;&#34;&#34;
    Return a clang that hides CFLAGS and LDFLAGS.

    This will generate a wrapper script in the current directory
    and return a complete plumbum command to it.

    Args:
        cflags: The CFLAGS we want to hide.
        ldflags: The LDFLAGS we want to hide.
        func (optional): A function that will be pickled alongside the compiler.
            It will be called before the actual compilation took place. This
            way you can intercept the compilation process with arbitrary python
            code.

    Returns (benchbuild.utils.cmd):
        Path to the new clang command.
    &#34;&#34;&#34;
    from benchbuild.utils import cmd

    cc_name = str(CFG[&#34;compiler&#34;][&#34;c&#34;])
    wrap_cc(cc_name, compiler(cc_name), project, detect_project=detect_project)
    return cmd[&#34;./{}&#34;.format(cc_name)]</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.compiler.compiler"><code class="name flex">
<span>def <span class="ident">compiler</span></span>(<span>name)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a usable clang++ plumbum command.</p>
<p>This searches for a usable clang++ in the llvm binary path</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plumbum</code> <code>Command</code> <code>that</code> <code>executes</code> <code>clang</code>++</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compiler(name):
    &#34;&#34;&#34;
    Get a usable clang++ plumbum command.

    This searches for a usable clang++ in the llvm binary path

    Returns:
        plumbum Command that executes clang++
    &#34;&#34;&#34;
    pinfo = __get_paths()
    _compiler = local[name]
    _compiler = _compiler.setenv(
        PATH=pinfo[&#34;path&#34;], LD_LIBRARY_PATH=pinfo[&#34;ld_library_path&#34;],
        HOME=pinfo[&#34;home&#34;])
    return _compiler</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.compiler.cxx"><code class="name flex">
<span>def <span class="ident">cxx</span></span>(<span>project, detect_project=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a clang++ that hides CFLAGS and LDFLAGS.</p>
<p>This will generate a wrapper script in the current directory
and return a complete plumbum command to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cflags</code></strong></dt>
<dd>The CFLAGS we want to hide.</dd>
<dt><strong><code>ldflags</code></strong></dt>
<dd>The LDFLAGS we want to hide.</dd>
<dt><strong><code>func</code></strong> :&ensp;optional</dt>
<dd>A function that will be pickled alongside the compiler.
It will be called before the actual compilation took place. This
way you can intercept the compilation process with arbitrary python
code.</dd>
</dl>
<p>Returns (benchbuild.utils.cmd):
Path to the new clang command.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cxx(project, detect_project=False):
    &#34;&#34;&#34;
    Return a clang++ that hides CFLAGS and LDFLAGS.

    This will generate a wrapper script in the current directory
    and return a complete plumbum command to it.

    Args:
        cflags: The CFLAGS we want to hide.
        ldflags: The LDFLAGS we want to hide.
        func (optional): A function that will be pickled alongside the compiler.
            It will be called before the actual compilation took place. This
            way you can intercept the compilation process with arbitrary python
            code.

    Returns (benchbuild.utils.cmd):
        Path to the new clang command.
    &#34;&#34;&#34;
    from benchbuild.utils import cmd

    cxx_name = str(CFG[&#34;compiler&#34;][&#34;cxx&#34;])
    wrap_cc(
        cxx_name, compiler(cxx_name), project, detect_project=detect_project)
    return cmd[&#34;./{name}&#34;.format(name=cxx_name)]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="benchbuild.utils" href="index.html">benchbuild.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="benchbuild.utils.compiler.cc" href="#benchbuild.utils.compiler.cc">cc</a></code></li>
<li><code><a title="benchbuild.utils.compiler.compiler" href="#benchbuild.utils.compiler.compiler">compiler</a></code></li>
<li><code><a title="benchbuild.utils.compiler.cxx" href="#benchbuild.utils.compiler.cxx">cxx</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>