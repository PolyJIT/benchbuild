<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>benchbuild.utils.download API documentation</title>
<meta name="description" content="Downloading helper functions for benchbuild â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>benchbuild.utils.download</code></h1>
</header>
<section id="section-intro">
<h1 id="downloading-helper-functions-for-benchbuild">Downloading helper functions for benchbuild.</h1>
<p>The helpers defined in this module provide access to some common Downloading
methods for the source code of benchbuild projects.
All downloads will be cached in BB_TMP_DIR and locked down with a hash that
is generated after the first download. If the hash matches the file/folder
found in BB_TMP_DIR, nothing will be downloaded at all.</p>
<p>Supported methods:
Copy, CopyNoFail, Wget, Git, Svn, Rsync</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Downloading helper functions for benchbuild.

The helpers defined in this module provide access to some common Downloading
methods for the source code of benchbuild projects.
All downloads will be cached in BB_TMP_DIR and locked down with a hash that
is generated after the first download. If the hash matches the file/folder
found in BB_TMP_DIR, nothing will be downloaded at all.

Supported methods:
        Copy, CopyNoFail, Wget, Git, Svn, Rsync
&#34;&#34;&#34;
import logging
import os

from plumbum import local

from benchbuild.settings import CFG
from benchbuild.utils.path import flocked

LOG = logging.getLogger(__name__)


def get_hash_of_dirs(directory):
    &#34;&#34;&#34;
    Recursively hash the contents of the given directory.

    Args:
        directory (str): The root directory we want to hash.

    Returns:
        A hash of all the contents in the directory.
    &#34;&#34;&#34;
    import hashlib
    sha = hashlib.sha512()
    if not os.path.exists(directory):
        return -1

    for root, _, files in os.walk(directory):
        for name in files:
            filepath = local.path(root) / name
            if filepath.exists():
                with open(filepath, &#39;rb&#39;) as next_file:
                    for line in next_file:
                        sha.update(line)
    return sha.hexdigest()


def source_required(src_file):
    &#34;&#34;&#34;
    Check, if a download is required.

    Args:
        src_file: The filename to check for.
        src_root: The path we find the file in.

    Returns:
        True, if we need to download something, False otherwise.
    &#34;&#34;&#34;
    if not src_file.exists():
        return True

    required = True
    hash_file = src_file.with_suffix(&#34;.hash&#34;, depth=0)
    LOG.debug(&#34;Hash file location: %s&#34;, hash_file)
    if hash_file.exists():
        new_hash = get_hash_of_dirs(src_file)
        with open(hash_file, &#39;r&#39;) as h_file:
            old_hash = h_file.readline()
        required = not new_hash == old_hash
        if required:
            from benchbuild.utils.cmd import rm
            rm(&#34;-r&#34;, src_file)
            rm(hash_file)
    if required:
        LOG.info(&#34;Source required for: %s&#34;, src_file)
        LOG.debug(&#34;Reason: src-exists: %s hash-exists: %s&#34;, src_file.exists(),
                  hash_file.exists())
    return required


def update_hash(src_file):
    &#34;&#34;&#34;
    Update the hash for the given file.

    Args:
        src: The file name.
        root: The path of the given file.
    &#34;&#34;&#34;
    hash_file = local.path(src_file) + &#34;.hash&#34;
    new_hash = 0
    with open(hash_file, &#39;w&#39;) as h_file:
        new_hash = get_hash_of_dirs(src_file)
        h_file.write(str(new_hash))
    return new_hash


def Copy(From, To):
    &#34;&#34;&#34;
    Small copy wrapper.

    Args:
        From (str): Path to the SOURCE.
        To (str): Path to the TARGET.
    &#34;&#34;&#34;
    from benchbuild.utils.cmd import cp
    cp(&#34;-ar&#34;, &#34;--reflink=auto&#34;, From, To)


def CopyNoFail(src, root=None):
    &#34;&#34;&#34;
    Just copy fName into the current working directory, if it exists.

    No action is executed, if fName does not exist. No Hash is checked.

    Args:
        src: The filename we want to copy to &#39;.&#39;.
        root: The optional source dir we should pull fName from. Defaults
            to benchbuild.settings.CFG[&#34;tmpdir&#34;].

    Returns:
        True, if we copied something.
    &#34;&#34;&#34;
    if root is None:
        root = str(CFG[&#34;tmp_dir&#34;])
    src_path = local.path(root) / src

    if src_path.exists():
        Copy(src_path, &#39;.&#39;)
        return True
    return False


def Wget(src_url, tgt_name, tgt_root=None):
    &#34;&#34;&#34;
    Download url, if required.

    Args:
        src_url (str): Our SOURCE url.
        tgt_name (str): The filename we want to have on disk.
        tgt_root (str): The TARGET directory for the download.
            Defaults to ``CFG[&#34;tmpdir&#34;]``.
    &#34;&#34;&#34;
    if tgt_root is None:
        tgt_root = str(CFG[&#34;tmp_dir&#34;])

    from benchbuild.utils.cmd import wget

    tgt_file = local.path(tgt_root) / tgt_name
    if not source_required(tgt_file):
        Copy(tgt_file, &#34;.&#34;)
        return

    wget(src_url, &#34;-O&#34;, tgt_file)
    update_hash(tgt_file)
    Copy(tgt_file, &#34;.&#34;)


def with_wget(url_dict=None, target_file=None):
    &#34;&#34;&#34;
    Decorate a project class with wget-based version information.

    This adds two attributes to a project class:
        - A `versions` method that returns a list of available versions
          for this project.
        - A `repository` attribute that provides a repository string to
          download from later.
    We use the `git rev-list` subcommand to list available versions.

    Args:
        url_dict (dict): A dictionary that assigns a version to a download URL.
        target_file (str): An optional path where we should put the clone.
            If unspecified, we will use the `SRC_FILE` attribute of
            the decorated class.
    &#34;&#34;&#34;

    def wget_decorator(cls):
        def download_impl(self):
            &#34;&#34;&#34;Download the selected version from the url_dict value.&#34;&#34;&#34;
            t_file = target_file if target_file else self.SRC_FILE
            t_version = url_dict[self.version]
            Wget(t_version, t_file)

        @staticmethod
        def versions_impl():
            &#34;&#34;&#34;Return a list of versions from the url_dict keys.&#34;&#34;&#34;
            return list(url_dict.keys())

        cls.versions = versions_impl
        cls.download = download_impl
        return cls

    return wget_decorator


def __clone_needed__(repository: str, directory: str) -&gt; bool:
    &#34;&#34;&#34;
    Do we need to create a fresh clone of the given repository.

    Args:
        repository: the repository we want to clone.
        directory: the directory we expect the clone to live.

    Returns:
        True, if the clone is required.
        False, if the directory is a valid clone.
    &#34;&#34;&#34;
    from benchbuild.utils.cmd import git, rm

    git_dir = local.path(directory) / &#39;.git&#39;
    if not git_dir.exists():
        return True

    requires_clone = True
    with local.cwd(directory):
        repo_origin_url = git(&#39;config&#39;, &#39;--get&#39;, &#39;remote.origin.url&#39;)
        requires_clone = repo_origin_url.strip(&#39;\n&#39;) != repository

    if requires_clone:
        rm(&#39;-r&#39;, directory)
    return requires_clone


def Git(repository, directory, rev=None, prefix=None, shallow_clone=True):
    &#34;&#34;&#34;
    Get a clone of the given repo

    Args:
        repository (str): Git URL of the SOURCE repo.
        directory (str): Name of the repo folder on disk.
        rev (str): A revision to check out.
        prefix (str): TARGET folder for the git repo.
            Defaults to ``CFG[&#34;tmpdir&#34;]``
        shallow_clone (bool): Only clone the repository shallow
            Defaults to true
    &#34;&#34;&#34;
    repository_loc = str(prefix)
    if prefix is None:
        repository_loc = str(CFG[&#34;tmp_dir&#34;])

    src_dir = local.path(repository_loc) / directory
    tgt_dir = local.path(local.cwd) / directory
    lock_f = local.path(local.cwd / directory + &#39;.lock&#39;)

    extra_param = []
    if shallow_clone:
        extra_param.append(&#34;--depth&#34;)
        extra_param.append(&#34;1&#34;)

    from benchbuild.utils.cmd import git, mkdir
    if __clone_needed__(repository, src_dir):
        git(&#34;clone&#34;, extra_param, repository, src_dir)
    else:
        worktree_rev = rev if rev else &#39;HEAD&#39;
        with local.cwd(src_dir):
            mkdir(&#39;-p&#39;, tgt_dir)
            with flocked(lock_f):
                git(&#39;worktree&#39;, &#39;prune&#39;)
                git(&#39;worktree&#39;, &#39;add&#39;, &#39;--detach&#39;, tgt_dir, worktree_rev)

    return repository_loc


def with_git(repo,
             target_dir=None,
             limit=None,
             refspec=&#34;HEAD&#34;,
             clone=True,
             rev_list_args=None,
             shallow_clone=True,
             version_filter=lambda version: True):
    &#34;&#34;&#34;
    Decorate a project class with git-based version information.

    This adds two attributes to a project class:
        - A `versions` method that returns a list of available versions
          for this project.
        - A `repository` attribute that provides a repository string to
          download from later.
    We use the `git rev-list` subcommand to list available versions.

    Args:
        repo (str): Repository to download from, this will be stored
            in the `repository` attribute of the decorated class.
        target_dir (str): An optional path where we should put the clone.
            If unspecified, we will use the `SRC_FILE` attribute of
            the decorated class.
        limit (int): Limit the number of commits to consider for available
            versions. Versions are &#39;ordered&#39; from latest to oldest.
        refspec (str): A git refspec string to start listing the versions from.
        clone (bool): Should we clone the repo if it isn&#39;t already available
            in our tmp dir? Defaults to `True`. You can set this to False to
            avoid time consuming clones, when the project has not been accessed
            at least once in your installation.
        ref_list_args (list of str): Additional arguments you want to pass to
            `git rev-list`.
        shallow_clone (bool): Only clone the repository shallow
            Defaults to true
        version_filter (class filter): Filter function to remove unwanted
            project versions.

    &#34;&#34;&#34;
    if not rev_list_args:
        rev_list_args = []

    def git_decorator(cls):
        from benchbuild.utils.cmd import git

        @staticmethod
        def versions_impl():
            &#34;&#34;&#34;Return a list of versions from the git hashes up to :limit:.&#34;&#34;&#34;
            directory = cls.SRC_FILE if target_dir is None else target_dir
            repo_prefix = local.path(str(CFG[&#34;tmp_dir&#34;]))
            repo_loc = local.path(repo_prefix) / directory
            if __clone_needed__(repo, repo_loc):
                if not clone:
                    return []
                git(&#34;clone&#34;, repo, repo_loc)

            with local.cwd(repo_loc):
                rev_list = git(&#34;rev-list&#34;, &#34;--abbrev-commit&#34;, &#34;--abbrev=10&#34;,
                               refspec, *rev_list_args).strip().split(&#39;\n&#39;)
                latest = git(&#34;rev-parse&#34;, &#34;--short=10&#34;,
                             refspec).strip().split(&#39;\n&#39;)

            if limit:
                return list(filter(version_filter, rev_list))[:limit]

            return list(filter(version_filter, rev_list))

        def download_impl(self):
            &#34;&#34;&#34;Download the selected version.&#34;&#34;&#34;
            nonlocal target_dir, git
            directory = cls.SRC_FILE if target_dir is None else target_dir
            Git(self.repository,
                directory,
                self.version,
                shallow_clone=shallow_clone)

        cls.versions = versions_impl
        cls.download = download_impl
        cls.repository = repo
        return cls

    return git_decorator


def Svn(url, fname, to=None):
    &#34;&#34;&#34;
    Checkout the SVN repo.

    Args:
        url (str): The SVN SOURCE repo.
        fname (str): The name of the repo on disk.
        to (str): The name of the TARGET folder on disk.
            Defaults to ``CFG[&#34;tmpdir&#34;]``
    &#34;&#34;&#34;
    if to is None:
        to = str(CFG[&#34;tmp_dir&#34;])

    src_dir = local.path(to) / fname
    if not source_required(src_dir):
        Copy(src_dir, &#34;.&#34;)
        return

    from benchbuild.utils.cmd import svn
    svn(&#34;co&#34;, url, src_dir)
    update_hash(src_dir)
    Copy(src_dir, &#34;.&#34;)


def Rsync(url, tgt_name, tgt_root=None):
    &#34;&#34;&#34;
    RSync a folder.

    Args:
        url (str): The url of the SOURCE location.
        fname (str): The name of the TARGET.
        to (str): Path of the target location.
            Defaults to ``CFG[&#34;tmpdir&#34;]``.
    &#34;&#34;&#34;
    if tgt_root is None:
        tgt_root = str(CFG[&#34;tmp_dir&#34;])

    from benchbuild.utils.cmd import rsync

    tgt_dir = local.path(tgt_root) / tgt_name
    if not source_required(tgt_dir):
        Copy(tgt_dir, &#34;.&#34;)
        return

    rsync(&#34;-a&#34;, url, tgt_dir)
    update_hash(tgt_dir)
    Copy(tgt_dir, &#34;.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="benchbuild.utils.download.Copy"><code class="name flex">
<span>def <span class="ident">Copy</span></span>(<span>From, To)</span>
</code></dt>
<dd>
<section class="desc"><p>Small copy wrapper.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>From</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the SOURCE.</dd>
<dt><strong><code>To</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the TARGET.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Copy(From, To):
    &#34;&#34;&#34;
    Small copy wrapper.

    Args:
        From (str): Path to the SOURCE.
        To (str): Path to the TARGET.
    &#34;&#34;&#34;
    from benchbuild.utils.cmd import cp
    cp(&#34;-ar&#34;, &#34;--reflink=auto&#34;, From, To)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.download.CopyNoFail"><code class="name flex">
<span>def <span class="ident">CopyNoFail</span></span>(<span>src, root=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Just copy fName into the current working directory, if it exists.</p>
<p>No action is executed, if fName does not exist. No Hash is checked.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>src</code></strong></dt>
<dd>The filename we want to copy to '.'.</dd>
<dt><strong><code>root</code></strong></dt>
<dd>The optional source dir we should pull fName from. Defaults
to benchbuild.settings.CFG["tmpdir"].</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True, if we copied something.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CopyNoFail(src, root=None):
    &#34;&#34;&#34;
    Just copy fName into the current working directory, if it exists.

    No action is executed, if fName does not exist. No Hash is checked.

    Args:
        src: The filename we want to copy to &#39;.&#39;.
        root: The optional source dir we should pull fName from. Defaults
            to benchbuild.settings.CFG[&#34;tmpdir&#34;].

    Returns:
        True, if we copied something.
    &#34;&#34;&#34;
    if root is None:
        root = str(CFG[&#34;tmp_dir&#34;])
    src_path = local.path(root) / src

    if src_path.exists():
        Copy(src_path, &#39;.&#39;)
        return True
    return False</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.download.Git"><code class="name flex">
<span>def <span class="ident">Git</span></span>(<span>repository, directory, rev=None, prefix=None, shallow_clone=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a clone of the given repo</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>repository</code></strong> :&ensp;<code>str</code></dt>
<dd>Git URL of the SOURCE repo.</dd>
<dt><strong><code>directory</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the repo folder on disk.</dd>
<dt><strong><code>rev</code></strong> :&ensp;<code>str</code></dt>
<dd>A revision to check out.</dd>
<dt><strong><code>prefix</code></strong> :&ensp;<code>str</code></dt>
<dd>TARGET folder for the git repo.
Defaults to <code>CFG["tmpdir"]</code></dd>
<dt><strong><code>shallow_clone</code></strong> :&ensp;<code>bool</code></dt>
<dd>Only clone the repository shallow
Defaults to true</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Git(repository, directory, rev=None, prefix=None, shallow_clone=True):
    &#34;&#34;&#34;
    Get a clone of the given repo

    Args:
        repository (str): Git URL of the SOURCE repo.
        directory (str): Name of the repo folder on disk.
        rev (str): A revision to check out.
        prefix (str): TARGET folder for the git repo.
            Defaults to ``CFG[&#34;tmpdir&#34;]``
        shallow_clone (bool): Only clone the repository shallow
            Defaults to true
    &#34;&#34;&#34;
    repository_loc = str(prefix)
    if prefix is None:
        repository_loc = str(CFG[&#34;tmp_dir&#34;])

    src_dir = local.path(repository_loc) / directory
    tgt_dir = local.path(local.cwd) / directory
    lock_f = local.path(local.cwd / directory + &#39;.lock&#39;)

    extra_param = []
    if shallow_clone:
        extra_param.append(&#34;--depth&#34;)
        extra_param.append(&#34;1&#34;)

    from benchbuild.utils.cmd import git, mkdir
    if __clone_needed__(repository, src_dir):
        git(&#34;clone&#34;, extra_param, repository, src_dir)
    else:
        worktree_rev = rev if rev else &#39;HEAD&#39;
        with local.cwd(src_dir):
            mkdir(&#39;-p&#39;, tgt_dir)
            with flocked(lock_f):
                git(&#39;worktree&#39;, &#39;prune&#39;)
                git(&#39;worktree&#39;, &#39;add&#39;, &#39;--detach&#39;, tgt_dir, worktree_rev)

    return repository_loc</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.download.Rsync"><code class="name flex">
<span>def <span class="ident">Rsync</span></span>(<span>url, tgt_name, tgt_root=None)</span>
</code></dt>
<dd>
<section class="desc"><p>RSync a folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>The url of the SOURCE location.</dd>
<dt><strong><code>fname</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the TARGET.</dd>
<dt><strong><code>to</code></strong> :&ensp;<code>str</code></dt>
<dd>Path of the target location.
Defaults to <code>CFG["tmpdir"]</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Rsync(url, tgt_name, tgt_root=None):
    &#34;&#34;&#34;
    RSync a folder.

    Args:
        url (str): The url of the SOURCE location.
        fname (str): The name of the TARGET.
        to (str): Path of the target location.
            Defaults to ``CFG[&#34;tmpdir&#34;]``.
    &#34;&#34;&#34;
    if tgt_root is None:
        tgt_root = str(CFG[&#34;tmp_dir&#34;])

    from benchbuild.utils.cmd import rsync

    tgt_dir = local.path(tgt_root) / tgt_name
    if not source_required(tgt_dir):
        Copy(tgt_dir, &#34;.&#34;)
        return

    rsync(&#34;-a&#34;, url, tgt_dir)
    update_hash(tgt_dir)
    Copy(tgt_dir, &#34;.&#34;)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.download.Svn"><code class="name flex">
<span>def <span class="ident">Svn</span></span>(<span>url, fname, to=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Checkout the SVN repo.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>The SVN SOURCE repo.</dd>
<dt><strong><code>fname</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the repo on disk.</dd>
<dt><strong><code>to</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the TARGET folder on disk.
Defaults to <code>CFG["tmpdir"]</code></dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Svn(url, fname, to=None):
    &#34;&#34;&#34;
    Checkout the SVN repo.

    Args:
        url (str): The SVN SOURCE repo.
        fname (str): The name of the repo on disk.
        to (str): The name of the TARGET folder on disk.
            Defaults to ``CFG[&#34;tmpdir&#34;]``
    &#34;&#34;&#34;
    if to is None:
        to = str(CFG[&#34;tmp_dir&#34;])

    src_dir = local.path(to) / fname
    if not source_required(src_dir):
        Copy(src_dir, &#34;.&#34;)
        return

    from benchbuild.utils.cmd import svn
    svn(&#34;co&#34;, url, src_dir)
    update_hash(src_dir)
    Copy(src_dir, &#34;.&#34;)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.download.Wget"><code class="name flex">
<span>def <span class="ident">Wget</span></span>(<span>src_url, tgt_name, tgt_root=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Download url, if required.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>src_url</code></strong> :&ensp;<code>str</code></dt>
<dd>Our SOURCE url.</dd>
<dt><strong><code>tgt_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The filename we want to have on disk.</dd>
<dt><strong><code>tgt_root</code></strong> :&ensp;<code>str</code></dt>
<dd>The TARGET directory for the download.
Defaults to <code>CFG["tmpdir"]</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Wget(src_url, tgt_name, tgt_root=None):
    &#34;&#34;&#34;
    Download url, if required.

    Args:
        src_url (str): Our SOURCE url.
        tgt_name (str): The filename we want to have on disk.
        tgt_root (str): The TARGET directory for the download.
            Defaults to ``CFG[&#34;tmpdir&#34;]``.
    &#34;&#34;&#34;
    if tgt_root is None:
        tgt_root = str(CFG[&#34;tmp_dir&#34;])

    from benchbuild.utils.cmd import wget

    tgt_file = local.path(tgt_root) / tgt_name
    if not source_required(tgt_file):
        Copy(tgt_file, &#34;.&#34;)
        return

    wget(src_url, &#34;-O&#34;, tgt_file)
    update_hash(tgt_file)
    Copy(tgt_file, &#34;.&#34;)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.download.get_hash_of_dirs"><code class="name flex">
<span>def <span class="ident">get_hash_of_dirs</span></span>(<span>directory)</span>
</code></dt>
<dd>
<section class="desc"><p>Recursively hash the contents of the given directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>str</code></dt>
<dd>The root directory we want to hash.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A hash of all the contents in the directory.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hash_of_dirs(directory):
    &#34;&#34;&#34;
    Recursively hash the contents of the given directory.

    Args:
        directory (str): The root directory we want to hash.

    Returns:
        A hash of all the contents in the directory.
    &#34;&#34;&#34;
    import hashlib
    sha = hashlib.sha512()
    if not os.path.exists(directory):
        return -1

    for root, _, files in os.walk(directory):
        for name in files:
            filepath = local.path(root) / name
            if filepath.exists():
                with open(filepath, &#39;rb&#39;) as next_file:
                    for line in next_file:
                        sha.update(line)
    return sha.hexdigest()</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.download.source_required"><code class="name flex">
<span>def <span class="ident">source_required</span></span>(<span>src_file)</span>
</code></dt>
<dd>
<section class="desc"><p>Check, if a download is required.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>src_file</code></strong></dt>
<dd>The filename to check for.</dd>
<dt><strong><code>src_root</code></strong></dt>
<dd>The path we find the file in.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True, if we need to download something, False otherwise.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def source_required(src_file):
    &#34;&#34;&#34;
    Check, if a download is required.

    Args:
        src_file: The filename to check for.
        src_root: The path we find the file in.

    Returns:
        True, if we need to download something, False otherwise.
    &#34;&#34;&#34;
    if not src_file.exists():
        return True

    required = True
    hash_file = src_file.with_suffix(&#34;.hash&#34;, depth=0)
    LOG.debug(&#34;Hash file location: %s&#34;, hash_file)
    if hash_file.exists():
        new_hash = get_hash_of_dirs(src_file)
        with open(hash_file, &#39;r&#39;) as h_file:
            old_hash = h_file.readline()
        required = not new_hash == old_hash
        if required:
            from benchbuild.utils.cmd import rm
            rm(&#34;-r&#34;, src_file)
            rm(hash_file)
    if required:
        LOG.info(&#34;Source required for: %s&#34;, src_file)
        LOG.debug(&#34;Reason: src-exists: %s hash-exists: %s&#34;, src_file.exists(),
                  hash_file.exists())
    return required</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.download.update_hash"><code class="name flex">
<span>def <span class="ident">update_hash</span></span>(<span>src_file)</span>
</code></dt>
<dd>
<section class="desc"><p>Update the hash for the given file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>src</code></strong></dt>
<dd>The file name.</dd>
<dt><strong><code>root</code></strong></dt>
<dd>The path of the given file.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_hash(src_file):
    &#34;&#34;&#34;
    Update the hash for the given file.

    Args:
        src: The file name.
        root: The path of the given file.
    &#34;&#34;&#34;
    hash_file = local.path(src_file) + &#34;.hash&#34;
    new_hash = 0
    with open(hash_file, &#39;w&#39;) as h_file:
        new_hash = get_hash_of_dirs(src_file)
        h_file.write(str(new_hash))
    return new_hash</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.download.with_git"><code class="name flex">
<span>def <span class="ident">with_git</span></span>(<span>repo, target_dir=None, limit=None, refspec='HEAD', clone=True, rev_list_args=None, shallow_clone=True, version_filter=&lt;function &lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<section class="desc"><p>Decorate a project class with git-based version information.</p>
<p>This adds two attributes to a project class:
- A <code>versions</code> method that returns a list of available versions
for this project.
- A <code>repository</code> attribute that provides a repository string to
download from later.
We use the <code>git rev-list</code> subcommand to list available versions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>repo</code></strong> :&ensp;<code>str</code></dt>
<dd>Repository to download from, this will be stored
in the <code>repository</code> attribute of the decorated class.</dd>
<dt><strong><code>target_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>An optional path where we should put the clone.
If unspecified, we will use the <code>SRC_FILE</code> attribute of
the decorated class.</dd>
<dt><strong><code>limit</code></strong> :&ensp;<code>int</code></dt>
<dd>Limit the number of commits to consider for available
versions. Versions are 'ordered' from latest to oldest.</dd>
<dt><strong><code>refspec</code></strong> :&ensp;<code>str</code></dt>
<dd>A git refspec string to start listing the versions from.</dd>
<dt><strong><code>clone</code></strong> :&ensp;<code>bool</code></dt>
<dd>Should we clone the repo if it isn't already available
in our tmp dir? Defaults to <code>True</code>. You can set this to False to
avoid time consuming clones, when the project has not been accessed
at least once in your installation.</dd>
<dt><strong><code>ref_list_args</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Additional arguments you want to pass to
<code>git rev-list</code>.</dd>
<dt><strong><code>shallow_clone</code></strong> :&ensp;<code>bool</code></dt>
<dd>Only clone the repository shallow
Defaults to true</dd>
<dt><strong><code>version_filter</code></strong> :&ensp;<code>class</code> <code>filter</code></dt>
<dd>Filter function to remove unwanted
project versions.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_git(repo,
             target_dir=None,
             limit=None,
             refspec=&#34;HEAD&#34;,
             clone=True,
             rev_list_args=None,
             shallow_clone=True,
             version_filter=lambda version: True):
    &#34;&#34;&#34;
    Decorate a project class with git-based version information.

    This adds two attributes to a project class:
        - A `versions` method that returns a list of available versions
          for this project.
        - A `repository` attribute that provides a repository string to
          download from later.
    We use the `git rev-list` subcommand to list available versions.

    Args:
        repo (str): Repository to download from, this will be stored
            in the `repository` attribute of the decorated class.
        target_dir (str): An optional path where we should put the clone.
            If unspecified, we will use the `SRC_FILE` attribute of
            the decorated class.
        limit (int): Limit the number of commits to consider for available
            versions. Versions are &#39;ordered&#39; from latest to oldest.
        refspec (str): A git refspec string to start listing the versions from.
        clone (bool): Should we clone the repo if it isn&#39;t already available
            in our tmp dir? Defaults to `True`. You can set this to False to
            avoid time consuming clones, when the project has not been accessed
            at least once in your installation.
        ref_list_args (list of str): Additional arguments you want to pass to
            `git rev-list`.
        shallow_clone (bool): Only clone the repository shallow
            Defaults to true
        version_filter (class filter): Filter function to remove unwanted
            project versions.

    &#34;&#34;&#34;
    if not rev_list_args:
        rev_list_args = []

    def git_decorator(cls):
        from benchbuild.utils.cmd import git

        @staticmethod
        def versions_impl():
            &#34;&#34;&#34;Return a list of versions from the git hashes up to :limit:.&#34;&#34;&#34;
            directory = cls.SRC_FILE if target_dir is None else target_dir
            repo_prefix = local.path(str(CFG[&#34;tmp_dir&#34;]))
            repo_loc = local.path(repo_prefix) / directory
            if __clone_needed__(repo, repo_loc):
                if not clone:
                    return []
                git(&#34;clone&#34;, repo, repo_loc)

            with local.cwd(repo_loc):
                rev_list = git(&#34;rev-list&#34;, &#34;--abbrev-commit&#34;, &#34;--abbrev=10&#34;,
                               refspec, *rev_list_args).strip().split(&#39;\n&#39;)
                latest = git(&#34;rev-parse&#34;, &#34;--short=10&#34;,
                             refspec).strip().split(&#39;\n&#39;)

            if limit:
                return list(filter(version_filter, rev_list))[:limit]

            return list(filter(version_filter, rev_list))

        def download_impl(self):
            &#34;&#34;&#34;Download the selected version.&#34;&#34;&#34;
            nonlocal target_dir, git
            directory = cls.SRC_FILE if target_dir is None else target_dir
            Git(self.repository,
                directory,
                self.version,
                shallow_clone=shallow_clone)

        cls.versions = versions_impl
        cls.download = download_impl
        cls.repository = repo
        return cls

    return git_decorator</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.download.with_wget"><code class="name flex">
<span>def <span class="ident">with_wget</span></span>(<span>url_dict=None, target_file=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Decorate a project class with wget-based version information.</p>
<p>This adds two attributes to a project class:
- A <code>versions</code> method that returns a list of available versions
for this project.
- A <code>repository</code> attribute that provides a repository string to
download from later.
We use the <code>git rev-list</code> subcommand to list available versions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary that assigns a version to a download URL.</dd>
<dt><strong><code>target_file</code></strong> :&ensp;<code>str</code></dt>
<dd>An optional path where we should put the clone.
If unspecified, we will use the <code>SRC_FILE</code> attribute of
the decorated class.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_wget(url_dict=None, target_file=None):
    &#34;&#34;&#34;
    Decorate a project class with wget-based version information.

    This adds two attributes to a project class:
        - A `versions` method that returns a list of available versions
          for this project.
        - A `repository` attribute that provides a repository string to
          download from later.
    We use the `git rev-list` subcommand to list available versions.

    Args:
        url_dict (dict): A dictionary that assigns a version to a download URL.
        target_file (str): An optional path where we should put the clone.
            If unspecified, we will use the `SRC_FILE` attribute of
            the decorated class.
    &#34;&#34;&#34;

    def wget_decorator(cls):
        def download_impl(self):
            &#34;&#34;&#34;Download the selected version from the url_dict value.&#34;&#34;&#34;
            t_file = target_file if target_file else self.SRC_FILE
            t_version = url_dict[self.version]
            Wget(t_version, t_file)

        @staticmethod
        def versions_impl():
            &#34;&#34;&#34;Return a list of versions from the url_dict keys.&#34;&#34;&#34;
            return list(url_dict.keys())

        cls.versions = versions_impl
        cls.download = download_impl
        return cls

    return wget_decorator</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#downloading-helper-functions-for-benchbuild">Downloading helper functions for benchbuild.</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="benchbuild.utils" href="index.html">benchbuild.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="benchbuild.utils.download.Copy" href="#benchbuild.utils.download.Copy">Copy</a></code></li>
<li><code><a title="benchbuild.utils.download.CopyNoFail" href="#benchbuild.utils.download.CopyNoFail">CopyNoFail</a></code></li>
<li><code><a title="benchbuild.utils.download.Git" href="#benchbuild.utils.download.Git">Git</a></code></li>
<li><code><a title="benchbuild.utils.download.Rsync" href="#benchbuild.utils.download.Rsync">Rsync</a></code></li>
<li><code><a title="benchbuild.utils.download.Svn" href="#benchbuild.utils.download.Svn">Svn</a></code></li>
<li><code><a title="benchbuild.utils.download.Wget" href="#benchbuild.utils.download.Wget">Wget</a></code></li>
<li><code><a title="benchbuild.utils.download.get_hash_of_dirs" href="#benchbuild.utils.download.get_hash_of_dirs">get_hash_of_dirs</a></code></li>
<li><code><a title="benchbuild.utils.download.source_required" href="#benchbuild.utils.download.source_required">source_required</a></code></li>
<li><code><a title="benchbuild.utils.download.update_hash" href="#benchbuild.utils.download.update_hash">update_hash</a></code></li>
<li><code><a title="benchbuild.utils.download.with_git" href="#benchbuild.utils.download.with_git">with_git</a></code></li>
<li><code><a title="benchbuild.utils.download.with_wget" href="#benchbuild.utils.download.with_wget">with_wget</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
