<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>benchbuild.utils.run API documentation</title>
<meta name="description" content="Experiment helpers." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>benchbuild.utils.run</code></h1>
</header>
<section id="section-intro">
<p>Experiment helpers.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Experiment helpers.&#34;&#34;&#34;
import logging
import sys
import typing as t
from contextlib import contextmanager

from plumbum import TEE, local
from plumbum.commands import ProcessExecutionError

import attr
from benchbuild import settings, signals

CFG = settings.CFG
LOG = logging.getLogger(__name__)


@attr.s()
class RunInfo:
    &#34;&#34;&#34;
    Execution context of wrapped binaries.

    Execution of tracked binaries is guarded with this context
    object. In here we store everything about a single binary
    execution for consumption of an experiment.

    Attributes:
        cmd ():
        failed ():
        project ():
        experiment ():
        retcode ():
        stdout ():
        stderr ():
        db_run ():
        session ():
    &#34;&#34;&#34;
    def __begin(self, command, project, ename, group):
        &#34;&#34;&#34;
        Begin a run in the database log.

        Args:
            command: The command that will be executed.
            pname: The project name we belong to.
            ename: The experiment name we belong to.
            group: The run group we belong to.

        Returns:
            (run, session), where run is the generated run instance and
            session the associated transaction for later use.
        &#34;&#34;&#34;
        from benchbuild.utils.db import create_run
        from benchbuild.utils import schema as s
        from datetime import datetime

        db_run, session = create_run(command, project, ename, group)
        db_run.begin = datetime.now()
        db_run.status = &#39;running&#39;
        log = s.RunLog()
        log.run_id = db_run.id
        log.begin = datetime.now()
        log.config = repr(CFG)
        session.add(log)
        session.add(db_run)

        self.db_run = db_run
        self.session = session

    def __end(self, stdout, stderr):
        &#34;&#34;&#34;
        End a run in the database log (Successfully).

        This will persist the log information in the database and commit the
        transaction.

        Args:
            db_run: The ``run`` schema object we belong to
            session: The db transaction we belong to.
            stdout: The stdout we captured of the run.
            stderr: The stderr we capture of the run.
        &#34;&#34;&#34;
        from benchbuild.utils.schema import RunLog
        from datetime import datetime

        run_id = self.db_run.id

        log = self.session.query(RunLog).filter(RunLog.run_id == run_id).one()
        log.stderr = stderr
        log.stdout = stdout
        log.status = 0
        log.end = datetime.now()

        self.db_run.end = datetime.now()
        self.db_run.status = &#39;completed&#39;
        self.session.add(log)
        self.session.add(self.db_run)

    def __fail(self, retcode, stdout, stderr):
        &#34;&#34;&#34;
        End a run in the database log (Unsuccessfully).

        This will persist the log information in the database and commit the
        transaction.

        Args:
            db_run: The ``run`` schema object we belong to
            session: The db transaction we belong to.
            retcode: The return code we captured of the run.
            stdout: The stdout we captured of the run.
            stderr: The stderr we capture of the run.
        &#34;&#34;&#34;
        from benchbuild.utils.schema import RunLog
        from datetime import datetime
        run_id = self.db_run.id

        log = self.session.query(RunLog).filter(RunLog.run_id == run_id).one()
        log.stderr = stderr
        log.stdout = stdout
        log.status = retcode
        log.end = datetime.now()

        self.db_run.end = datetime.now()
        self.db_run.status = &#39;failed&#39;
        self.failed = True
        self.session.add(log)
        self.session.add(self.db_run)

    cmd = attr.ib(default=None, repr=False)
    failed = attr.ib(default=False)
    project = attr.ib(default=None, repr=False)
    experiment = attr.ib(default=None, repr=False)
    retcode = attr.ib(default=0)
    stdout = attr.ib(default=attr.Factory(list), repr=False)
    stderr = attr.ib(default=attr.Factory(list), repr=False)

    db_run = attr.ib(init=False, default=None)
    session = attr.ib(init=False, default=None, repr=False)
    payload = attr.ib(init=False, default=None, repr=False)

    def __attrs_post_init__(self):
        self.__begin(self.cmd, self.project, self.experiment.name,
                     self.project.run_uuid)
        signals.handlers.register(self.__fail, 15, &#34;SIGTERM&#34;, &#34;SIGTERM&#34;)

        run_id = self.db_run.id
        settings.CFG[&#34;db&#34;][&#34;run_id&#34;] = run_id

    def add_payload(self, name, payload):
        if self == payload:
            return
        if not self.payload:
            self.payload = {name: payload}
        else:
            self.payload.update({name: payload})

    @property
    def has_failed(self):
        &#34;&#34;&#34;Check, whether this run failed.&#34;&#34;&#34;
        return self.failed

    def __call__(self, *args, expected_retcode=0, ri=None, **kwargs):
        cmd_env = settings.CFG.to_env_dict()

        with local.env(**cmd_env):
            try:
                bin_name = sys.argv[0]
                retcode, stdout, stderr = \
                    self.cmd &amp; TEE(retcode=expected_retcode)
                f_stdout = bin_name + &#34;.stdout&#34;
                f_stderr = bin_name + &#34;.stderr&#34;
                with open(f_stdout, &#39;w&#39;) as fd_stdout:
                    fd_stdout.write(stdout)

                with open(f_stderr, &#39;w&#39;) as fd_stderr:
                    fd_stderr.write(stderr)

                self.retcode = retcode
                self.stdout = stdout
                self.stderr = stderr
                self.__end(str(stdout), str(stderr))
            except ProcessExecutionError as ex:
                self.__fail(ex.retcode, ex.stderr, ex.stdout)
                self.retcode = ex.retcode
                self.stdout = ex.stdout
                self.stderr = ex.stderr

                LOG.debug(&#34;Tracked process failed&#34;)
                LOG.error(str(ex))
            except KeyboardInterrupt:
                self.retcode = retcode
                self.stdout = stdout
                self.stderr = stderr
                self.__fail(-1, &#34;&#34;, &#34;KeyboardInterrupt&#34;)
                LOG.warning(&#34;Interrupted by user input&#34;)
                raise
            finally:
                signals.handlers.deregister(self.__fail)

        return self

    def commit(self):
        self.session.commit()


def begin_run_group(project):
    &#34;&#34;&#34;
    Begin a run_group in the database.

    A run_group groups a set of runs for a given project. This models a series
    of runs that form a complete binary runtime test.

    Args:
        project: The project we begin a new run_group for.

    Returns:
        ``(group, session)`` where group is the created group in the
        database and session is the database session this group lives in.
    &#34;&#34;&#34;
    from benchbuild.utils.db import create_run_group
    from datetime import datetime

    group, session = create_run_group(project)
    group.begin = datetime.now()
    group.status = &#39;running&#39;

    session.commit()
    return group, session


def end_run_group(group, session):
    &#34;&#34;&#34;
    End the run_group successfully.

    Args:
        group: The run_group we want to complete.
        session: The database transaction we will finish.
    &#34;&#34;&#34;
    from datetime import datetime

    group.end = datetime.now()
    group.status = &#39;completed&#39;
    session.commit()


def fail_run_group(group, session):
    &#34;&#34;&#34;
    End the run_group unsuccessfully.

    Args:
        group: The run_group we want to complete.
        session: The database transaction we will finish.
    &#34;&#34;&#34;
    from datetime import datetime

    group.end = datetime.now()
    group.status = &#39;failed&#39;
    session.commit()


def exit_code_from_run_infos(run_infos: t.List[RunInfo]) -&gt; int:
    &#34;&#34;&#34;Generate a single exit code from a list of RunInfo objects.

    Takes a list of RunInfos and returns the exit code that is furthest away
    from 0.

    Args:
        run_infos (t.List[RunInfo]): [description]

    Returns:
        int: [description]
    &#34;&#34;&#34;
    assert run_infos is not None

    if not hasattr(run_infos, &#34;__iter__&#34;):
        return run_infos.retcode

    rcs = [ri.retcode for ri in run_infos]
    max_rc = max(rcs)
    min_rc = min(rcs)
    if max_rc == 0:
        return min_rc
    return max_rc


@contextmanager
def track_execution(cmd, project, experiment, **kwargs):
    &#34;&#34;&#34;Guard the execution of the given command.

    The given command (`cmd`) will be executed inside a database context.
    As soon as you leave the context we will commit the transaction.
    Any necessary modifications to the database can be identified inside
    the context with the RunInfo object.

    Args:
        cmd: The command we guard.
        project: The project we track for.
        experiment: The experiment we track for.

    Yields:
        RunInfo: A context object that carries the necessary
            database transaction.
    &#34;&#34;&#34;

    runner = RunInfo(cmd=cmd, project=project, experiment=experiment, **kwargs)
    yield runner
    runner.commit()


def watch(command):
    &#34;&#34;&#34;Execute a plumbum command, depending on the user&#39;s settings.

    Args:
        command: The plumbumb command to execute.
    &#34;&#34;&#34;
    def f(*args, retcode=0):
        final_command = command[args]
        return final_command &amp; TEE(retcode=retcode)

    return f


def with_env_recursive(cmd, **envvars):
    &#34;&#34;&#34;
    Recursively updates the environment of cmd and all its subcommands.

    Args:
        cmd - A plumbum command-like object
        **envvars - The environment variables to update

    Returns:
        The updated command.
    &#34;&#34;&#34;
    from plumbum.commands.base import BoundCommand, BoundEnvCommand
    if isinstance(cmd, BoundCommand):
        cmd.cmd = with_env_recursive(cmd.cmd, **envvars)
    elif isinstance(cmd, BoundEnvCommand):
        cmd.envvars.update(envvars)
        cmd.cmd = with_env_recursive(cmd.cmd, **envvars)
    return cmd


def in_builddir(sub=&#39;.&#39;):
    &#34;&#34;&#34;
    Decorate a project phase with a local working directory change.

    Args:
        sub: An optional subdirectory to change into.
    &#34;&#34;&#34;
    from functools import wraps

    def wrap_in_builddir(func):
        &#34;&#34;&#34;Wrap the function for the new build directory.&#34;&#34;&#34;
        @wraps(func)
        def wrap_in_builddir_func(self, *args, **kwargs):
            &#34;&#34;&#34;The actual function inside the wrapper for the new builddir.&#34;&#34;&#34;
            p = local.path(self.builddir) / sub
            if not p.exists():
                LOG.error(&#34;%s does not exist.&#34;, p)

            if p == local.cwd:
                LOG.debug(&#34;CWD already is %s&#34;, p)
                return func(self, *args, *kwargs)
            with local.cwd(p):
                return func(self, *args, **kwargs)

        return wrap_in_builddir_func

    return wrap_in_builddir


def store_config(func):
    &#34;&#34;&#34;Decorator for storing the configuration in the project&#39;s builddir.&#34;&#34;&#34;
    from functools import wraps

    @wraps(func)
    def wrap_store_config(self, *args, **kwargs):
        &#34;&#34;&#34;Wrapper that contains the actual storage call for the config.&#34;&#34;&#34;
        CFG.store(local.path(self.builddir) / &#34;.benchbuild.yml&#34;)
        return func(self, *args, **kwargs)

    return wrap_store_config</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="benchbuild.utils.run.begin_run_group"><code class="name flex">
<span>def <span class="ident">begin_run_group</span></span>(<span>project)</span>
</code></dt>
<dd>
<section class="desc"><p>Begin a run_group in the database.</p>
<p>A run_group groups a set of runs for a given project. This models a series
of runs that form a complete binary runtime test.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>project</code></strong></dt>
<dd>The project we begin a new run_group for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>(group, session)</code> where group is the created group in the
database and session is the database session this group lives in.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def begin_run_group(project):
    &#34;&#34;&#34;
    Begin a run_group in the database.

    A run_group groups a set of runs for a given project. This models a series
    of runs that form a complete binary runtime test.

    Args:
        project: The project we begin a new run_group for.

    Returns:
        ``(group, session)`` where group is the created group in the
        database and session is the database session this group lives in.
    &#34;&#34;&#34;
    from benchbuild.utils.db import create_run_group
    from datetime import datetime

    group, session = create_run_group(project)
    group.begin = datetime.now()
    group.status = &#39;running&#39;

    session.commit()
    return group, session</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.run.end_run_group"><code class="name flex">
<span>def <span class="ident">end_run_group</span></span>(<span>group, session)</span>
</code></dt>
<dd>
<section class="desc"><p>End the run_group successfully.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>group</code></strong></dt>
<dd>The run_group we want to complete.</dd>
<dt><strong><code>session</code></strong></dt>
<dd>The database transaction we will finish.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_run_group(group, session):
    &#34;&#34;&#34;
    End the run_group successfully.

    Args:
        group: The run_group we want to complete.
        session: The database transaction we will finish.
    &#34;&#34;&#34;
    from datetime import datetime

    group.end = datetime.now()
    group.status = &#39;completed&#39;
    session.commit()</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.run.exit_code_from_run_infos"><code class="name flex">
<span>def <span class="ident">exit_code_from_run_infos</span></span>(<span>run_infos: List[<a title="benchbuild.utils.run.RunInfo" href="#benchbuild.utils.run.RunInfo">RunInfo</a>]) -> int</span>
</code></dt>
<dd>
<section class="desc"><p>Generate a single exit code from a list of RunInfo objects.</p>
<p>Takes a list of RunInfos and returns the exit code that is furthest away
from 0.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>run_infos</code></strong> :&ensp;<code>t.List</code>[<code>RunInfo</code>]</dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>int</code></strong></dt>
<dd>[description]</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_code_from_run_infos(run_infos: t.List[RunInfo]) -&gt; int:
    &#34;&#34;&#34;Generate a single exit code from a list of RunInfo objects.

    Takes a list of RunInfos and returns the exit code that is furthest away
    from 0.

    Args:
        run_infos (t.List[RunInfo]): [description]

    Returns:
        int: [description]
    &#34;&#34;&#34;
    assert run_infos is not None

    if not hasattr(run_infos, &#34;__iter__&#34;):
        return run_infos.retcode

    rcs = [ri.retcode for ri in run_infos]
    max_rc = max(rcs)
    min_rc = min(rcs)
    if max_rc == 0:
        return min_rc
    return max_rc</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.run.fail_run_group"><code class="name flex">
<span>def <span class="ident">fail_run_group</span></span>(<span>group, session)</span>
</code></dt>
<dd>
<section class="desc"><p>End the run_group unsuccessfully.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>group</code></strong></dt>
<dd>The run_group we want to complete.</dd>
<dt><strong><code>session</code></strong></dt>
<dd>The database transaction we will finish.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fail_run_group(group, session):
    &#34;&#34;&#34;
    End the run_group unsuccessfully.

    Args:
        group: The run_group we want to complete.
        session: The database transaction we will finish.
    &#34;&#34;&#34;
    from datetime import datetime

    group.end = datetime.now()
    group.status = &#39;failed&#39;
    session.commit()</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.run.in_builddir"><code class="name flex">
<span>def <span class="ident">in_builddir</span></span>(<span>sub='.')</span>
</code></dt>
<dd>
<section class="desc"><p>Decorate a project phase with a local working directory change.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sub</code></strong></dt>
<dd>An optional subdirectory to change into.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_builddir(sub=&#39;.&#39;):
    &#34;&#34;&#34;
    Decorate a project phase with a local working directory change.

    Args:
        sub: An optional subdirectory to change into.
    &#34;&#34;&#34;
    from functools import wraps

    def wrap_in_builddir(func):
        &#34;&#34;&#34;Wrap the function for the new build directory.&#34;&#34;&#34;
        @wraps(func)
        def wrap_in_builddir_func(self, *args, **kwargs):
            &#34;&#34;&#34;The actual function inside the wrapper for the new builddir.&#34;&#34;&#34;
            p = local.path(self.builddir) / sub
            if not p.exists():
                LOG.error(&#34;%s does not exist.&#34;, p)

            if p == local.cwd:
                LOG.debug(&#34;CWD already is %s&#34;, p)
                return func(self, *args, *kwargs)
            with local.cwd(p):
                return func(self, *args, **kwargs)

        return wrap_in_builddir_func

    return wrap_in_builddir</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.run.store_config"><code class="name flex">
<span>def <span class="ident">store_config</span></span>(<span>func)</span>
</code></dt>
<dd>
<section class="desc"><p>Decorator for storing the configuration in the project's builddir.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_config(func):
    &#34;&#34;&#34;Decorator for storing the configuration in the project&#39;s builddir.&#34;&#34;&#34;
    from functools import wraps

    @wraps(func)
    def wrap_store_config(self, *args, **kwargs):
        &#34;&#34;&#34;Wrapper that contains the actual storage call for the config.&#34;&#34;&#34;
        CFG.store(local.path(self.builddir) / &#34;.benchbuild.yml&#34;)
        return func(self, *args, **kwargs)

    return wrap_store_config</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.run.track_execution"><code class="name flex">
<span>def <span class="ident">track_execution</span></span>(<span>cmd, project, experiment, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Guard the execution of the given command.</p>
<p>The given command (<code>cmd</code>) will be executed inside a database context.
As soon as you leave the context we will commit the transaction.
Any necessary modifications to the database can be identified inside
the context with the RunInfo object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cmd</code></strong></dt>
<dd>The command we guard.</dd>
<dt><strong><code>project</code></strong></dt>
<dd>The project we track for.</dd>
<dt><strong><code>experiment</code></strong></dt>
<dd>The experiment we track for.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><strong><a title="benchbuild.utils.run.RunInfo" href="#benchbuild.utils.run.RunInfo"><code>RunInfo</code></a></strong></dt>
<dd>A context object that carries the necessary
database transaction.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def track_execution(cmd, project, experiment, **kwargs):
    &#34;&#34;&#34;Guard the execution of the given command.

    The given command (`cmd`) will be executed inside a database context.
    As soon as you leave the context we will commit the transaction.
    Any necessary modifications to the database can be identified inside
    the context with the RunInfo object.

    Args:
        cmd: The command we guard.
        project: The project we track for.
        experiment: The experiment we track for.

    Yields:
        RunInfo: A context object that carries the necessary
            database transaction.
    &#34;&#34;&#34;

    runner = RunInfo(cmd=cmd, project=project, experiment=experiment, **kwargs)
    yield runner
    runner.commit()</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.run.watch"><code class="name flex">
<span>def <span class="ident">watch</span></span>(<span>command)</span>
</code></dt>
<dd>
<section class="desc"><p>Execute a plumbum command, depending on the user's settings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>command</code></strong></dt>
<dd>The plumbumb command to execute.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watch(command):
    &#34;&#34;&#34;Execute a plumbum command, depending on the user&#39;s settings.

    Args:
        command: The plumbumb command to execute.
    &#34;&#34;&#34;
    def f(*args, retcode=0):
        final_command = command[args]
        return final_command &amp; TEE(retcode=retcode)

    return f</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.run.with_env_recursive"><code class="name flex">
<span>def <span class="ident">with_env_recursive</span></span>(<span>cmd, **envvars)</span>
</code></dt>
<dd>
<section class="desc"><p>Recursively updates the environment of cmd and all its subcommands.</p>
<h2 id="args">Args</h2>
<p>cmd - A plumbum command-like object
**envvars - The environment variables to update</p>
<h2 id="returns">Returns</h2>
<p>The updated command.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_env_recursive(cmd, **envvars):
    &#34;&#34;&#34;
    Recursively updates the environment of cmd and all its subcommands.

    Args:
        cmd - A plumbum command-like object
        **envvars - The environment variables to update

    Returns:
        The updated command.
    &#34;&#34;&#34;
    from plumbum.commands.base import BoundCommand, BoundEnvCommand
    if isinstance(cmd, BoundCommand):
        cmd.cmd = with_env_recursive(cmd.cmd, **envvars)
    elif isinstance(cmd, BoundEnvCommand):
        cmd.envvars.update(envvars)
        cmd.cmd = with_env_recursive(cmd.cmd, **envvars)
    return cmd</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="benchbuild.utils.run.RunInfo"><code class="flex name class">
<span>class <span class="ident">RunInfo</span></span>
<span>(</span><span>cmd=None, failed=False, project=None, experiment=None, retcode=0, stdout=NOTHING, stderr=NOTHING)</span>
</code></dt>
<dd>
<section class="desc"><p>Execution context of wrapped binaries.</p>
<p>Execution of tracked binaries is guarded with this context
object. In here we store everything about a single binary
execution for consumption of an experiment.</p>
<h2 id="attributes">Attributes</h2>
<p>cmd ():
failed ():
project ():
experiment ():
retcode ():
stdout ():
stderr ():
db_run ():
session ():</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RunInfo:
    &#34;&#34;&#34;
    Execution context of wrapped binaries.

    Execution of tracked binaries is guarded with this context
    object. In here we store everything about a single binary
    execution for consumption of an experiment.

    Attributes:
        cmd ():
        failed ():
        project ():
        experiment ():
        retcode ():
        stdout ():
        stderr ():
        db_run ():
        session ():
    &#34;&#34;&#34;
    def __begin(self, command, project, ename, group):
        &#34;&#34;&#34;
        Begin a run in the database log.

        Args:
            command: The command that will be executed.
            pname: The project name we belong to.
            ename: The experiment name we belong to.
            group: The run group we belong to.

        Returns:
            (run, session), where run is the generated run instance and
            session the associated transaction for later use.
        &#34;&#34;&#34;
        from benchbuild.utils.db import create_run
        from benchbuild.utils import schema as s
        from datetime import datetime

        db_run, session = create_run(command, project, ename, group)
        db_run.begin = datetime.now()
        db_run.status = &#39;running&#39;
        log = s.RunLog()
        log.run_id = db_run.id
        log.begin = datetime.now()
        log.config = repr(CFG)
        session.add(log)
        session.add(db_run)

        self.db_run = db_run
        self.session = session

    def __end(self, stdout, stderr):
        &#34;&#34;&#34;
        End a run in the database log (Successfully).

        This will persist the log information in the database and commit the
        transaction.

        Args:
            db_run: The ``run`` schema object we belong to
            session: The db transaction we belong to.
            stdout: The stdout we captured of the run.
            stderr: The stderr we capture of the run.
        &#34;&#34;&#34;
        from benchbuild.utils.schema import RunLog
        from datetime import datetime

        run_id = self.db_run.id

        log = self.session.query(RunLog).filter(RunLog.run_id == run_id).one()
        log.stderr = stderr
        log.stdout = stdout
        log.status = 0
        log.end = datetime.now()

        self.db_run.end = datetime.now()
        self.db_run.status = &#39;completed&#39;
        self.session.add(log)
        self.session.add(self.db_run)

    def __fail(self, retcode, stdout, stderr):
        &#34;&#34;&#34;
        End a run in the database log (Unsuccessfully).

        This will persist the log information in the database and commit the
        transaction.

        Args:
            db_run: The ``run`` schema object we belong to
            session: The db transaction we belong to.
            retcode: The return code we captured of the run.
            stdout: The stdout we captured of the run.
            stderr: The stderr we capture of the run.
        &#34;&#34;&#34;
        from benchbuild.utils.schema import RunLog
        from datetime import datetime
        run_id = self.db_run.id

        log = self.session.query(RunLog).filter(RunLog.run_id == run_id).one()
        log.stderr = stderr
        log.stdout = stdout
        log.status = retcode
        log.end = datetime.now()

        self.db_run.end = datetime.now()
        self.db_run.status = &#39;failed&#39;
        self.failed = True
        self.session.add(log)
        self.session.add(self.db_run)

    cmd = attr.ib(default=None, repr=False)
    failed = attr.ib(default=False)
    project = attr.ib(default=None, repr=False)
    experiment = attr.ib(default=None, repr=False)
    retcode = attr.ib(default=0)
    stdout = attr.ib(default=attr.Factory(list), repr=False)
    stderr = attr.ib(default=attr.Factory(list), repr=False)

    db_run = attr.ib(init=False, default=None)
    session = attr.ib(init=False, default=None, repr=False)
    payload = attr.ib(init=False, default=None, repr=False)

    def __attrs_post_init__(self):
        self.__begin(self.cmd, self.project, self.experiment.name,
                     self.project.run_uuid)
        signals.handlers.register(self.__fail, 15, &#34;SIGTERM&#34;, &#34;SIGTERM&#34;)

        run_id = self.db_run.id
        settings.CFG[&#34;db&#34;][&#34;run_id&#34;] = run_id

    def add_payload(self, name, payload):
        if self == payload:
            return
        if not self.payload:
            self.payload = {name: payload}
        else:
            self.payload.update({name: payload})

    @property
    def has_failed(self):
        &#34;&#34;&#34;Check, whether this run failed.&#34;&#34;&#34;
        return self.failed

    def __call__(self, *args, expected_retcode=0, ri=None, **kwargs):
        cmd_env = settings.CFG.to_env_dict()

        with local.env(**cmd_env):
            try:
                bin_name = sys.argv[0]
                retcode, stdout, stderr = \
                    self.cmd &amp; TEE(retcode=expected_retcode)
                f_stdout = bin_name + &#34;.stdout&#34;
                f_stderr = bin_name + &#34;.stderr&#34;
                with open(f_stdout, &#39;w&#39;) as fd_stdout:
                    fd_stdout.write(stdout)

                with open(f_stderr, &#39;w&#39;) as fd_stderr:
                    fd_stderr.write(stderr)

                self.retcode = retcode
                self.stdout = stdout
                self.stderr = stderr
                self.__end(str(stdout), str(stderr))
            except ProcessExecutionError as ex:
                self.__fail(ex.retcode, ex.stderr, ex.stdout)
                self.retcode = ex.retcode
                self.stdout = ex.stdout
                self.stderr = ex.stderr

                LOG.debug(&#34;Tracked process failed&#34;)
                LOG.error(str(ex))
            except KeyboardInterrupt:
                self.retcode = retcode
                self.stdout = stdout
                self.stderr = stderr
                self.__fail(-1, &#34;&#34;, &#34;KeyboardInterrupt&#34;)
                LOG.warning(&#34;Interrupted by user input&#34;)
                raise
            finally:
                signals.handlers.deregister(self.__fail)

        return self

    def commit(self):
        self.session.commit()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="benchbuild.utils.run.RunInfo.has_failed"><code class="name">var <span class="ident">has_failed</span></code></dt>
<dd>
<section class="desc"><p>Check, whether this run failed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_failed(self):
    &#34;&#34;&#34;Check, whether this run failed.&#34;&#34;&#34;
    return self.failed</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.utils.run.RunInfo.add_payload"><code class="name flex">
<span>def <span class="ident">add_payload</span></span>(<span>self, name, payload)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_payload(self, name, payload):
    if self == payload:
        return
    if not self.payload:
        self.payload = {name: payload}
    else:
        self.payload.update({name: payload})</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.run.RunInfo.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit(self):
    self.session.commit()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="benchbuild.utils" href="index.html">benchbuild.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="benchbuild.utils.run.begin_run_group" href="#benchbuild.utils.run.begin_run_group">begin_run_group</a></code></li>
<li><code><a title="benchbuild.utils.run.end_run_group" href="#benchbuild.utils.run.end_run_group">end_run_group</a></code></li>
<li><code><a title="benchbuild.utils.run.exit_code_from_run_infos" href="#benchbuild.utils.run.exit_code_from_run_infos">exit_code_from_run_infos</a></code></li>
<li><code><a title="benchbuild.utils.run.fail_run_group" href="#benchbuild.utils.run.fail_run_group">fail_run_group</a></code></li>
<li><code><a title="benchbuild.utils.run.in_builddir" href="#benchbuild.utils.run.in_builddir">in_builddir</a></code></li>
<li><code><a title="benchbuild.utils.run.store_config" href="#benchbuild.utils.run.store_config">store_config</a></code></li>
<li><code><a title="benchbuild.utils.run.track_execution" href="#benchbuild.utils.run.track_execution">track_execution</a></code></li>
<li><code><a title="benchbuild.utils.run.watch" href="#benchbuild.utils.run.watch">watch</a></code></li>
<li><code><a title="benchbuild.utils.run.with_env_recursive" href="#benchbuild.utils.run.with_env_recursive">with_env_recursive</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="benchbuild.utils.run.RunInfo" href="#benchbuild.utils.run.RunInfo">RunInfo</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.utils.run.RunInfo.add_payload" href="#benchbuild.utils.run.RunInfo.add_payload">add_payload</a></code></li>
<li><code><a title="benchbuild.utils.run.RunInfo.commit" href="#benchbuild.utils.run.RunInfo.commit">commit</a></code></li>
<li><code><a title="benchbuild.utils.run.RunInfo.has_failed" href="#benchbuild.utils.run.RunInfo.has_failed">has_failed</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>