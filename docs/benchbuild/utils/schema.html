<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>benchbuild.utils.schema API documentation</title>
<meta name="description" content="Database schema for benchbuild â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>benchbuild.utils.schema</code></h1>
</header>
<section id="section-intro">
<h1 id="database-schema-for-benchbuild">Database schema for benchbuild</h1>
<p>The schema should initialize itself on an empty database. For now, we do not
support automatic upgrades on schema changes. You might encounter some
roadbumps when using an older version of benchbuild.</p>
<p>Furthermore, for now, we are restricted to postgresql databases, although we
already support arbitrary connection strings via config.</p>
<p>If you want to use reports that use one of our SQL functions, you need to
initialize the functions first using the following command:</p>
<pre><code class="bash">  &gt; BB_DB_CREATE_FUNCTIONS=true benchbuild run -E empty -l
</code></pre>
<p>After that you (normally)
do not need to do this agains, unless we supply
a new version that you are interested in.
As soon as we have alembic running, we can provide automatic up/downgrade
paths for you.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Database schema for benchbuild

The schema should initialize itself on an empty database. For now, we do not
support automatic upgrades on schema changes. You might encounter some
roadbumps when using an older version of benchbuild.

Furthermore, for now, we are restricted to postgresql databases, although we
already support arbitrary connection strings via config.

If you want to use reports that use one of our SQL functions, you need to
initialize the functions first using the following command:

```bash
  &gt; BB_DB_CREATE_FUNCTIONS=true benchbuild run -E empty -l
```

After that you (normally)  do not need to do this agains, unless we supply
a new version that you are interested in.
As soon as we have alembic running, we can provide automatic up/downgrade
paths for you.
&#34;&#34;&#34;

import functools
import logging
import sys
import uuid

import migrate.versioning.api as migrate
import sqlalchemy as sa
from sqlalchemy import (Column, DateTime, Enum, ForeignKey,
                        ForeignKeyConstraint, Integer, String, create_engine)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.types import CHAR, Float, TypeDecorator

from benchbuild import settings
from benchbuild.utils import path
from benchbuild.utils import user_interface as ui

BASE = declarative_base()
LOG = logging.getLogger(__name__)


def metadata():
    return BASE.metadata


def exceptions(error_is_fatal=True, error_messages=None):
    &#34;&#34;&#34;
    Handle SQLAlchemy exceptions in a sane way.

    Args:
        func: An arbitrary function to wrap.
        error_is_fatal: Should we exit the program on exception?
        reraise: Should we reraise the exception, after logging? Only makes sense
            if error_is_fatal is False.
        error_messages: A dictionary that assigns an exception class to a
            customized error message.
    &#34;&#34;&#34;

    def exception_decorator(func):
        nonlocal error_messages

        @functools.wraps(func)
        def exc_wrapper(*args, **kwargs):
            nonlocal error_messages
            try:
                result = func(*args, **kwargs)
            except sa.exc.SQLAlchemyError as err:
                result = None
                details = None
                err_type = err.__class__
                if error_messages and err_type in error_messages:
                    details = error_messages[err_type]
                if details:
                    LOG.error(details)
                LOG.error(&#34;For developers: (%s) %s&#34;, err.__class__, str(err))
                if error_is_fatal:
                    sys.exit(&#34;Abort, SQL operation failed.&#34;)
                if not ui.ask(
                        &#34;I can continue at your own risk, do you want that?&#34;):
                    raise err
            return result

        return exc_wrapper

    return exception_decorator


class GUID(TypeDecorator):
    &#34;&#34;&#34;Platform-independent GUID type.

    Uses Postgresql&#39;s UUID type, otherwise uses
    CHAR(32), storing as stringified hex values.
    &#34;&#34;&#34;
    impl = CHAR
    as_uuid = False

    def __init__(self, *args, as_uuid=False, **kwargs):
        self.as_uuid = as_uuid
        super(GUID, self).__init__(*args, **kwargs)

    def load_dialect_impl(self, dialect):
        if dialect.name == &#39;postgresql&#39;:
            return dialect.type_descriptor(UUID(as_uuid=self.as_uuid))
        else:
            return dialect.type_descriptor(CHAR(32))

    def process_bind_param(self, value, dialect):
        return str(value)

    def process_result_value(self, value, dialect):
        if isinstance(value, uuid.UUID):
            return value

        return uuid.UUID(str(value))


class Run(BASE):
    &#34;&#34;&#34;Store a run for each executed test binary.&#34;&#34;&#34;

    __tablename__ = &#39;run&#39;
    __table_args__ = (ForeignKeyConstraint(
        [&#39;project_name&#39;, &#39;project_group&#39;],
        [&#39;project.name&#39;, &#39;project.group_name&#39;],
        onupdate=&#34;CASCADE&#34;,
        ondelete=&#34;CASCADE&#34;), )

    id = Column(Integer, primary_key=True)
    command = Column(String)
    project_name = Column(String, index=True)
    project_group = Column(String, index=True)
    experiment_name = Column(String, index=True)
    run_group = Column(GUID(as_uuid=True), index=True)
    experiment_group = Column(
        GUID(as_uuid=True),
        ForeignKey(&#34;experiment.id&#34;, ondelete=&#34;CASCADE&#34;, onupdate=&#34;CASCADE&#34;),
        index=True)

    begin = Column(DateTime(timezone=False))
    end = Column(DateTime(timezone=False))
    status = Column(Enum(&#39;completed&#39;, &#39;running&#39;, &#39;failed&#39;, name=&#34;run_state&#34;))

    metrics = sa.orm.relationship(
        &#34;Metric&#34;,
        cascade=&#34;all, delete-orphan&#34;,
        passive_deletes=True,
        passive_updates=True)
    logs = sa.orm.relationship(
        &#34;RunLog&#34;,
        cascade=&#34;all, delete-orphan&#34;,
        passive_deletes=True,
        passive_updates=True)
    stored_data = sa.orm.relationship(
        &#34;Metadata&#34;,
        cascade=&#34;all, delete-orphan&#34;,
        passive_deletes=True,
        passive_updates=True)
    configurations = sa.orm.relationship(
        &#34;Config&#34;,
        cascade=&#34;all, delete-orphan&#34;,
        passive_deletes=True,
        passive_updates=True)

    def __repr__(self):
        return (&#34;&lt;Run: {0} status={1} run={2}&gt;&#34;).format(
            self.project_name, self.status, self.id)


class RunGroup(BASE):
    &#34;&#34;&#34; Store information about a run group. &#34;&#34;&#34;

    __tablename__ = &#39;rungroup&#39;

    id = Column(GUID(as_uuid=True), primary_key=True, index=True)
    experiment = Column(
        GUID(as_uuid=True),
        ForeignKey(&#34;experiment.id&#34;, ondelete=&#34;CASCADE&#34;, onupdate=&#34;CASCADE&#34;),
        index=True)

    begin = Column(DateTime(timezone=False))
    end = Column(DateTime(timezone=False))
    status = Column(Enum(&#39;completed&#39;, &#39;running&#39;, &#39;failed&#39;, name=&#34;run_state&#34;))


class Experiment(BASE):
    &#34;&#34;&#34;Store metadata about experiments.&#34;&#34;&#34;

    __tablename__ = &#39;experiment&#39;

    name = Column(String)
    description = Column(String)
    id = Column(GUID(as_uuid=True), primary_key=True)
    begin = Column(DateTime(timezone=False))
    end = Column(DateTime(timezone=False))

    runs = sa.orm.relationship(
        &#34;Run&#34;,
        cascade=&#34;all, delete-orphan&#34;,
        passive_deletes=True,
        passive_updates=True)
    run_groups = sa.orm.relationship(
        &#34;RunGroup&#34;,
        cascade=&#34;all, delete-orphan&#34;,
        passive_deletes=True,
        passive_updates=True)

    def __repr__(self):
        return &#34;&lt;Experiment {name}&gt;&#34;.format(name=self.name)


class Project(BASE):
    &#34;&#34;&#34;Store project metadata.&#34;&#34;&#34;

    __tablename__ = &#39;project&#39;

    name = Column(String, primary_key=True)
    description = Column(String)
    src_url = Column(String)
    domain = Column(String)
    group_name = Column(String, primary_key=True)
    version = Column(String)

    runs = sa.orm.relationship(
        &#34;Run&#34;,
        cascade=&#34;all, delete-orphan&#34;,
        passive_deletes=True,
        passive_updates=True)

    def __repr__(self):
        return &#34;&lt;Project {group}@{domain}/{name} V:{version}&gt;&#34;.format(
            group=self.group_name,
            domain=self.domain,
            name=self.name,
            version=self.version)


class Metric(BASE):
    &#34;&#34;&#34;Store default metrics, simple name value store.&#34;&#34;&#34;

    __tablename__ = &#39;metrics&#39;

    name = Column(String, primary_key=True, index=True, nullable=False)
    value = Column(Float)
    run_id = Column(
        Integer,
        ForeignKey(&#34;run.id&#34;, onupdate=&#34;CASCADE&#34;, ondelete=&#34;CASCADE&#34;),
        index=True,
        primary_key=True)

    def __repr__(self):
        return &#34;{0} - {1}&#34;.format(self.name, self.value)


class RunLog(BASE):
    &#34;&#34;&#34;
    Store log information for every run.

    Properties like, start time, finish time, exit code, stderr, stdout
    are stored here.
    &#34;&#34;&#34;

    __tablename__ = &#39;log&#39;

    run_id = Column(
        Integer,
        ForeignKey(&#34;run.id&#34;, onupdate=&#34;CASCADE&#34;, ondelete=&#34;CASCADE&#34;),
        index=True,
        primary_key=True)
    begin = Column(DateTime(timezone=False))
    end = Column(DateTime(timezone=False))
    status = Column(Integer)
    config = Column(String)
    stderr = Column(String)
    stdout = Column(String)


class Metadata(BASE):
    &#34;&#34;&#34;
    Store metadata information for every run.

    If you happen to have some free-form data that belongs to the database,
    this is the place for it.
    &#34;&#34;&#34;

    __tablename__ = &#34;metadata&#34;

    run_id = Column(
        Integer,
        ForeignKey(&#34;run.id&#34;, onupdate=&#34;CASCADE&#34;, ondelete=&#34;CASCADE&#34;),
        index=True,
        primary_key=True)
    name = Column(String)
    value = Column(String)


class Config(BASE):
    &#34;&#34;&#34;
    Store customized information about a run.

    You can store arbitrary configuration information about a run here.
    Use it for extended filtering against the run table.
    &#34;&#34;&#34;

    __tablename__ = &#39;config&#39;

    run_id = Column(
        Integer,
        ForeignKey(&#34;run.id&#34;, onupdate=&#34;CASCADE&#34;, ondelete=&#34;CASCADE&#34;),
        index=True,
        primary_key=True)
    name = Column(String, primary_key=True)
    value = Column(String)


def needed_schema(connection, meta):
    try:
        meta.create_all(connection, checkfirst=False)
    except sa.exc.CompileError as cerr:
        LOG.fatal(&#34;Schema could not be created! Details: %s&#34;, str(cerr))
        sys.exit(-4)
    except sa.exc.OperationalError:
        # SQLite throws an OperationalError

        # Now try again to add user-defined tables unconditionally.
        meta.create_all(connection, checkfirst=True)
        return False
    except sa.exc.ProgrammingError:
        # PostgreSQL throws a ProgrammingError

        # Now try again to add user-defined tables unconditionally.
        meta.create_all(connection, checkfirst=True)
        return False
    return True


def get_version_data():
    &#34;&#34;&#34;Retreive migration information.&#34;&#34;&#34;
    connect_str = str(settings.CFG[&#34;db&#34;][&#34;connect_string&#34;])
    repo_url = path.template_path(&#34;../db/&#34;)
    return (connect_str, repo_url)


@exceptions(
    error_messages={
        sa.exc.ProgrammingError:
        &#34;Could not enforce versioning. Are you allowed to modify the database?&#34;
    })
def enforce_versioning(force=False):
    &#34;&#34;&#34;Install versioning on the db.&#34;&#34;&#34;
    connect_str, repo_url = get_version_data()
    #LOG.warning(&#34;Your database uses an unversioned benchbuild schema.&#34;)
    if not force and not ui.ask(
            &#34;Should I enforce version control on your schema?&#34;):
        LOG.error(&#34;User declined schema versioning.&#34;)
        return None
    repo_version = migrate.version(repo_url, url=connect_str)
    migrate.version_control(connect_str, repo_url, version=repo_version)
    return repo_version


def setup_versioning():
    connect_str, repo_url = get_version_data()
    repo_version = migrate.version(repo_url, url=connect_str)
    db_version = None
    requires_versioning = False
    try:
        db_version = migrate.db_version(connect_str, repo_url)
    except migrate.exceptions.DatabaseNotControlledError:
        requires_versioning = True

    if requires_versioning:
        db_version = enforce_versioning()

    return (repo_version, db_version)


@exceptions(
    error_messages={
        sa.exc.ProgrammingError:
        &#34;Update failed.&#34;
        &#34; Base schema version diverged from the expected structure.&#34;
    })
def maybe_update_db(repo_version, db_version):
    if db_version is None:
        return
    if db_version == repo_version:
        return

    LOG.warning(&#34;Your database contains version &#39;%s&#39; of benchbuild&#39;s schema.&#34;,
                db_version)
    LOG.warning(
        &#34;Benchbuild currently requires version &#39;%s&#39; to work correctly.&#34;,
        repo_version)
    if not ui.ask(&#34;Should I attempt to update your schema to version &#39;{0}&#39;?&#34;.
                  format(repo_version)):
        LOG.error(&#34;User declined schema upgrade.&#34;)
        return

    connect_str = str(settings.CFG[&#34;db&#34;][&#34;connect_string&#34;])
    repo_url = path.template_path(&#34;../db/&#34;)
    LOG.info(&#34;Upgrading to newest version...&#34;)
    migrate.upgrade(connect_str, repo_url)
    LOG.info(&#34;Complete.&#34;)


class SessionManager:
    def connect_engine(self):
        &#34;&#34;&#34;
        Establish a connection to the database.

        Provides simple error handling for fatal errors.

        Returns:
            True, if we could establish a connection, else False.
        &#34;&#34;&#34;
        try:
            self.connection = self.engine.connect()
            return True
        except sa.exc.OperationalError as opex:
            LOG.fatal(&#34;Could not connect to the database. The error was: &#39;%s&#39;&#34;,
                      str(opex))
        return False

    def configure_engine(self):
        &#34;&#34;&#34;
        Configure the databse connection.

        Sets appropriate transaction isolation levels and handle errors.

        Returns:
            True, if we did not encounter any unrecoverable errors, else False.
        &#34;&#34;&#34;
        try:
            self.connection.execution_options(isolation_level=&#34;SERIALIZABLE&#34;)
        except sa.exc.ArgumentError:
            LOG.debug(&#34;Unable to set isolation level to SERIALIZABLE&#34;)
        return True

    @exceptions(error_messages={
        sa.exc.NoSuchModuleError:
        &#34;Connect string contained an invalid backend.&#34;
    })
    def __init__(self):
        self.__test_mode = bool(settings.CFG[&#39;db&#39;][&#39;rollback&#39;])
        self.engine = create_engine(str(settings.CFG[&#34;db&#34;][&#34;connect_string&#34;]))

        if not (self.connect_engine() and self.configure_engine()):
            sys.exit(-3)

        self.__transaction = None
        if self.__test_mode:
            LOG.warning(
                &#34;DB test mode active, all actions will be rolled back.&#34;)
            self.__transaction = self.connection.begin()

        if needed_schema(self.connection, BASE.metadata):
            #LOG.debug(&#34;Initialized new db schema.&#34;)
            repo_version = enforce_versioning(force=True)
        else:
            repo_version, db_version = setup_versioning()
            maybe_update_db(repo_version, db_version)

    def get(self):
        return sessionmaker(bind=self.connection)

    def __del__(self):
        if hasattr(self, &#39;__transaction&#39;) and self.__transaction:
            self.__transaction.rollback()


def __lazy_session__():
    &#34;&#34;&#34;Initialize the connection manager lazily.&#34;&#34;&#34;
    connection_manager = None
    session = None

    def __lazy_session_wrapped():
        nonlocal connection_manager
        nonlocal session
        if connection_manager is None:
            connection_manager = SessionManager()
        if session is None:
            session = connection_manager.get()()
        return session

    return __lazy_session_wrapped


Session = __lazy_session__()


def init_functions(connection):
    &#34;&#34;&#34;Initialize all SQL functions in the database.&#34;&#34;&#34;
    if settings.CFG[&#34;db&#34;][&#34;create_functions&#34;]:
        print(&#34;Refreshing SQL functions...&#34;)
        for file in path.template_files(&#34;../sql/&#34;, exts=[&#34;.sql&#34;]):
            func = sa.DDL(path.template_str(file))
            LOG.info(&#34;Loading: &#39;%s&#39; into database&#34;, file)
            connection.execute(func)
            connection.commit()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="benchbuild.utils.schema.Session"><code class="name flex">
<span>def <span class="ident">Session</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __lazy_session_wrapped():
    nonlocal connection_manager
    nonlocal session
    if connection_manager is None:
        connection_manager = SessionManager()
    if session is None:
        session = connection_manager.get()()
    return session</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.enforce_versioning"><code class="name flex">
<span>def <span class="ident">enforce_versioning</span></span>(<span>force=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Install versioning on the db.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@exceptions(
    error_messages={
        sa.exc.ProgrammingError:
        &#34;Could not enforce versioning. Are you allowed to modify the database?&#34;
    })
def enforce_versioning(force=False):
    &#34;&#34;&#34;Install versioning on the db.&#34;&#34;&#34;
    connect_str, repo_url = get_version_data()
    #LOG.warning(&#34;Your database uses an unversioned benchbuild schema.&#34;)
    if not force and not ui.ask(
            &#34;Should I enforce version control on your schema?&#34;):
        LOG.error(&#34;User declined schema versioning.&#34;)
        return None
    repo_version = migrate.version(repo_url, url=connect_str)
    migrate.version_control(connect_str, repo_url, version=repo_version)
    return repo_version</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.exceptions"><code class="name flex">
<span>def <span class="ident">exceptions</span></span>(<span>error_is_fatal=True, error_messages=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Handle SQLAlchemy exceptions in a sane way.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong></dt>
<dd>An arbitrary function to wrap.</dd>
<dt><strong><code>error_is_fatal</code></strong></dt>
<dd>Should we exit the program on exception?</dd>
<dt><strong><code>reraise</code></strong></dt>
<dd>Should we reraise the exception, after logging? Only makes sense
if error_is_fatal is False.</dd>
<dt><strong><code>error_messages</code></strong></dt>
<dd>A dictionary that assigns an exception class to a
customized error message.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exceptions(error_is_fatal=True, error_messages=None):
    &#34;&#34;&#34;
    Handle SQLAlchemy exceptions in a sane way.

    Args:
        func: An arbitrary function to wrap.
        error_is_fatal: Should we exit the program on exception?
        reraise: Should we reraise the exception, after logging? Only makes sense
            if error_is_fatal is False.
        error_messages: A dictionary that assigns an exception class to a
            customized error message.
    &#34;&#34;&#34;

    def exception_decorator(func):
        nonlocal error_messages

        @functools.wraps(func)
        def exc_wrapper(*args, **kwargs):
            nonlocal error_messages
            try:
                result = func(*args, **kwargs)
            except sa.exc.SQLAlchemyError as err:
                result = None
                details = None
                err_type = err.__class__
                if error_messages and err_type in error_messages:
                    details = error_messages[err_type]
                if details:
                    LOG.error(details)
                LOG.error(&#34;For developers: (%s) %s&#34;, err.__class__, str(err))
                if error_is_fatal:
                    sys.exit(&#34;Abort, SQL operation failed.&#34;)
                if not ui.ask(
                        &#34;I can continue at your own risk, do you want that?&#34;):
                    raise err
            return result

        return exc_wrapper

    return exception_decorator</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.get_version_data"><code class="name flex">
<span>def <span class="ident">get_version_data</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Retreive migration information.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_version_data():
    &#34;&#34;&#34;Retreive migration information.&#34;&#34;&#34;
    connect_str = str(settings.CFG[&#34;db&#34;][&#34;connect_string&#34;])
    repo_url = path.template_path(&#34;../db/&#34;)
    return (connect_str, repo_url)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.init_functions"><code class="name flex">
<span>def <span class="ident">init_functions</span></span>(<span>connection)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize all SQL functions in the database.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_functions(connection):
    &#34;&#34;&#34;Initialize all SQL functions in the database.&#34;&#34;&#34;
    if settings.CFG[&#34;db&#34;][&#34;create_functions&#34;]:
        print(&#34;Refreshing SQL functions...&#34;)
        for file in path.template_files(&#34;../sql/&#34;, exts=[&#34;.sql&#34;]):
            func = sa.DDL(path.template_str(file))
            LOG.info(&#34;Loading: &#39;%s&#39; into database&#34;, file)
            connection.execute(func)
            connection.commit()</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.maybe_update_db"><code class="name flex">
<span>def <span class="ident">maybe_update_db</span></span>(<span>repo_version, db_version)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@exceptions(
    error_messages={
        sa.exc.ProgrammingError:
        &#34;Update failed.&#34;
        &#34; Base schema version diverged from the expected structure.&#34;
    })
def maybe_update_db(repo_version, db_version):
    if db_version is None:
        return
    if db_version == repo_version:
        return

    LOG.warning(&#34;Your database contains version &#39;%s&#39; of benchbuild&#39;s schema.&#34;,
                db_version)
    LOG.warning(
        &#34;Benchbuild currently requires version &#39;%s&#39; to work correctly.&#34;,
        repo_version)
    if not ui.ask(&#34;Should I attempt to update your schema to version &#39;{0}&#39;?&#34;.
                  format(repo_version)):
        LOG.error(&#34;User declined schema upgrade.&#34;)
        return

    connect_str = str(settings.CFG[&#34;db&#34;][&#34;connect_string&#34;])
    repo_url = path.template_path(&#34;../db/&#34;)
    LOG.info(&#34;Upgrading to newest version...&#34;)
    migrate.upgrade(connect_str, repo_url)
    LOG.info(&#34;Complete.&#34;)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.metadata"><code class="name flex">
<span>def <span class="ident">metadata</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metadata():
    return BASE.metadata</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.needed_schema"><code class="name flex">
<span>def <span class="ident">needed_schema</span></span>(<span>connection, meta)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def needed_schema(connection, meta):
    try:
        meta.create_all(connection, checkfirst=False)
    except sa.exc.CompileError as cerr:
        LOG.fatal(&#34;Schema could not be created! Details: %s&#34;, str(cerr))
        sys.exit(-4)
    except sa.exc.OperationalError:
        # SQLite throws an OperationalError

        # Now try again to add user-defined tables unconditionally.
        meta.create_all(connection, checkfirst=True)
        return False
    except sa.exc.ProgrammingError:
        # PostgreSQL throws a ProgrammingError

        # Now try again to add user-defined tables unconditionally.
        meta.create_all(connection, checkfirst=True)
        return False
    return True</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.setup_versioning"><code class="name flex">
<span>def <span class="ident">setup_versioning</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_versioning():
    connect_str, repo_url = get_version_data()
    repo_version = migrate.version(repo_url, url=connect_str)
    db_version = None
    requires_versioning = False
    try:
        db_version = migrate.db_version(connect_str, repo_url)
    except migrate.exceptions.DatabaseNotControlledError:
        requires_versioning = True

    if requires_versioning:
        db_version = enforce_versioning()

    return (repo_version, db_version)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="benchbuild.utils.schema.Config"><code class="flex name class">
<span>class <span class="ident">Config</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Store customized information about a run.</p>
<p>You can store arbitrary configuration information about a run here.
Use it for extended filtering against the run table.</p>
<p>A simple constructor that allows initialization from kwargs.</p>
<p>Sets attributes on the constructed instance using the names and
values in <code>kwargs</code>.</p>
<p>Only keys that are present as
attributes of the instance's class are allowed. These could be,
for example, any mapped columns or relationships.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Config(BASE):
    &#34;&#34;&#34;
    Store customized information about a run.

    You can store arbitrary configuration information about a run here.
    Use it for extended filtering against the run table.
    &#34;&#34;&#34;

    __tablename__ = &#39;config&#39;

    run_id = Column(
        Integer,
        ForeignKey(&#34;run.id&#34;, onupdate=&#34;CASCADE&#34;, ondelete=&#34;CASCADE&#34;),
        index=True,
        primary_key=True)
    name = Column(String, primary_key=True)
    value = Column(String)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sqlalchemy.ext.declarative.api.Base</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="benchbuild.utils.schema.Config.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Config.run_id"><code class="name">var <span class="ident">run_id</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Config.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.utils.schema.Experiment"><code class="flex name class">
<span>class <span class="ident">Experiment</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Store metadata about experiments.</p>
<p>A simple constructor that allows initialization from kwargs.</p>
<p>Sets attributes on the constructed instance using the names and
values in <code>kwargs</code>.</p>
<p>Only keys that are present as
attributes of the instance's class are allowed. These could be,
for example, any mapped columns or relationships.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Experiment(BASE):
    &#34;&#34;&#34;Store metadata about experiments.&#34;&#34;&#34;

    __tablename__ = &#39;experiment&#39;

    name = Column(String)
    description = Column(String)
    id = Column(GUID(as_uuid=True), primary_key=True)
    begin = Column(DateTime(timezone=False))
    end = Column(DateTime(timezone=False))

    runs = sa.orm.relationship(
        &#34;Run&#34;,
        cascade=&#34;all, delete-orphan&#34;,
        passive_deletes=True,
        passive_updates=True)
    run_groups = sa.orm.relationship(
        &#34;RunGroup&#34;,
        cascade=&#34;all, delete-orphan&#34;,
        passive_deletes=True,
        passive_updates=True)

    def __repr__(self):
        return &#34;&lt;Experiment {name}&gt;&#34;.format(name=self.name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sqlalchemy.ext.declarative.api.Base</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="benchbuild.utils.schema.Experiment.begin"><code class="name">var <span class="ident">begin</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Experiment.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Experiment.end"><code class="name">var <span class="ident">end</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Experiment.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Experiment.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Experiment.run_groups"><code class="name">var <span class="ident">run_groups</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Experiment.runs"><code class="name">var <span class="ident">runs</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.utils.schema.GUID"><code class="flex name class">
<span>class <span class="ident">GUID</span></span>
<span>(</span><span>*args, as_uuid=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Platform-independent GUID type.</p>
<p>Uses Postgresql's UUID type, otherwise uses
CHAR(32), storing as stringified hex values.</p>
<p>Construct a :class:<code>.TypeDecorator</code>.</p>
<p>Arguments sent here are passed to the constructor
of the class assigned to the <code>impl</code> class level attribute,
assuming the <code>impl</code> is a callable, and the resulting
object is assigned to the <code>self.impl</code> instance attribute
(thus overriding the class attribute of the same name).</p>
<p>If the class level <code>impl</code> is not a callable (the unusual case),
it will be assigned to the same instance attribute 'as-is',
ignoring those arguments passed to the constructor.</p>
<p>Subclasses can override this to customize the generation
of <code>self.impl</code> entirely.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GUID(TypeDecorator):
    &#34;&#34;&#34;Platform-independent GUID type.

    Uses Postgresql&#39;s UUID type, otherwise uses
    CHAR(32), storing as stringified hex values.
    &#34;&#34;&#34;
    impl = CHAR
    as_uuid = False

    def __init__(self, *args, as_uuid=False, **kwargs):
        self.as_uuid = as_uuid
        super(GUID, self).__init__(*args, **kwargs)

    def load_dialect_impl(self, dialect):
        if dialect.name == &#39;postgresql&#39;:
            return dialect.type_descriptor(UUID(as_uuid=self.as_uuid))
        else:
            return dialect.type_descriptor(CHAR(32))

    def process_bind_param(self, value, dialect):
        return str(value)

    def process_result_value(self, value, dialect):
        if isinstance(value, uuid.UUID):
            return value

        return uuid.UUID(str(value))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sqlalchemy.sql.type_api.TypeDecorator</li>
<li>sqlalchemy.sql.base.SchemaEventTarget</li>
<li>sqlalchemy.sql.type_api.TypeEngine</li>
<li>sqlalchemy.sql.visitors.Visitable</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="benchbuild.utils.schema.GUID.as_uuid"><code class="name">var <span class="ident">as_uuid</span></code></dt>
<dd>
<section class="desc"><p>bool(x) -&gt; bool</p>
<p>Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.</p></section>
</dd>
<dt id="benchbuild.utils.schema.GUID.impl"><code class="name">var <span class="ident">impl</span></code></dt>
<dd>
<section class="desc"><p>The SQL CHAR type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CHAR(String):

    &#34;&#34;&#34;The SQL CHAR type.&#34;&#34;&#34;

    __visit_name__ = &#34;CHAR&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.utils.schema.GUID.load_dialect_impl"><code class="name flex">
<span>def <span class="ident">load_dialect_impl</span></span>(<span>self, dialect)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a :class:<code>.TypeEngine</code> object corresponding to a dialect.</p>
<p>This is an end-user override hook that can be used to provide
differing types depending on the given dialect.
It is used
by the :class:<code>.TypeDecorator</code> implementation of :meth:<code>type_engine</code>
to help determine what type should ultimately be returned
for a given :class:<code>.TypeDecorator</code>.</p>
<p>By default returns <code>self.impl</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_dialect_impl(self, dialect):
    if dialect.name == &#39;postgresql&#39;:
        return dialect.type_descriptor(UUID(as_uuid=self.as_uuid))
    else:
        return dialect.type_descriptor(CHAR(32))</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.GUID.process_bind_param"><code class="name flex">
<span>def <span class="ident">process_bind_param</span></span>(<span>self, value, dialect)</span>
</code></dt>
<dd>
<section class="desc"><p>Receive a bound parameter value to be converted.</p>
<p>Subclasses override this method to return the
value that should be passed along to the underlying
:class:<code>.TypeEngine</code> object, and from there to the
DBAPI <code>execute()</code> method.</p>
<p>The operation could be anything desired to perform custom
behavior, such as transforming or serializing data.
This could also be used as a hook for validating logic.</p>
<p>This operation should be designed with the reverse operation
in mind, which would be the process_result_value method of
this class.</p>
<p>:param value: Data to operate upon, of any type expected by
this method in the subclass.
Can be <code>None</code>.
:param dialect: the :class:<code>.Dialect</code> in use.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_bind_param(self, value, dialect):
    return str(value)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.GUID.process_result_value"><code class="name flex">
<span>def <span class="ident">process_result_value</span></span>(<span>self, value, dialect)</span>
</code></dt>
<dd>
<section class="desc"><p>Receive a result-row column value to be converted.</p>
<p>Subclasses should implement this method to operate on data
fetched from the database.</p>
<p>Subclasses override this method to return the
value that should be passed back to the application,
given a value that is already processed by
the underlying :class:<code>.TypeEngine</code> object, originally
from the DBAPI cursor method <code>fetchone()</code> or similar.</p>
<p>The operation could be anything desired to perform custom
behavior, such as transforming or serializing data.
This could also be used as a hook for validating logic.</p>
<p>:param value: Data to operate upon, of any type expected by
this method in the subclass.
Can be <code>None</code>.
:param dialect: the :class:<code>.Dialect</code> in use.</p>
<p>This operation should be designed to be reversible by
the "process_bind_param" method of this class.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_result_value(self, value, dialect):
    if isinstance(value, uuid.UUID):
        return value

    return uuid.UUID(str(value))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.utils.schema.Metadata"><code class="flex name class">
<span>class <span class="ident">Metadata</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Store metadata information for every run.</p>
<p>If you happen to have some free-form data that belongs to the database,
this is the place for it.</p>
<p>A simple constructor that allows initialization from kwargs.</p>
<p>Sets attributes on the constructed instance using the names and
values in <code>kwargs</code>.</p>
<p>Only keys that are present as
attributes of the instance's class are allowed. These could be,
for example, any mapped columns or relationships.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Metadata(BASE):
    &#34;&#34;&#34;
    Store metadata information for every run.

    If you happen to have some free-form data that belongs to the database,
    this is the place for it.
    &#34;&#34;&#34;

    __tablename__ = &#34;metadata&#34;

    run_id = Column(
        Integer,
        ForeignKey(&#34;run.id&#34;, onupdate=&#34;CASCADE&#34;, ondelete=&#34;CASCADE&#34;),
        index=True,
        primary_key=True)
    name = Column(String)
    value = Column(String)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sqlalchemy.ext.declarative.api.Base</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="benchbuild.utils.schema.Metadata.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Metadata.run_id"><code class="name">var <span class="ident">run_id</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Metadata.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.utils.schema.Metric"><code class="flex name class">
<span>class <span class="ident">Metric</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Store default metrics, simple name value store.</p>
<p>A simple constructor that allows initialization from kwargs.</p>
<p>Sets attributes on the constructed instance using the names and
values in <code>kwargs</code>.</p>
<p>Only keys that are present as
attributes of the instance's class are allowed. These could be,
for example, any mapped columns or relationships.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Metric(BASE):
    &#34;&#34;&#34;Store default metrics, simple name value store.&#34;&#34;&#34;

    __tablename__ = &#39;metrics&#39;

    name = Column(String, primary_key=True, index=True, nullable=False)
    value = Column(Float)
    run_id = Column(
        Integer,
        ForeignKey(&#34;run.id&#34;, onupdate=&#34;CASCADE&#34;, ondelete=&#34;CASCADE&#34;),
        index=True,
        primary_key=True)

    def __repr__(self):
        return &#34;{0} - {1}&#34;.format(self.name, self.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sqlalchemy.ext.declarative.api.Base</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="benchbuild.utils.schema.Metric.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Metric.run_id"><code class="name">var <span class="ident">run_id</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Metric.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.utils.schema.Project"><code class="flex name class">
<span>class <span class="ident">Project</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Store project metadata.</p>
<p>A simple constructor that allows initialization from kwargs.</p>
<p>Sets attributes on the constructed instance using the names and
values in <code>kwargs</code>.</p>
<p>Only keys that are present as
attributes of the instance's class are allowed. These could be,
for example, any mapped columns or relationships.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Project(BASE):
    &#34;&#34;&#34;Store project metadata.&#34;&#34;&#34;

    __tablename__ = &#39;project&#39;

    name = Column(String, primary_key=True)
    description = Column(String)
    src_url = Column(String)
    domain = Column(String)
    group_name = Column(String, primary_key=True)
    version = Column(String)

    runs = sa.orm.relationship(
        &#34;Run&#34;,
        cascade=&#34;all, delete-orphan&#34;,
        passive_deletes=True,
        passive_updates=True)

    def __repr__(self):
        return &#34;&lt;Project {group}@{domain}/{name} V:{version}&gt;&#34;.format(
            group=self.group_name,
            domain=self.domain,
            name=self.name,
            version=self.version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sqlalchemy.ext.declarative.api.Base</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="benchbuild.utils.schema.Project.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Project.domain"><code class="name">var <span class="ident">domain</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Project.group_name"><code class="name">var <span class="ident">group_name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Project.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Project.runs"><code class="name">var <span class="ident">runs</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Project.src_url"><code class="name">var <span class="ident">src_url</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Project.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.utils.schema.Run"><code class="flex name class">
<span>class <span class="ident">Run</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Store a run for each executed test binary.</p>
<p>A simple constructor that allows initialization from kwargs.</p>
<p>Sets attributes on the constructed instance using the names and
values in <code>kwargs</code>.</p>
<p>Only keys that are present as
attributes of the instance's class are allowed. These could be,
for example, any mapped columns or relationships.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Run(BASE):
    &#34;&#34;&#34;Store a run for each executed test binary.&#34;&#34;&#34;

    __tablename__ = &#39;run&#39;
    __table_args__ = (ForeignKeyConstraint(
        [&#39;project_name&#39;, &#39;project_group&#39;],
        [&#39;project.name&#39;, &#39;project.group_name&#39;],
        onupdate=&#34;CASCADE&#34;,
        ondelete=&#34;CASCADE&#34;), )

    id = Column(Integer, primary_key=True)
    command = Column(String)
    project_name = Column(String, index=True)
    project_group = Column(String, index=True)
    experiment_name = Column(String, index=True)
    run_group = Column(GUID(as_uuid=True), index=True)
    experiment_group = Column(
        GUID(as_uuid=True),
        ForeignKey(&#34;experiment.id&#34;, ondelete=&#34;CASCADE&#34;, onupdate=&#34;CASCADE&#34;),
        index=True)

    begin = Column(DateTime(timezone=False))
    end = Column(DateTime(timezone=False))
    status = Column(Enum(&#39;completed&#39;, &#39;running&#39;, &#39;failed&#39;, name=&#34;run_state&#34;))

    metrics = sa.orm.relationship(
        &#34;Metric&#34;,
        cascade=&#34;all, delete-orphan&#34;,
        passive_deletes=True,
        passive_updates=True)
    logs = sa.orm.relationship(
        &#34;RunLog&#34;,
        cascade=&#34;all, delete-orphan&#34;,
        passive_deletes=True,
        passive_updates=True)
    stored_data = sa.orm.relationship(
        &#34;Metadata&#34;,
        cascade=&#34;all, delete-orphan&#34;,
        passive_deletes=True,
        passive_updates=True)
    configurations = sa.orm.relationship(
        &#34;Config&#34;,
        cascade=&#34;all, delete-orphan&#34;,
        passive_deletes=True,
        passive_updates=True)

    def __repr__(self):
        return (&#34;&lt;Run: {0} status={1} run={2}&gt;&#34;).format(
            self.project_name, self.status, self.id)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sqlalchemy.ext.declarative.api.Base</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="benchbuild.utils.schema.Run.begin"><code class="name">var <span class="ident">begin</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Run.command"><code class="name">var <span class="ident">command</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Run.configurations"><code class="name">var <span class="ident">configurations</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Run.end"><code class="name">var <span class="ident">end</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Run.experiment_group"><code class="name">var <span class="ident">experiment_group</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Run.experiment_name"><code class="name">var <span class="ident">experiment_name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Run.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Run.logs"><code class="name">var <span class="ident">logs</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Run.metrics"><code class="name">var <span class="ident">metrics</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Run.project_group"><code class="name">var <span class="ident">project_group</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Run.project_name"><code class="name">var <span class="ident">project_name</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Run.run_group"><code class="name">var <span class="ident">run_group</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Run.status"><code class="name">var <span class="ident">status</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.Run.stored_data"><code class="name">var <span class="ident">stored_data</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.utils.schema.RunGroup"><code class="flex name class">
<span>class <span class="ident">RunGroup</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Store information about a run group. </p>
<p>A simple constructor that allows initialization from kwargs.</p>
<p>Sets attributes on the constructed instance using the names and
values in <code>kwargs</code>.</p>
<p>Only keys that are present as
attributes of the instance's class are allowed. These could be,
for example, any mapped columns or relationships.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RunGroup(BASE):
    &#34;&#34;&#34; Store information about a run group. &#34;&#34;&#34;

    __tablename__ = &#39;rungroup&#39;

    id = Column(GUID(as_uuid=True), primary_key=True, index=True)
    experiment = Column(
        GUID(as_uuid=True),
        ForeignKey(&#34;experiment.id&#34;, ondelete=&#34;CASCADE&#34;, onupdate=&#34;CASCADE&#34;),
        index=True)

    begin = Column(DateTime(timezone=False))
    end = Column(DateTime(timezone=False))
    status = Column(Enum(&#39;completed&#39;, &#39;running&#39;, &#39;failed&#39;, name=&#34;run_state&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sqlalchemy.ext.declarative.api.Base</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="benchbuild.utils.schema.RunGroup.begin"><code class="name">var <span class="ident">begin</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.RunGroup.end"><code class="name">var <span class="ident">end</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.RunGroup.experiment"><code class="name">var <span class="ident">experiment</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.RunGroup.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.RunGroup.status"><code class="name">var <span class="ident">status</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.utils.schema.RunLog"><code class="flex name class">
<span>class <span class="ident">RunLog</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Store log information for every run.</p>
<p>Properties like, start time, finish time, exit code, stderr, stdout
are stored here.</p>
<p>A simple constructor that allows initialization from kwargs.</p>
<p>Sets attributes on the constructed instance using the names and
values in <code>kwargs</code>.</p>
<p>Only keys that are present as
attributes of the instance's class are allowed. These could be,
for example, any mapped columns or relationships.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RunLog(BASE):
    &#34;&#34;&#34;
    Store log information for every run.

    Properties like, start time, finish time, exit code, stderr, stdout
    are stored here.
    &#34;&#34;&#34;

    __tablename__ = &#39;log&#39;

    run_id = Column(
        Integer,
        ForeignKey(&#34;run.id&#34;, onupdate=&#34;CASCADE&#34;, ondelete=&#34;CASCADE&#34;),
        index=True,
        primary_key=True)
    begin = Column(DateTime(timezone=False))
    end = Column(DateTime(timezone=False))
    status = Column(Integer)
    config = Column(String)
    stderr = Column(String)
    stdout = Column(String)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sqlalchemy.ext.declarative.api.Base</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="benchbuild.utils.schema.RunLog.begin"><code class="name">var <span class="ident">begin</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.RunLog.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.RunLog.end"><code class="name">var <span class="ident">end</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.RunLog.run_id"><code class="name">var <span class="ident">run_id</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.RunLog.status"><code class="name">var <span class="ident">status</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.RunLog.stderr"><code class="name">var <span class="ident">stderr</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.RunLog.stdout"><code class="name">var <span class="ident">stdout</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    if instance is None:
        return self

    dict_ = instance_dict(instance)
    if self._supports_population and self.key in dict_:
        return dict_[self.key]
    else:
        return self.impl.get(instance_state(instance), dict_)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="benchbuild.utils.schema.SessionManager"><code class="flex name class">
<span>class <span class="ident">SessionManager</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SessionManager:
    def connect_engine(self):
        &#34;&#34;&#34;
        Establish a connection to the database.

        Provides simple error handling for fatal errors.

        Returns:
            True, if we could establish a connection, else False.
        &#34;&#34;&#34;
        try:
            self.connection = self.engine.connect()
            return True
        except sa.exc.OperationalError as opex:
            LOG.fatal(&#34;Could not connect to the database. The error was: &#39;%s&#39;&#34;,
                      str(opex))
        return False

    def configure_engine(self):
        &#34;&#34;&#34;
        Configure the databse connection.

        Sets appropriate transaction isolation levels and handle errors.

        Returns:
            True, if we did not encounter any unrecoverable errors, else False.
        &#34;&#34;&#34;
        try:
            self.connection.execution_options(isolation_level=&#34;SERIALIZABLE&#34;)
        except sa.exc.ArgumentError:
            LOG.debug(&#34;Unable to set isolation level to SERIALIZABLE&#34;)
        return True

    @exceptions(error_messages={
        sa.exc.NoSuchModuleError:
        &#34;Connect string contained an invalid backend.&#34;
    })
    def __init__(self):
        self.__test_mode = bool(settings.CFG[&#39;db&#39;][&#39;rollback&#39;])
        self.engine = create_engine(str(settings.CFG[&#34;db&#34;][&#34;connect_string&#34;]))

        if not (self.connect_engine() and self.configure_engine()):
            sys.exit(-3)

        self.__transaction = None
        if self.__test_mode:
            LOG.warning(
                &#34;DB test mode active, all actions will be rolled back.&#34;)
            self.__transaction = self.connection.begin()

        if needed_schema(self.connection, BASE.metadata):
            #LOG.debug(&#34;Initialized new db schema.&#34;)
            repo_version = enforce_versioning(force=True)
        else:
            repo_version, db_version = setup_versioning()
            maybe_update_db(repo_version, db_version)

    def get(self):
        return sessionmaker(bind=self.connection)

    def __del__(self):
        if hasattr(self, &#39;__transaction&#39;) and self.__transaction:
            self.__transaction.rollback()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="benchbuild.utils.schema.SessionManager.configure_engine"><code class="name flex">
<span>def <span class="ident">configure_engine</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Configure the databse connection.</p>
<p>Sets appropriate transaction isolation levels and handle errors.</p>
<h2 id="returns">Returns</h2>
<p>True, if we did not encounter any unrecoverable errors, else False.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_engine(self):
    &#34;&#34;&#34;
    Configure the databse connection.

    Sets appropriate transaction isolation levels and handle errors.

    Returns:
        True, if we did not encounter any unrecoverable errors, else False.
    &#34;&#34;&#34;
    try:
        self.connection.execution_options(isolation_level=&#34;SERIALIZABLE&#34;)
    except sa.exc.ArgumentError:
        LOG.debug(&#34;Unable to set isolation level to SERIALIZABLE&#34;)
    return True</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.SessionManager.connect_engine"><code class="name flex">
<span>def <span class="ident">connect_engine</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Establish a connection to the database.</p>
<p>Provides simple error handling for fatal errors.</p>
<h2 id="returns">Returns</h2>
<p>True, if we could establish a connection, else False.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_engine(self):
    &#34;&#34;&#34;
    Establish a connection to the database.

    Provides simple error handling for fatal errors.

    Returns:
        True, if we could establish a connection, else False.
    &#34;&#34;&#34;
    try:
        self.connection = self.engine.connect()
        return True
    except sa.exc.OperationalError as opex:
        LOG.fatal(&#34;Could not connect to the database. The error was: &#39;%s&#39;&#34;,
                  str(opex))
    return False</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.schema.SessionManager.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self):
    return sessionmaker(bind=self.connection)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#database-schema-for-benchbuild">Database schema for benchbuild</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="benchbuild.utils" href="index.html">benchbuild.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="benchbuild.utils.schema.Session" href="#benchbuild.utils.schema.Session">Session</a></code></li>
<li><code><a title="benchbuild.utils.schema.enforce_versioning" href="#benchbuild.utils.schema.enforce_versioning">enforce_versioning</a></code></li>
<li><code><a title="benchbuild.utils.schema.exceptions" href="#benchbuild.utils.schema.exceptions">exceptions</a></code></li>
<li><code><a title="benchbuild.utils.schema.get_version_data" href="#benchbuild.utils.schema.get_version_data">get_version_data</a></code></li>
<li><code><a title="benchbuild.utils.schema.init_functions" href="#benchbuild.utils.schema.init_functions">init_functions</a></code></li>
<li><code><a title="benchbuild.utils.schema.maybe_update_db" href="#benchbuild.utils.schema.maybe_update_db">maybe_update_db</a></code></li>
<li><code><a title="benchbuild.utils.schema.metadata" href="#benchbuild.utils.schema.metadata">metadata</a></code></li>
<li><code><a title="benchbuild.utils.schema.needed_schema" href="#benchbuild.utils.schema.needed_schema">needed_schema</a></code></li>
<li><code><a title="benchbuild.utils.schema.setup_versioning" href="#benchbuild.utils.schema.setup_versioning">setup_versioning</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="benchbuild.utils.schema.Config" href="#benchbuild.utils.schema.Config">Config</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.utils.schema.Config.name" href="#benchbuild.utils.schema.Config.name">name</a></code></li>
<li><code><a title="benchbuild.utils.schema.Config.run_id" href="#benchbuild.utils.schema.Config.run_id">run_id</a></code></li>
<li><code><a title="benchbuild.utils.schema.Config.value" href="#benchbuild.utils.schema.Config.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.utils.schema.Experiment" href="#benchbuild.utils.schema.Experiment">Experiment</a></code></h4>
<ul class="two-column">
<li><code><a title="benchbuild.utils.schema.Experiment.begin" href="#benchbuild.utils.schema.Experiment.begin">begin</a></code></li>
<li><code><a title="benchbuild.utils.schema.Experiment.description" href="#benchbuild.utils.schema.Experiment.description">description</a></code></li>
<li><code><a title="benchbuild.utils.schema.Experiment.end" href="#benchbuild.utils.schema.Experiment.end">end</a></code></li>
<li><code><a title="benchbuild.utils.schema.Experiment.id" href="#benchbuild.utils.schema.Experiment.id">id</a></code></li>
<li><code><a title="benchbuild.utils.schema.Experiment.name" href="#benchbuild.utils.schema.Experiment.name">name</a></code></li>
<li><code><a title="benchbuild.utils.schema.Experiment.run_groups" href="#benchbuild.utils.schema.Experiment.run_groups">run_groups</a></code></li>
<li><code><a title="benchbuild.utils.schema.Experiment.runs" href="#benchbuild.utils.schema.Experiment.runs">runs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.utils.schema.GUID" href="#benchbuild.utils.schema.GUID">GUID</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.utils.schema.GUID.as_uuid" href="#benchbuild.utils.schema.GUID.as_uuid">as_uuid</a></code></li>
<li><code><a title="benchbuild.utils.schema.GUID.impl" href="#benchbuild.utils.schema.GUID.impl">impl</a></code></li>
<li><code><a title="benchbuild.utils.schema.GUID.load_dialect_impl" href="#benchbuild.utils.schema.GUID.load_dialect_impl">load_dialect_impl</a></code></li>
<li><code><a title="benchbuild.utils.schema.GUID.process_bind_param" href="#benchbuild.utils.schema.GUID.process_bind_param">process_bind_param</a></code></li>
<li><code><a title="benchbuild.utils.schema.GUID.process_result_value" href="#benchbuild.utils.schema.GUID.process_result_value">process_result_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.utils.schema.Metadata" href="#benchbuild.utils.schema.Metadata">Metadata</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.utils.schema.Metadata.name" href="#benchbuild.utils.schema.Metadata.name">name</a></code></li>
<li><code><a title="benchbuild.utils.schema.Metadata.run_id" href="#benchbuild.utils.schema.Metadata.run_id">run_id</a></code></li>
<li><code><a title="benchbuild.utils.schema.Metadata.value" href="#benchbuild.utils.schema.Metadata.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.utils.schema.Metric" href="#benchbuild.utils.schema.Metric">Metric</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.utils.schema.Metric.name" href="#benchbuild.utils.schema.Metric.name">name</a></code></li>
<li><code><a title="benchbuild.utils.schema.Metric.run_id" href="#benchbuild.utils.schema.Metric.run_id">run_id</a></code></li>
<li><code><a title="benchbuild.utils.schema.Metric.value" href="#benchbuild.utils.schema.Metric.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.utils.schema.Project" href="#benchbuild.utils.schema.Project">Project</a></code></h4>
<ul class="two-column">
<li><code><a title="benchbuild.utils.schema.Project.description" href="#benchbuild.utils.schema.Project.description">description</a></code></li>
<li><code><a title="benchbuild.utils.schema.Project.domain" href="#benchbuild.utils.schema.Project.domain">domain</a></code></li>
<li><code><a title="benchbuild.utils.schema.Project.group_name" href="#benchbuild.utils.schema.Project.group_name">group_name</a></code></li>
<li><code><a title="benchbuild.utils.schema.Project.name" href="#benchbuild.utils.schema.Project.name">name</a></code></li>
<li><code><a title="benchbuild.utils.schema.Project.runs" href="#benchbuild.utils.schema.Project.runs">runs</a></code></li>
<li><code><a title="benchbuild.utils.schema.Project.src_url" href="#benchbuild.utils.schema.Project.src_url">src_url</a></code></li>
<li><code><a title="benchbuild.utils.schema.Project.version" href="#benchbuild.utils.schema.Project.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.utils.schema.Run" href="#benchbuild.utils.schema.Run">Run</a></code></h4>
<ul class="two-column">
<li><code><a title="benchbuild.utils.schema.Run.begin" href="#benchbuild.utils.schema.Run.begin">begin</a></code></li>
<li><code><a title="benchbuild.utils.schema.Run.command" href="#benchbuild.utils.schema.Run.command">command</a></code></li>
<li><code><a title="benchbuild.utils.schema.Run.configurations" href="#benchbuild.utils.schema.Run.configurations">configurations</a></code></li>
<li><code><a title="benchbuild.utils.schema.Run.end" href="#benchbuild.utils.schema.Run.end">end</a></code></li>
<li><code><a title="benchbuild.utils.schema.Run.experiment_group" href="#benchbuild.utils.schema.Run.experiment_group">experiment_group</a></code></li>
<li><code><a title="benchbuild.utils.schema.Run.experiment_name" href="#benchbuild.utils.schema.Run.experiment_name">experiment_name</a></code></li>
<li><code><a title="benchbuild.utils.schema.Run.id" href="#benchbuild.utils.schema.Run.id">id</a></code></li>
<li><code><a title="benchbuild.utils.schema.Run.logs" href="#benchbuild.utils.schema.Run.logs">logs</a></code></li>
<li><code><a title="benchbuild.utils.schema.Run.metrics" href="#benchbuild.utils.schema.Run.metrics">metrics</a></code></li>
<li><code><a title="benchbuild.utils.schema.Run.project_group" href="#benchbuild.utils.schema.Run.project_group">project_group</a></code></li>
<li><code><a title="benchbuild.utils.schema.Run.project_name" href="#benchbuild.utils.schema.Run.project_name">project_name</a></code></li>
<li><code><a title="benchbuild.utils.schema.Run.run_group" href="#benchbuild.utils.schema.Run.run_group">run_group</a></code></li>
<li><code><a title="benchbuild.utils.schema.Run.status" href="#benchbuild.utils.schema.Run.status">status</a></code></li>
<li><code><a title="benchbuild.utils.schema.Run.stored_data" href="#benchbuild.utils.schema.Run.stored_data">stored_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.utils.schema.RunGroup" href="#benchbuild.utils.schema.RunGroup">RunGroup</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.utils.schema.RunGroup.begin" href="#benchbuild.utils.schema.RunGroup.begin">begin</a></code></li>
<li><code><a title="benchbuild.utils.schema.RunGroup.end" href="#benchbuild.utils.schema.RunGroup.end">end</a></code></li>
<li><code><a title="benchbuild.utils.schema.RunGroup.experiment" href="#benchbuild.utils.schema.RunGroup.experiment">experiment</a></code></li>
<li><code><a title="benchbuild.utils.schema.RunGroup.id" href="#benchbuild.utils.schema.RunGroup.id">id</a></code></li>
<li><code><a title="benchbuild.utils.schema.RunGroup.status" href="#benchbuild.utils.schema.RunGroup.status">status</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.utils.schema.RunLog" href="#benchbuild.utils.schema.RunLog">RunLog</a></code></h4>
<ul class="two-column">
<li><code><a title="benchbuild.utils.schema.RunLog.begin" href="#benchbuild.utils.schema.RunLog.begin">begin</a></code></li>
<li><code><a title="benchbuild.utils.schema.RunLog.config" href="#benchbuild.utils.schema.RunLog.config">config</a></code></li>
<li><code><a title="benchbuild.utils.schema.RunLog.end" href="#benchbuild.utils.schema.RunLog.end">end</a></code></li>
<li><code><a title="benchbuild.utils.schema.RunLog.run_id" href="#benchbuild.utils.schema.RunLog.run_id">run_id</a></code></li>
<li><code><a title="benchbuild.utils.schema.RunLog.status" href="#benchbuild.utils.schema.RunLog.status">status</a></code></li>
<li><code><a title="benchbuild.utils.schema.RunLog.stderr" href="#benchbuild.utils.schema.RunLog.stderr">stderr</a></code></li>
<li><code><a title="benchbuild.utils.schema.RunLog.stdout" href="#benchbuild.utils.schema.RunLog.stdout">stdout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="benchbuild.utils.schema.SessionManager" href="#benchbuild.utils.schema.SessionManager">SessionManager</a></code></h4>
<ul class="">
<li><code><a title="benchbuild.utils.schema.SessionManager.configure_engine" href="#benchbuild.utils.schema.SessionManager.configure_engine">configure_engine</a></code></li>
<li><code><a title="benchbuild.utils.schema.SessionManager.connect_engine" href="#benchbuild.utils.schema.SessionManager.connect_engine">connect_engine</a></code></li>
<li><code><a title="benchbuild.utils.schema.SessionManager.get" href="#benchbuild.utils.schema.SessionManager.get">get</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>