<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>benchbuild.utils.wrapping API documentation</title>
<meta name="description" content="Wrapper utilities for benchbuild â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>benchbuild.utils.wrapping</code></h1>
</header>
<section id="section-intro">
<p>Wrapper utilities for benchbuild.</p>
<p>This module provides methods to wrap binaries with extensions that are
pickled alongside the original binary.
In place of the original binary a new python module is generated that
loads the pickle and redirects the program call with all its arguments
to it. This allows interception of arbitrary programs for experimentation.</p>
<h2 id="examples">Examples</h2>
<dl>
<dt><strong><code>TODO</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Compiler Wrappers:
The compiler wrappers substitute the compiler call with a script that
produces the expected output from the original compiler call first.
Afterwards the pickle is loaded and the original call is forwarded to the
pickle. This way the user is not obligated to produce valid output during
his own experiment.</p>
<p>Runtime Wrappers:
These directly forward the binary call to the pickle without any execution
of the binary. We cannot guarantee that repeated execution is valid,
therefore, we let the user decide what the program should do.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Wrapper utilities for benchbuild.

This module provides methods to wrap binaries with extensions that are
pickled alongside the original binary.
In place of the original binary a new python module is generated that
loads the pickle and redirects the program call with all its arguments
to it. This allows interception of arbitrary programs for experimentation.

Examples:
    TODO

Compiler Wrappers:
    The compiler wrappers substitute the compiler call with a script that
    produces the expected output from the original compiler call first.
    Afterwards the pickle is loaded and the original call is forwarded to the
    pickle. This way the user is not obligated to produce valid output during
    his own experiment.

Runtime Wrappers:
    These directly forward the binary call to the pickle without any execution
    of the binary. We cannot guarantee that repeated execution is valid,
    therefore, we let the user decide what the program should do.
&#34;&#34;&#34;
import logging
import os
import sys

import dill
from plumbum import local

from benchbuild.settings import CFG
from benchbuild.utils import run
from benchbuild.utils.cmd import chmod, mv
from benchbuild.utils.path import list_to_path
from benchbuild.utils.uchroot import no_llvm as uchroot

PROJECT_BIN_F_EXT = &#34;.bin&#34;
PROJECT_BLOB_F_EXT = &#34;.postproc&#34;
LOG = logging.getLogger(__name__)


def strip_path_prefix(ipath, prefix):
    &#34;&#34;&#34;
    Strip prefix from path.

    Args:
        ipath: input path
        prefix: the prefix to remove, if it is found in :ipath:

    Examples:
        &gt;&gt;&gt; strip_path_prefix(&#34;/foo/bar&#34;, &#34;/bar&#34;)
        &#39;/foo/bar&#39;
        &gt;&gt;&gt; strip_path_prefix(&#34;/foo/bar&#34;, &#34;/&#34;)
        &#39;foo/bar&#39;
        &gt;&gt;&gt; strip_path_prefix(&#34;/foo/bar&#34;, &#34;/foo&#34;)
        &#39;/bar&#39;
        &gt;&gt;&gt; strip_path_prefix(&#34;/foo/bar&#34;, &#34;None&#34;)
        &#39;/foo/bar&#39;

    &#34;&#34;&#34;
    if prefix is None:
        return ipath

    return ipath[len(prefix):] if ipath.startswith(prefix) else ipath


def unpickle(pickle_file):
    &#34;&#34;&#34;Unpickle a python object from the given path.&#34;&#34;&#34;
    pickle = None
    with open(pickle_file, &#34;rb&#34;) as pickle_f:
        pickle = dill.load(pickle_f)
    if not pickle:
        LOG.error(&#34;Could not load python object from file&#34;)
    return pickle


def __create_jinja_env():
    from jinja2 import Environment, PackageLoader
    return Environment(trim_blocks=True,
                       lstrip_blocks=True,
                       loader=PackageLoader(&#39;benchbuild.utils&#39;, &#39;templates&#39;))


def wrap(name, project, sprefix=None, python=sys.executable):
    &#34;&#34;&#34; Wrap the binary :name: with the runtime extension of the project.

    This module generates a python tool that replaces :name:
    The function in runner only accepts the replaced binaries
    name as argument. We use the cloudpickle package to
    perform the serialization, make sure :runner: can be serialized
    with it and you&#39;re fine.

    Args:
        name: Binary we want to wrap
        project: The project that contains the runtime_extension we want
                 to run instead of the binary.

    Returns:
        A plumbum command, ready to launch.
    &#34;&#34;&#34;
    env = __create_jinja_env()
    template = env.get_template(&#39;run_static.py.inc&#39;)

    name_absolute = os.path.abspath(name)
    real_f = name_absolute + PROJECT_BIN_F_EXT
    if sprefix:
        mv_ = run.watch(uchroot()[&#34;/bin/mv&#34;])
        mv_(strip_path_prefix(name_absolute, sprefix),
            strip_path_prefix(real_f, sprefix))
    else:
        mv_ = run.watch(mv)
        mv(name_absolute, real_f)

    project_file = persist(project, suffix=&#34;.project&#34;)

    env = CFG[&#39;env&#39;].value

    bin_path = list_to_path(env.get(&#39;PATH&#39;, []))
    bin_path = list_to_path([bin_path, os.environ[&#34;PATH&#34;]])

    bin_lib_path = list_to_path(env.get(&#39;LD_LIBRARY_PATH&#39;, []))
    bin_lib_path = list_to_path([bin_lib_path, os.environ[&#34;LD_LIBRARY_PATH&#34;]])
    home = env.get(&#34;HOME&#34;, os.getenv(&#34;HOME&#34;, &#34;&#34;))

    with open(name_absolute, &#39;w&#39;) as wrapper:
        wrapper.write(
            template.render(
                runf=strip_path_prefix(real_f, sprefix),
                project_file=strip_path_prefix(project_file, sprefix),
                path=str(bin_path),
                ld_library_path=str(bin_lib_path),
                home=str(home),
                python=python,
            ))

    chmod_ = run.watch(chmod)
    chmod_(&#34;+x&#34;, name_absolute)
    return local[name_absolute]


def wrap_dynamic(project,
                 name,
                 sprefix=None,
                 python=sys.executable,
                 name_filters=None):
    &#34;&#34;&#34;
    Wrap the binary :name with the function :runner.

    This module generates a python tool :name: that can replace
    a yet unspecified binary.
    It behaves similar to the :wrap: function. However, the first
    argument is the actual binary name.

    Args:
        name: name of the python module
        runner: Function that should run the real binary
        sprefix: Prefix that should be used for commands.
        python: The python executable that should be used.
        name_filters:
            List of regex expressions that are used to filter the
            real project name. Make sure to include a match group named
            &#39;name&#39; in the regex, e.g.,
            [
                r&#39;foo(?P&lt;name&gt;.)-flt&#39;
            ]

    Returns: plumbum command, readty to launch.

    &#34;&#34;&#34;
    env = __create_jinja_env()
    template = env.get_template(&#39;run_dynamic.py.inc&#39;)

    name_absolute = os.path.abspath(name)
    real_f = name_absolute + PROJECT_BIN_F_EXT

    project_file = persist(project, suffix=&#34;.project&#34;)

    env = CFG[&#39;env&#39;].value

    bin_path = list_to_path(env.get(&#39;PATH&#39;, []))
    bin_path = list_to_path([bin_path, os.environ[&#34;PATH&#34;]])

    bin_lib_path = \
        list_to_path(env.get(&#39;LD_LIBRARY_PATH&#39;, []))
    bin_lib_path = \
        list_to_path([bin_lib_path, os.environ[&#34;LD_LIBRARY_PATH&#34;]])
    home = env.get(&#34;HOME&#34;, os.getenv(&#34;HOME&#34;, &#34;&#34;))

    with open(name_absolute, &#39;w&#39;) as wrapper:
        wrapper.write(
            template.render(runf=strip_path_prefix(real_f, sprefix),
                            project_file=strip_path_prefix(
                                project_file, sprefix),
                            path=str(bin_path),
                            ld_library_path=str(bin_lib_path),
                            home=str(home),
                            python=python,
                            name_filters=name_filters))

    chmod(&#34;+x&#34;, name_absolute)
    return local[name_absolute]


def wrap_cc(filepath,
            compiler,
            project,
            python=sys.executable,
            detect_project=False):
    &#34;&#34;&#34;
    Substitute a compiler with a script that hides CFLAGS &amp; LDFLAGS.

    This will generate a wrapper script in the current directory
    and return a complete plumbum command to it.

    Args:
        filepath (str): Path to the wrapper script.
        compiler (benchbuild.utils.cmd):
            Real compiler command we should call in the script.
        project (benchbuild.project.Project):
            The project this compiler will be for.
        python (str): Path to the python interpreter we should use.
        detect_project: Should we enable project detection or not.

    Returns (benchbuild.utils.cmd):
        Command of the new compiler we can call.
    &#34;&#34;&#34;
    env = __create_jinja_env()
    template = env.get_template(&#39;run_compiler.py.inc&#39;)

    cc_fname = local.path(filepath).with_suffix(&#34;.benchbuild.cc&#34;, depth=0)
    cc_f = persist(compiler, filename=cc_fname)

    project_file = persist(project, suffix=&#34;.project&#34;)

    with open(filepath, &#39;w&#39;) as wrapper:
        wrapper.write(
            template.render(cc_f=cc_f,
                            project_file=project_file,
                            python=python,
                            detect_project=detect_project))

    chmod(&#34;+x&#34;, filepath)
    LOG.debug(&#34;Placed wrapper in: %s for compiler %s&#34;, local.path(filepath),
              str(compiler))
    LOG.debug(&#34;Placed project in: %s&#34;, local.path(project_file))
    LOG.debug(&#34;Placed compiler command in: %s&#34;, local.path(cc_f))
    return local[filepath]


def persist(id_obj, filename=None, suffix=None):
    &#34;&#34;&#34;Persist an object in the filesystem.

    This will generate a pickled version of the given obj in the filename path.
    Objects shall provide an id() method to be able to use this persistence API.
    If not, we will use the id() builtin of python to generate an identifier
    for you.

    The file will be created, if it does not exist.
    If the file already exists, we will overwrite it.

    Args:
        id_obj (Any): An identifiable object you want to persist in the
                      filesystem.
    &#34;&#34;&#34;
    if suffix is None:
        suffix = &#34;.pickle&#34;
    if hasattr(id_obj, &#39;run_uuid&#39;):
        ident = id_obj.run_uuid
    else:
        ident = str(id(id_obj))

    if filename is None:
        filename = &#34;{obj_id}{suffix}&#34;.format(obj_id=ident, suffix=suffix)

    with open(filename, &#39;wb&#39;) as obj_file:
        dill.dump(id_obj, obj_file)
    return os.path.abspath(filename)


def load(filename):
    &#34;&#34;&#34;Load a pickled obj from the filesystem.

    You better know what you expect from the given pickle, because we don&#39;t check it.

    Args:
        filename (str): The filename we load the object from.

    Returns:
        The object we were able to unpickle, else None.
    &#34;&#34;&#34;
    if not os.path.exists(filename):
        LOG.error(&#34;load object - File &#39;%s&#39; does not exist.&#34;, filename)
        return None

    obj = None
    with open(filename, &#39;rb&#39;) as obj_file:
        obj = dill.load(obj_file)
    return obj</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="benchbuild.utils.wrapping.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Load a pickled obj from the filesystem.</p>
<p>You better know what you expect from the given pickle, because we don't check it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>The filename we load the object from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The object we were able to unpickle, else None.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(filename):
    &#34;&#34;&#34;Load a pickled obj from the filesystem.

    You better know what you expect from the given pickle, because we don&#39;t check it.

    Args:
        filename (str): The filename we load the object from.

    Returns:
        The object we were able to unpickle, else None.
    &#34;&#34;&#34;
    if not os.path.exists(filename):
        LOG.error(&#34;load object - File &#39;%s&#39; does not exist.&#34;, filename)
        return None

    obj = None
    with open(filename, &#39;rb&#39;) as obj_file:
        obj = dill.load(obj_file)
    return obj</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.wrapping.persist"><code class="name flex">
<span>def <span class="ident">persist</span></span>(<span>id_obj, filename=None, suffix=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Persist an object in the filesystem.</p>
<p>This will generate a pickled version of the given obj in the filename path.
Objects shall provide an id() method to be able to use this persistence API.
If not, we will use the id() builtin of python to generate an identifier
for you.</p>
<p>The file will be created, if it does not exist.
If the file already exists, we will overwrite it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id_obj</code></strong> :&ensp;<code>Any</code></dt>
<dd>An identifiable object you want to persist in the
filesystem.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def persist(id_obj, filename=None, suffix=None):
    &#34;&#34;&#34;Persist an object in the filesystem.

    This will generate a pickled version of the given obj in the filename path.
    Objects shall provide an id() method to be able to use this persistence API.
    If not, we will use the id() builtin of python to generate an identifier
    for you.

    The file will be created, if it does not exist.
    If the file already exists, we will overwrite it.

    Args:
        id_obj (Any): An identifiable object you want to persist in the
                      filesystem.
    &#34;&#34;&#34;
    if suffix is None:
        suffix = &#34;.pickle&#34;
    if hasattr(id_obj, &#39;run_uuid&#39;):
        ident = id_obj.run_uuid
    else:
        ident = str(id(id_obj))

    if filename is None:
        filename = &#34;{obj_id}{suffix}&#34;.format(obj_id=ident, suffix=suffix)

    with open(filename, &#39;wb&#39;) as obj_file:
        dill.dump(id_obj, obj_file)
    return os.path.abspath(filename)</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.wrapping.strip_path_prefix"><code class="name flex">
<span>def <span class="ident">strip_path_prefix</span></span>(<span>ipath, prefix)</span>
</code></dt>
<dd>
<section class="desc"><p>Strip prefix from path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ipath</code></strong></dt>
<dd>input path</dd>
<dt><strong><code>prefix</code></strong></dt>
<dd>the prefix to remove, if it is found in :ipath:</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; strip_path_prefix("/foo/bar", "/bar")
'/foo/bar'
&gt;&gt;&gt; strip_path_prefix("/foo/bar", "/")
'foo/bar'
&gt;&gt;&gt; strip_path_prefix("/foo/bar", "/foo")
'/bar'
&gt;&gt;&gt; strip_path_prefix("/foo/bar", "None")
'/foo/bar'
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_path_prefix(ipath, prefix):
    &#34;&#34;&#34;
    Strip prefix from path.

    Args:
        ipath: input path
        prefix: the prefix to remove, if it is found in :ipath:

    Examples:
        &gt;&gt;&gt; strip_path_prefix(&#34;/foo/bar&#34;, &#34;/bar&#34;)
        &#39;/foo/bar&#39;
        &gt;&gt;&gt; strip_path_prefix(&#34;/foo/bar&#34;, &#34;/&#34;)
        &#39;foo/bar&#39;
        &gt;&gt;&gt; strip_path_prefix(&#34;/foo/bar&#34;, &#34;/foo&#34;)
        &#39;/bar&#39;
        &gt;&gt;&gt; strip_path_prefix(&#34;/foo/bar&#34;, &#34;None&#34;)
        &#39;/foo/bar&#39;

    &#34;&#34;&#34;
    if prefix is None:
        return ipath

    return ipath[len(prefix):] if ipath.startswith(prefix) else ipath</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.wrapping.unpickle"><code class="name flex">
<span>def <span class="ident">unpickle</span></span>(<span>pickle_file)</span>
</code></dt>
<dd>
<section class="desc"><p>Unpickle a python object from the given path.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unpickle(pickle_file):
    &#34;&#34;&#34;Unpickle a python object from the given path.&#34;&#34;&#34;
    pickle = None
    with open(pickle_file, &#34;rb&#34;) as pickle_f:
        pickle = dill.load(pickle_f)
    if not pickle:
        LOG.error(&#34;Could not load python object from file&#34;)
    return pickle</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.wrapping.wrap"><code class="name flex">
<span>def <span class="ident">wrap</span></span>(<span>name, project, sprefix=None, python='/home/simbuerg/src/polyjit/benchbuild/.tox/docs/bin/python')</span>
</code></dt>
<dd>
<section class="desc"><p>Wrap the binary :name: with the runtime extension of the project.</p>
<p>This module generates a python tool that replaces :name:
The function in runner only accepts the replaced binaries
name as argument. We use the cloudpickle package to
perform the serialization, make sure :runner: can be serialized
with it and you're fine.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Binary we want to wrap</dd>
<dt><strong><code>project</code></strong></dt>
<dd>The project that contains the runtime_extension we want
to run instead of the binary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A plumbum command, ready to launch.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap(name, project, sprefix=None, python=sys.executable):
    &#34;&#34;&#34; Wrap the binary :name: with the runtime extension of the project.

    This module generates a python tool that replaces :name:
    The function in runner only accepts the replaced binaries
    name as argument. We use the cloudpickle package to
    perform the serialization, make sure :runner: can be serialized
    with it and you&#39;re fine.

    Args:
        name: Binary we want to wrap
        project: The project that contains the runtime_extension we want
                 to run instead of the binary.

    Returns:
        A plumbum command, ready to launch.
    &#34;&#34;&#34;
    env = __create_jinja_env()
    template = env.get_template(&#39;run_static.py.inc&#39;)

    name_absolute = os.path.abspath(name)
    real_f = name_absolute + PROJECT_BIN_F_EXT
    if sprefix:
        mv_ = run.watch(uchroot()[&#34;/bin/mv&#34;])
        mv_(strip_path_prefix(name_absolute, sprefix),
            strip_path_prefix(real_f, sprefix))
    else:
        mv_ = run.watch(mv)
        mv(name_absolute, real_f)

    project_file = persist(project, suffix=&#34;.project&#34;)

    env = CFG[&#39;env&#39;].value

    bin_path = list_to_path(env.get(&#39;PATH&#39;, []))
    bin_path = list_to_path([bin_path, os.environ[&#34;PATH&#34;]])

    bin_lib_path = list_to_path(env.get(&#39;LD_LIBRARY_PATH&#39;, []))
    bin_lib_path = list_to_path([bin_lib_path, os.environ[&#34;LD_LIBRARY_PATH&#34;]])
    home = env.get(&#34;HOME&#34;, os.getenv(&#34;HOME&#34;, &#34;&#34;))

    with open(name_absolute, &#39;w&#39;) as wrapper:
        wrapper.write(
            template.render(
                runf=strip_path_prefix(real_f, sprefix),
                project_file=strip_path_prefix(project_file, sprefix),
                path=str(bin_path),
                ld_library_path=str(bin_lib_path),
                home=str(home),
                python=python,
            ))

    chmod_ = run.watch(chmod)
    chmod_(&#34;+x&#34;, name_absolute)
    return local[name_absolute]</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.wrapping.wrap_cc"><code class="name flex">
<span>def <span class="ident">wrap_cc</span></span>(<span>filepath, compiler, project, python='/home/simbuerg/src/polyjit/benchbuild/.tox/docs/bin/python', detect_project=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Substitute a compiler with a script that hides CFLAGS &amp; LDFLAGS.</p>
<p>This will generate a wrapper script in the current directory
and return a complete plumbum command to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the wrapper script.</dd>
<dt>compiler (benchbuild.utils.cmd):</dt>
<dt>Real compiler command we should call in the script.</dt>
<dt>project (benchbuild.project.Project):</dt>
<dt>The project this compiler will be for.</dt>
<dt><strong><code>python</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the python interpreter we should use.</dd>
<dt><strong><code>detect_project</code></strong></dt>
<dd>Should we enable project detection or not.</dd>
</dl>
<p>Returns (benchbuild.utils.cmd):
Command of the new compiler we can call.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_cc(filepath,
            compiler,
            project,
            python=sys.executable,
            detect_project=False):
    &#34;&#34;&#34;
    Substitute a compiler with a script that hides CFLAGS &amp; LDFLAGS.

    This will generate a wrapper script in the current directory
    and return a complete plumbum command to it.

    Args:
        filepath (str): Path to the wrapper script.
        compiler (benchbuild.utils.cmd):
            Real compiler command we should call in the script.
        project (benchbuild.project.Project):
            The project this compiler will be for.
        python (str): Path to the python interpreter we should use.
        detect_project: Should we enable project detection or not.

    Returns (benchbuild.utils.cmd):
        Command of the new compiler we can call.
    &#34;&#34;&#34;
    env = __create_jinja_env()
    template = env.get_template(&#39;run_compiler.py.inc&#39;)

    cc_fname = local.path(filepath).with_suffix(&#34;.benchbuild.cc&#34;, depth=0)
    cc_f = persist(compiler, filename=cc_fname)

    project_file = persist(project, suffix=&#34;.project&#34;)

    with open(filepath, &#39;w&#39;) as wrapper:
        wrapper.write(
            template.render(cc_f=cc_f,
                            project_file=project_file,
                            python=python,
                            detect_project=detect_project))

    chmod(&#34;+x&#34;, filepath)
    LOG.debug(&#34;Placed wrapper in: %s for compiler %s&#34;, local.path(filepath),
              str(compiler))
    LOG.debug(&#34;Placed project in: %s&#34;, local.path(project_file))
    LOG.debug(&#34;Placed compiler command in: %s&#34;, local.path(cc_f))
    return local[filepath]</code></pre>
</details>
</dd>
<dt id="benchbuild.utils.wrapping.wrap_dynamic"><code class="name flex">
<span>def <span class="ident">wrap_dynamic</span></span>(<span>project, name, sprefix=None, python='/home/simbuerg/src/polyjit/benchbuild/.tox/docs/bin/python', name_filters=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Wrap the binary :name with the function :runner.</p>
<p>This module generates a python tool :name: that can replace
a yet unspecified binary.
It behaves similar to the :wrap: function. However, the first
argument is the actual binary name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>name of the python module</dd>
<dt><strong><code>runner</code></strong></dt>
<dd>Function that should run the real binary</dd>
<dt><strong><code>sprefix</code></strong></dt>
<dd>Prefix that should be used for commands.</dd>
<dt><strong><code>python</code></strong></dt>
<dd>The python executable that should be used.</dd>
</dl>
<p>name_filters:
List of regex expressions that are used to filter the
real project name. Make sure to include a match group named
'name' in the regex, e.g.,
[
r'foo(?P<name>.)-flt'
]
Returns: plumbum command, readty to launch.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_dynamic(project,
                 name,
                 sprefix=None,
                 python=sys.executable,
                 name_filters=None):
    &#34;&#34;&#34;
    Wrap the binary :name with the function :runner.

    This module generates a python tool :name: that can replace
    a yet unspecified binary.
    It behaves similar to the :wrap: function. However, the first
    argument is the actual binary name.

    Args:
        name: name of the python module
        runner: Function that should run the real binary
        sprefix: Prefix that should be used for commands.
        python: The python executable that should be used.
        name_filters:
            List of regex expressions that are used to filter the
            real project name. Make sure to include a match group named
            &#39;name&#39; in the regex, e.g.,
            [
                r&#39;foo(?P&lt;name&gt;.)-flt&#39;
            ]

    Returns: plumbum command, readty to launch.

    &#34;&#34;&#34;
    env = __create_jinja_env()
    template = env.get_template(&#39;run_dynamic.py.inc&#39;)

    name_absolute = os.path.abspath(name)
    real_f = name_absolute + PROJECT_BIN_F_EXT

    project_file = persist(project, suffix=&#34;.project&#34;)

    env = CFG[&#39;env&#39;].value

    bin_path = list_to_path(env.get(&#39;PATH&#39;, []))
    bin_path = list_to_path([bin_path, os.environ[&#34;PATH&#34;]])

    bin_lib_path = \
        list_to_path(env.get(&#39;LD_LIBRARY_PATH&#39;, []))
    bin_lib_path = \
        list_to_path([bin_lib_path, os.environ[&#34;LD_LIBRARY_PATH&#34;]])
    home = env.get(&#34;HOME&#34;, os.getenv(&#34;HOME&#34;, &#34;&#34;))

    with open(name_absolute, &#39;w&#39;) as wrapper:
        wrapper.write(
            template.render(runf=strip_path_prefix(real_f, sprefix),
                            project_file=strip_path_prefix(
                                project_file, sprefix),
                            path=str(bin_path),
                            ld_library_path=str(bin_lib_path),
                            home=str(home),
                            python=python,
                            name_filters=name_filters))

    chmod(&#34;+x&#34;, name_absolute)
    return local[name_absolute]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="benchbuild.utils" href="index.html">benchbuild.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="benchbuild.utils.wrapping.load" href="#benchbuild.utils.wrapping.load">load</a></code></li>
<li><code><a title="benchbuild.utils.wrapping.persist" href="#benchbuild.utils.wrapping.persist">persist</a></code></li>
<li><code><a title="benchbuild.utils.wrapping.strip_path_prefix" href="#benchbuild.utils.wrapping.strip_path_prefix">strip_path_prefix</a></code></li>
<li><code><a title="benchbuild.utils.wrapping.unpickle" href="#benchbuild.utils.wrapping.unpickle">unpickle</a></code></li>
<li><code><a title="benchbuild.utils.wrapping.wrap" href="#benchbuild.utils.wrapping.wrap">wrap</a></code></li>
<li><code><a title="benchbuild.utils.wrapping.wrap_cc" href="#benchbuild.utils.wrapping.wrap_cc">wrap_cc</a></code></li>
<li><code><a title="benchbuild.utils.wrapping.wrap_dynamic" href="#benchbuild.utils.wrapping.wrap_dynamic">wrap_dynamic</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
