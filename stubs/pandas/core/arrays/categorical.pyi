import numpy as np
from pandas._typing import ArrayLike as ArrayLike, Dtype as Dtype, Ordered as Ordered, Scalar as Scalar
from pandas.core.accessor import PandasDelegate
from pandas.core.arrays.base import ExtensionArray
from pandas.core.base import NoNewAttributesMixin, PandasObject
from pandas.core.dtypes.dtypes import CategoricalDtype
from typing import Any, List, Optional

def contains(cat: Any, key: Any, container: Any): ...

class Categorical(ExtensionArray, PandasObject):
    __array_priority__: int = ...
    def __init__(self, values: Any, categories: Optional[Any] = ..., ordered: Optional[Any] = ..., dtype: Optional[Any] = ..., fastpath: bool = ...) -> None: ...
    @property
    def categories(self): ...
    @categories.setter
    def categories(self, categories: Any) -> None: ...
    @property
    def ordered(self) -> Ordered: ...
    @property
    def dtype(self) -> CategoricalDtype: ...
    def copy(self) -> Categorical: ...
    def astype(self, dtype: Dtype, copy: bool=...) -> ArrayLike: ...
    def size(self) -> int: ...
    def itemsize(self) -> int: ...
    def tolist(self) -> List[Scalar]: ...
    to_list: Any = ...
    @classmethod
    def from_codes(cls, codes: Any, categories: Optional[Any] = ..., ordered: Optional[Any] = ..., dtype: Optional[Any] = ...): ...
    codes: Any = ...
    def set_ordered(self, value: Any, inplace: bool = ...): ...
    def as_ordered(self, inplace: bool = ...): ...
    def as_unordered(self, inplace: bool = ...): ...
    def set_categories(self, new_categories: Any, ordered: Optional[Any] = ..., rename: bool = ..., inplace: bool = ...): ...
    def rename_categories(self, new_categories: Any, inplace: bool = ...): ...
    def reorder_categories(self, new_categories: Any, ordered: Optional[Any] = ..., inplace: bool = ...): ...
    def add_categories(self, new_categories: Any, inplace: bool = ...): ...
    def remove_categories(self, removals: Any, inplace: bool = ...): ...
    def remove_unused_categories(self, inplace: bool = ...): ...
    def map(self, mapper: Any): ...
    __eq__: Any = ...
    __ne__: Any = ...
    __lt__: Any = ...
    __gt__: Any = ...
    __le__: Any = ...
    __ge__: Any = ...
    @property
    def shape(self): ...
    def shift(self, periods: Any, fill_value: Optional[Any] = ...): ...
    def __array__(self, dtype: Any=...) -> np.ndarray: ...
    def __array_ufunc__(self, ufunc: Any, method: Any, *inputs: Any, **kwargs: Any): ...
    @property
    def T(self): ...
    @property
    def nbytes(self): ...
    def memory_usage(self, deep: bool = ...): ...
    def searchsorted(self, value: Any, side: str = ..., sorter: Optional[Any] = ...): ...
    def isna(self): ...
    isnull: Any = ...
    def notna(self): ...
    notnull: Any = ...
    def put(self, *args: Any, **kwargs: Any) -> None: ...
    def dropna(self): ...
    def value_counts(self, dropna: bool = ...): ...
    def check_for_ordered(self, op: Any) -> None: ...
    def argsort(self, ascending: bool = ..., kind: str = ..., *args: Any, **kwargs: Any): ...
    def sort_values(self, inplace: bool = ..., ascending: bool = ..., na_position: str = ...): ...
    def view(self, dtype: Optional[Any] = ...): ...
    def to_dense(self): ...
    def fillna(self, value: Optional[Any] = ..., method: Optional[Any] = ..., limit: Optional[Any] = ...): ...
    def take(self, indexer: Any, allow_fill: bool=..., fill_value: Any=...) -> Any: ...
    def take_nd(self, indexer: Any, allow_fill: bool=..., fill_value: Any=...) -> Any: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Any: ...
    def __contains__(self, key: Any) -> bool: ...
    def __getitem__(self, key: Any): ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def min(self, skipna: bool = ..., **kwargs: Any): ...
    def max(self, skipna: bool = ..., **kwargs: Any): ...
    def mode(self, dropna: bool = ...): ...
    def unique(self): ...
    def equals(self, other: Any): ...
    def is_dtype_equal(self, other: Any): ...
    def describe(self): ...
    def repeat(self, repeats: Any, axis: Optional[Any] = ...): ...
    def isin(self, values: Any): ...
    def replace(self, to_replace: Any, value: Any, inplace: bool=...) -> Any: ...

class CategoricalAccessor(PandasDelegate, PandasObject, NoNewAttributesMixin):
    def __init__(self, data: Any) -> None: ...
    @property
    def codes(self): ...

def factorize_from_iterable(values: Any): ...
def factorize_from_iterables(iterables: Any): ...
