import numpy as np
from pandas.core.indexes.numeric import Int64Index
from typing import Any, Optional, Union

class RangeIndex(Int64Index):
    def __new__(cls, start: Optional[Any] = ..., stop: Optional[Any] = ..., step: Optional[Any] = ..., dtype: Optional[Any] = ..., copy: bool = ..., name: Optional[Any] = ...): ...
    @classmethod
    def from_range(cls, data: Any, name: Optional[Any] = ..., dtype: Optional[Any] = ...): ...
    def __reduce__(self): ...
    def start(self): ...
    def stop(self): ...
    def step(self): ...
    def nbytes(self) -> int: ...
    def memory_usage(self, deep: bool=...) -> int: ...
    @property
    def dtype(self) -> np.dtype: ...
    @property
    def is_unique(self) -> bool: ...
    def is_monotonic_increasing(self) -> bool: ...
    def is_monotonic_decreasing(self) -> bool: ...
    @property
    def has_duplicates(self) -> bool: ...
    def __contains__(self, key: Union[int, np.integer]) -> bool: ...
    def get_loc(self, key: Any, method: Optional[Any] = ..., tolerance: Optional[Any] = ...): ...
    def get_indexer(self, target: Any, method: Optional[Any] = ..., limit: Optional[Any] = ..., tolerance: Optional[Any] = ...): ...
    def tolist(self): ...
    def copy(self, name: Optional[Any] = ..., deep: bool = ..., dtype: Optional[Any] = ..., **kwargs: Any): ...
    def min(self, axis: Optional[Any] = ..., skipna: bool = ..., *args: Any, **kwargs: Any): ...
    def max(self, axis: Optional[Any] = ..., skipna: bool = ..., *args: Any, **kwargs: Any): ...
    def argsort(self, *args: Any, **kwargs: Any): ...
    def equals(self, other: Any): ...
    def intersection(self, other: Any, sort: bool = ...): ...
    def join(self, other: Any, how: str = ..., level: Optional[Any] = ..., return_indexers: bool = ..., sort: bool = ...): ...
    def __len__(self) -> int: ...
    @property
    def size(self) -> int: ...
    def __getitem__(self, key: Any): ...
    def __floordiv__(self, other: Any): ...
    def all(self) -> bool: ...
    def any(self) -> bool: ...
