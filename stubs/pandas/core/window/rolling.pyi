from pandas._typing import Axis as Axis, FrameOrSeries as FrameOrSeries, Scalar as Scalar
from pandas.core.base import PandasObject, SelectionMixin, ShallowMixin
from pandas.core.indexes.api import Index
from pandas.core.window.common import WindowGroupByMixin
from typing import Any, Dict, Optional, Set, Tuple, Union

class _Window(PandasObject, ShallowMixin, SelectionMixin):
    exclusions: Set[str] = ...
    obj: Any = ...
    on: Any = ...
    closed: Any = ...
    window: Any = ...
    min_periods: Any = ...
    center: Any = ...
    win_type: Any = ...
    win_freq: Any = ...
    axis: Any = ...
    def __init__(self, obj: Any, window: Any=..., min_periods: Optional[int]=..., center: Optional[bool]=..., win_type: Optional[str]=..., axis: Axis=..., on: Optional[Union[str, Index]]=..., closed: Optional[str]=..., **kwargs: Any) -> None: ...
    @property
    def is_datetimelike(self) -> Optional[bool]: ...
    @property
    def is_freq_type(self) -> bool: ...
    def validate(self) -> None: ...
    def __getattr__(self, attr: str) -> Any: ...
    def __iter__(self) -> Any: ...
    def aggregate(self, func: Any, *args: Any, **kwargs: Any): ...
    agg: Any = ...

class Window(_Window):
    def validate(self) -> None: ...
    def aggregate(self, func: Any, *args: Any, **kwargs: Any): ...
    agg: Any = ...
    def sum(self, *args: Any, **kwargs: Any): ...
    def mean(self, *args: Any, **kwargs: Any): ...
    def var(self, ddof: int = ..., *args: Any, **kwargs: Any): ...
    def std(self, ddof: int = ..., *args: Any, **kwargs: Any): ...

class _Rolling(_Window): ...

class _Rolling_and_Expanding(_Rolling):
    def count(self): ...
    def apply(self, func: Any, raw: bool=..., engine: str=..., engine_kwargs: Optional[Dict]=..., args: Optional[Tuple]=..., kwargs: Optional[Dict]=...) -> Any: ...
    def sum(self, *args: Any, **kwargs: Any): ...
    def max(self, *args: Any, **kwargs: Any): ...
    def min(self, *args: Any, **kwargs: Any): ...
    def mean(self, *args: Any, **kwargs: Any): ...
    def median(self, **kwargs: Any): ...
    def std(self, ddof: int = ..., *args: Any, **kwargs: Any): ...
    def var(self, ddof: int = ..., *args: Any, **kwargs: Any): ...
    def skew(self, **kwargs: Any): ...
    def kurt(self, **kwargs: Any): ...
    def quantile(self, quantile: Any, interpolation: str = ..., **kwargs: Any): ...
    def cov(self, other: Optional[Any] = ..., pairwise: Optional[Any] = ..., ddof: int = ..., **kwargs: Any): ...
    def corr(self, other: Optional[Any] = ..., pairwise: Optional[Any] = ..., **kwargs: Any): ...

class Rolling(_Rolling_and_Expanding):
    def is_datetimelike(self) -> bool: ...
    win_freq: Any = ...
    window: Any = ...
    win_type: str = ...
    min_periods: int = ...
    def validate(self) -> None: ...
    def aggregate(self, func: Any, *args: Any, **kwargs: Any): ...
    agg: Any = ...
    def count(self): ...
    def apply(self, func: Any, raw: bool = ..., engine: str = ..., engine_kwargs: Optional[Any] = ..., args: Optional[Any] = ..., kwargs: Optional[Any] = ...): ...
    def sum(self, *args: Any, **kwargs: Any): ...
    def max(self, *args: Any, **kwargs: Any): ...
    def min(self, *args: Any, **kwargs: Any): ...
    def mean(self, *args: Any, **kwargs: Any): ...
    def median(self, **kwargs: Any): ...
    def std(self, ddof: int = ..., *args: Any, **kwargs: Any): ...
    def var(self, ddof: int = ..., *args: Any, **kwargs: Any): ...
    def skew(self, **kwargs: Any): ...
    def kurt(self, **kwargs: Any): ...
    def quantile(self, quantile: Any, interpolation: str = ..., **kwargs: Any): ...
    def cov(self, other: Optional[Any] = ..., pairwise: Optional[Any] = ..., ddof: int = ..., **kwargs: Any): ...
    def corr(self, other: Optional[Any] = ..., pairwise: Optional[Any] = ..., **kwargs: Any): ...

class RollingGroupby(WindowGroupByMixin, Rolling): ...
