from itertools import chain as chain
from logging import DEBUG as DEBUG, INFO as INFO
from typing import Any, Optional

class Future:
    proc: Any = ...
    def __init__(self, proc: Any, expected_retcode: Any, timeout: Optional[Any] = ...) -> None: ...
    def poll(self): ...
    ready: Any = ...
    def wait(self) -> None: ...
    @property
    def stdout(self): ...
    @property
    def stderr(self): ...
    @property
    def returncode(self): ...

class ExecutionModifier:
    @classmethod
    def __call__(cls, *args: Any, **kwargs: Any): ...

class _BG(ExecutionModifier):
    retcode: Any = ...
    kargs: Any = ...
    timeout: Any = ...
    def __init__(self, retcode: int = ..., timeout: Optional[Any] = ..., **kargs: Any) -> None: ...
    def __rand__(self, cmd: Any): ...

BG: Any

class _FG(ExecutionModifier):
    retcode: Any = ...
    timeout: Any = ...
    def __init__(self, retcode: int = ..., timeout: Optional[Any] = ...) -> None: ...
    def __rand__(self, cmd: Any) -> None: ...

FG: Any

class _TEE(ExecutionModifier):
    retcode: Any = ...
    buffered: Any = ...
    timeout: Any = ...
    def __init__(self, retcode: int = ..., buffered: bool = ..., timeout: Optional[Any] = ...) -> None: ...
    def __rand__(self, cmd: Any): ...

TEE: Any

class _TF(ExecutionModifier):
    retcode: Any = ...
    FG: Any = ...
    timeout: Any = ...
    def __init__(self, retcode: int = ..., FG: bool = ..., timeout: Optional[Any] = ...) -> None: ...
    @classmethod
    def __call__(cls, *args: Any, **kwargs: Any): ...
    def __rand__(self, cmd: Any): ...

TF: Any

class _RETCODE(ExecutionModifier):
    foreground: Any = ...
    timeout: Any = ...
    def __init__(self, FG: bool = ..., timeout: Optional[Any] = ...) -> None: ...
    @classmethod
    def __call__(cls, *args: Any, **kwargs: Any): ...
    def __rand__(self, cmd: Any): ...

RETCODE: Any

class _NOHUP(ExecutionModifier):
    cwd: Any = ...
    stdout: Any = ...
    stderr: Any = ...
    append: Any = ...
    def __init__(self, cwd: str = ..., stdout: str = ..., stderr: Optional[Any] = ..., append: bool = ...) -> None: ...
    def __rand__(self, cmd: Any): ...

NOHUP: Any

class PipeToLoggerMixin:
    DEFAULT_LINE_TIMEOUT: Any = ...
    DEFAULT_STDOUT: str = ...
    DEFAULT_STDERR: str = ...
    def pipe(self, out_level: Optional[Any] = ..., err_level: Optional[Any] = ..., prefix: Optional[Any] = ..., line_timeout: Optional[Any] = ..., **kw: Any): ...
    def pipe_info(self, prefix: Optional[Any] = ..., **kw: Any): ...
    def pipe_debug(self, prefix: Optional[Any] = ..., **kw: Any): ...
    def __rand__(self, cmd: Any): ...
