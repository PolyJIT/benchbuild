import re as re
from typing import Any, Optional as _Optional

__versionTime__: str

class SimpleNamespace: ...

__compat__: Any
__diag__: Any
basestring = str
unichr = chr
unicode = str
range = xrange
alphas: Any
nums: str
hexnums: Any
alphanums: Any
printables: Any

def conditionAsParseAction(fn: Any, message: _Optional[Any] = ..., fatal: bool = ...): ...

class ParseBaseException(Exception):
    loc: Any = ...
    msg: Any = ...
    pstr: str = ...
    parserElement: Any = ...
    args: Any = ...
    def __init__(self, pstr: Any, loc: int = ..., msg: _Optional[Any] = ..., elem: _Optional[Any] = ...) -> None: ...
    def __getattr__(self, aname: Any): ...
    def markInputline(self, markerString: str = ...): ...
    def __dir__(self): ...

class ParseException(ParseBaseException):
    @staticmethod
    def explain(exc: Any, depth: int = ...): ...

class ParseFatalException(ParseBaseException): ...
class ParseSyntaxException(ParseFatalException): ...

class RecursiveGrammarException(Exception):
    parseElementTrace: Any = ...
    def __init__(self, parseElementList: Any) -> None: ...

class _ParseResultsWithOffset:
    tup: Any = ...
    def __init__(self, p1: Any, p2: Any) -> None: ...
    def __getitem__(self, i: Any): ...
    def setOffset(self, i: Any) -> None: ...

class ParseResults:
    def __new__(cls, toklist: _Optional[Any] = ..., name: _Optional[Any] = ..., asList: bool = ..., modal: bool = ...): ...
    def __init__(self, toklist: _Optional[Any] = ..., name: _Optional[Any] = ..., asList: bool = ..., modal: bool = ..., isinstance: Any = ...) -> None: ...
    def __getitem__(self, i: Any): ...
    def __setitem__(self, k: Any, v: Any, isinstance: Any = ...) -> None: ...
    def __delitem__(self, i: Any) -> None: ...
    def __contains__(self, k: Any): ...
    def __len__(self): ...
    def __bool__(self): ...
    __nonzero__: Any = ...
    def __iter__(self) -> Any: ...
    def __reversed__(self): ...
    keys: Any = ...
    values: Any = ...
    items: Any = ...
    iterkeys: Any = ...
    itervalues: Any = ...
    iteritems: Any = ...
    def keys(self): ...
    def values(self): ...
    def items(self): ...
    def haskeys(self): ...
    def pop(self, *args: Any, **kwargs: Any): ...
    def get(self, key: Any, defaultValue: _Optional[Any] = ...): ...
    def insert(self, index: Any, insStr: Any) -> None: ...
    def append(self, item: Any) -> None: ...
    def extend(self, itemseq: Any) -> None: ...
    def clear(self) -> None: ...
    def __getattr__(self, name: Any): ...
    def __add__(self, other: Any): ...
    def __iadd__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def asList(self): ...
    def asDict(self): ...
    def copy(self): ...
    def asXML(self, doctag: _Optional[Any] = ..., namedItemsOnly: bool = ..., indent: str = ..., formatted: bool = ...): ...
    def getName(self): ...
    def dump(self, indent: str = ..., full: bool = ..., include_list: bool = ..., _depth: int = ...): ...
    def pprint(self, *args: Any, **kwargs: Any) -> None: ...
    def __getnewargs__(self): ...
    def __dir__(self): ...
    @classmethod
    def from_dict(cls, other: Any, name: _Optional[Any] = ...): ...

def col(loc: Any, strg: Any): ...
def lineno(loc: Any, strg: Any): ...
def line(loc: Any, strg: Any): ...
def nullDebugAction(*args: Any) -> None: ...

class ParserElement:
    DEFAULT_WHITE_CHARS: str = ...
    verbose_stacktrace: bool = ...
    @staticmethod
    def setDefaultWhitespaceChars(chars: Any) -> None: ...
    @staticmethod
    def inlineLiteralsUsing(cls) -> None: ...
    parseAction: Any = ...
    failAction: Any = ...
    strRepr: Any = ...
    resultsName: Any = ...
    saveAsList: Any = ...
    skipWhitespace: bool = ...
    whiteChars: Any = ...
    copyDefaultWhiteChars: bool = ...
    mayReturnEmpty: bool = ...
    keepTabs: bool = ...
    ignoreExprs: Any = ...
    debug: bool = ...
    streamlined: bool = ...
    mayIndexError: bool = ...
    errmsg: str = ...
    modalResults: bool = ...
    debugActions: Any = ...
    re: Any = ...
    callPreparse: bool = ...
    callDuringTry: bool = ...
    def __init__(self, savelist: bool = ...) -> None: ...
    def copy(self): ...
    name: Any = ...
    def setName(self, name: Any): ...
    def setResultsName(self, name: Any, listAllMatches: bool = ...): ...
    def setBreak(self, breakFlag: bool = ...): ...
    def setParseAction(self, *fns: Any, **kwargs: Any): ...
    def addParseAction(self, *fns: Any, **kwargs: Any): ...
    def addCondition(self, *fns: Any, **kwargs: Any): ...
    def setFailAction(self, fn: Any): ...
    def preParse(self, instring: Any, loc: Any): ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...
    def postParse(self, instring: Any, loc: Any, tokenlist: Any): ...
    def tryParse(self, instring: Any, loc: Any): ...
    def canParseNext(self, instring: Any, loc: Any): ...
    class _UnboundedCache:
        not_in_cache: Any = ...
        get: Any = ...
        set: Any = ...
        clear: Any = ...
        __len__: Any = ...
        def __init__(self): ...
    class _FifoCache:
        not_in_cache: Any = ...
        get: Any = ...
        set: Any = ...
        clear: Any = ...
        __len__: Any = ...
        def __init__(self, size: Any): ...
    class _FifoCache:
        not_in_cache: Any = ...
        get: Any = ...
        set: Any = ...
        clear: Any = ...
        __len__: Any = ...
        def __init__(self, size: Any): ...
    packrat_cache: Any = ...
    packrat_cache_lock: Any = ...
    packrat_cache_stats: Any = ...
    @staticmethod
    def resetCache() -> None: ...
    @staticmethod
    def enablePackrat(cache_size_limit: int = ...) -> None: ...
    def parseString(self, instring: Any, parseAll: bool = ...): ...
    def scanString(self, instring: Any, maxMatches: Any = ..., overlap: bool = ...) -> None: ...
    def transformString(self, instring: Any): ...
    def searchString(self, instring: Any, maxMatches: Any = ...): ...
    def split(self, instring: Any, maxsplit: Any = ..., includeSeparators: bool = ...) -> None: ...
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def __sub__(self, other: Any): ...
    def __rsub__(self, other: Any): ...
    def __mul__(self, other: Any): ...
    def __rmul__(self, other: Any): ...
    def __or__(self, other: Any): ...
    def __ror__(self, other: Any): ...
    def __xor__(self, other: Any): ...
    def __rxor__(self, other: Any): ...
    def __and__(self, other: Any): ...
    def __rand__(self, other: Any): ...
    def __invert__(self): ...
    def __iter__(self) -> Any: ...
    def __getitem__(self, key: Any): ...
    def __call__(self, name: _Optional[Any] = ...): ...
    def suppress(self): ...
    def leaveWhitespace(self): ...
    def setWhitespaceChars(self, chars: Any): ...
    def parseWithTabs(self): ...
    def ignore(self, other: Any): ...
    def setDebugActions(self, startAction: Any, successAction: Any, exceptionAction: Any): ...
    def setDebug(self, flag: bool = ...): ...
    def streamline(self): ...
    def checkRecursion(self, parseElementList: Any) -> None: ...
    def validate(self, validateTrace: _Optional[Any] = ...) -> None: ...
    def parseFile(self, file_or_filename: Any, parseAll: bool = ...): ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def __hash__(self) -> Any: ...
    def __req__(self, other: Any): ...
    def __rne__(self, other: Any): ...
    def matches(self, testString: Any, parseAll: bool = ...): ...
    def runTests(self, tests: Any, parseAll: bool = ..., comment: str = ..., fullDump: bool = ..., printResults: bool = ..., failureTests: bool = ..., postParse: _Optional[Any] = ..., file: _Optional[Any] = ...): ...

class _PendingSkip(ParserElement):
    strRepr: Any = ...
    name: Any = ...
    anchor: Any = ...
    must_skip: Any = ...
    def __init__(self, expr: Any, must_skip: bool = ...) -> None: ...
    def __add__(self, other: Any): ...
    def parseImpl(self, *args: Any) -> None: ...

class Token(ParserElement):
    def __init__(self) -> None: ...

class Empty(Token):
    name: str = ...
    mayReturnEmpty: bool = ...
    mayIndexError: bool = ...
    def __init__(self) -> None: ...

class NoMatch(Token):
    name: str = ...
    mayReturnEmpty: bool = ...
    mayIndexError: bool = ...
    errmsg: str = ...
    def __init__(self) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...) -> None: ...

class Literal(Token):
    match: Any = ...
    matchLen: Any = ...
    firstMatchChar: Any = ...
    __class__: Any = ...
    name: Any = ...
    errmsg: Any = ...
    mayReturnEmpty: bool = ...
    mayIndexError: bool = ...
    def __init__(self, matchString: Any) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class _SingleCharLiteral(Literal):
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class Keyword(Token):
    DEFAULT_KEYWORD_CHARS: Any = ...
    match: Any = ...
    matchLen: Any = ...
    firstMatchChar: Any = ...
    name: Any = ...
    errmsg: Any = ...
    mayReturnEmpty: bool = ...
    mayIndexError: bool = ...
    caseless: Any = ...
    caselessmatch: Any = ...
    identChars: Any = ...
    def __init__(self, matchString: Any, identChars: _Optional[Any] = ..., caseless: bool = ...) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...
    def copy(self): ...
    @staticmethod
    def setDefaultKeywordChars(chars: Any) -> None: ...

class CaselessLiteral(Literal):
    returnString: Any = ...
    name: Any = ...
    errmsg: Any = ...
    def __init__(self, matchString: Any) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class CaselessKeyword(Keyword):
    def __init__(self, matchString: Any, identChars: _Optional[Any] = ...) -> None: ...

class CloseMatch(Token):
    name: Any = ...
    match_string: Any = ...
    maxMismatches: Any = ...
    errmsg: Any = ...
    mayIndexError: bool = ...
    mayReturnEmpty: bool = ...
    def __init__(self, match_string: Any, maxMismatches: int = ...) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class Word(Token):
    initCharsOrig: Any = ...
    initChars: Any = ...
    bodyCharsOrig: Any = ...
    bodyChars: Any = ...
    maxSpecified: Any = ...
    minLen: Any = ...
    maxLen: Any = ...
    name: Any = ...
    errmsg: Any = ...
    mayIndexError: bool = ...
    asKeyword: Any = ...
    reString: Any = ...
    re: Any = ...
    re_match: Any = ...
    __class__: Any = ...
    def __init__(self, initChars: Any, bodyChars: _Optional[Any] = ..., min: int = ..., max: int = ..., exact: int = ..., asKeyword: bool = ..., excludeChars: _Optional[Any] = ...) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class _WordRegex(Word):
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class Char(_WordRegex):
    reString: Any = ...
    re: Any = ...
    re_match: Any = ...
    def __init__(self, charset: Any, asKeyword: bool = ..., excludeChars: _Optional[Any] = ...) -> None: ...

class Regex(Token):
    pattern: Any = ...
    flags: Any = ...
    re: Any = ...
    reString: Any = ...
    re_match: Any = ...
    name: Any = ...
    errmsg: Any = ...
    mayIndexError: bool = ...
    mayReturnEmpty: Any = ...
    asGroupList: Any = ...
    asMatch: Any = ...
    def __init__(self, pattern: Any, flags: int = ..., asGroupList: bool = ..., asMatch: bool = ...) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...
    def parseImplAsGroupList(self, instring: Any, loc: Any, doActions: bool = ...): ...
    def parseImplAsMatch(self, instring: Any, loc: Any, doActions: bool = ...): ...
    def sub(self, repl: Any): ...

class QuotedString(Token):
    quoteChar: Any = ...
    quoteCharLen: Any = ...
    firstQuoteChar: Any = ...
    endQuoteChar: Any = ...
    endQuoteCharLen: Any = ...
    escChar: Any = ...
    escQuote: Any = ...
    unquoteResults: Any = ...
    convertWhitespaceEscapes: Any = ...
    flags: Any = ...
    pattern: Any = ...
    escCharReplacePattern: Any = ...
    re: Any = ...
    reString: Any = ...
    re_match: Any = ...
    name: Any = ...
    errmsg: Any = ...
    mayIndexError: bool = ...
    mayReturnEmpty: bool = ...
    def __init__(self, quoteChar: Any, escChar: _Optional[Any] = ..., escQuote: _Optional[Any] = ..., multiline: bool = ..., unquoteResults: bool = ..., endQuoteChar: _Optional[Any] = ..., convertWhitespaceEscapes: bool = ...) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class CharsNotIn(Token):
    skipWhitespace: bool = ...
    notChars: Any = ...
    minLen: Any = ...
    maxLen: Any = ...
    name: Any = ...
    errmsg: Any = ...
    mayReturnEmpty: Any = ...
    mayIndexError: bool = ...
    def __init__(self, notChars: Any, min: int = ..., max: int = ..., exact: int = ...) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class White(Token):
    whiteStrs: Any = ...
    matchWhite: Any = ...
    name: Any = ...
    mayReturnEmpty: bool = ...
    errmsg: Any = ...
    minLen: Any = ...
    maxLen: Any = ...
    def __init__(self, ws: str = ..., min: int = ..., max: int = ..., exact: int = ...) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class _PositionToken(Token):
    name: Any = ...
    mayReturnEmpty: bool = ...
    mayIndexError: bool = ...
    def __init__(self) -> None: ...

class GoToColumn(_PositionToken):
    col: Any = ...
    def __init__(self, colno: Any) -> None: ...
    def preParse(self, instring: Any, loc: Any): ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class LineStart(_PositionToken):
    errmsg: str = ...
    def __init__(self) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class LineEnd(_PositionToken):
    errmsg: str = ...
    def __init__(self) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class StringStart(_PositionToken):
    errmsg: str = ...
    def __init__(self) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class StringEnd(_PositionToken):
    errmsg: str = ...
    def __init__(self) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class WordStart(_PositionToken):
    wordChars: Any = ...
    errmsg: str = ...
    def __init__(self, wordChars: Any = ...) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class WordEnd(_PositionToken):
    wordChars: Any = ...
    skipWhitespace: bool = ...
    errmsg: str = ...
    def __init__(self, wordChars: Any = ...) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class ParseExpression(ParserElement):
    exprs: Any = ...
    callPreparse: bool = ...
    def __init__(self, exprs: Any, savelist: bool = ...) -> None: ...
    strRepr: Any = ...
    def append(self, other: Any): ...
    skipWhitespace: bool = ...
    def leaveWhitespace(self): ...
    def ignore(self, other: Any): ...
    errmsg: Any = ...
    def streamline(self): ...
    def validate(self, validateTrace: _Optional[Any] = ...) -> None: ...
    def copy(self): ...

class And(ParseExpression):
    class _ErrorStop(Empty):
        name: str = ...
        def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    mayReturnEmpty: Any = ...
    skipWhitespace: Any = ...
    callPreparse: bool = ...
    def __init__(self, exprs: Any, savelist: bool = ...) -> None: ...
    exprs: Any = ...
    def streamline(self): ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...
    def __iadd__(self, other: Any): ...
    def checkRecursion(self, parseElementList: Any) -> None: ...

class Or(ParseExpression):
    mayReturnEmpty: Any = ...
    def __init__(self, exprs: Any, savelist: bool = ...) -> None: ...
    saveAsList: Any = ...
    def streamline(self): ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...
    def __ixor__(self, other: Any): ...
    def checkRecursion(self, parseElementList: Any) -> None: ...

class MatchFirst(ParseExpression):
    mayReturnEmpty: Any = ...
    def __init__(self, exprs: Any, savelist: bool = ...) -> None: ...
    saveAsList: Any = ...
    def streamline(self): ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...
    def __ior__(self, other: Any): ...
    def checkRecursion(self, parseElementList: Any) -> None: ...

class Each(ParseExpression):
    mayReturnEmpty: Any = ...
    skipWhitespace: bool = ...
    initExprGroups: bool = ...
    saveAsList: bool = ...
    def __init__(self, exprs: Any, savelist: bool = ...) -> None: ...
    def streamline(self): ...
    opt1map: Any = ...
    optionals: Any = ...
    multioptionals: Any = ...
    multirequired: Any = ...
    required: Any = ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...
    def checkRecursion(self, parseElementList: Any) -> None: ...

class ParseElementEnhance(ParserElement):
    expr: Any = ...
    strRepr: Any = ...
    mayIndexError: Any = ...
    mayReturnEmpty: Any = ...
    skipWhitespace: Any = ...
    saveAsList: Any = ...
    callPreparse: Any = ...
    def __init__(self, expr: Any, savelist: bool = ...) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...
    def leaveWhitespace(self): ...
    def ignore(self, other: Any): ...
    def streamline(self): ...
    def checkRecursion(self, parseElementList: Any) -> None: ...
    def validate(self, validateTrace: _Optional[Any] = ...) -> None: ...

class FollowedBy(ParseElementEnhance):
    mayReturnEmpty: bool = ...
    def __init__(self, expr: Any) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class PrecededBy(ParseElementEnhance):
    expr: Any = ...
    mayReturnEmpty: bool = ...
    mayIndexError: bool = ...
    exact: bool = ...
    retreat: Any = ...
    errmsg: Any = ...
    skipWhitespace: bool = ...
    def __init__(self, expr: Any, retreat: _Optional[Any] = ...): ...
    def parseImpl(self, instring: Any, loc: int = ..., doActions: bool = ...): ...

class NotAny(ParseElementEnhance):
    skipWhitespace: bool = ...
    mayReturnEmpty: bool = ...
    errmsg: Any = ...
    def __init__(self, expr: Any) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class _MultipleMatch(ParseElementEnhance):
    saveAsList: bool = ...
    def __init__(self, expr: Any, stopOn: _Optional[Any] = ...) -> None: ...
    not_ender: Any = ...
    def stopOn(self, ender: Any): ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class OneOrMore(_MultipleMatch): ...

class ZeroOrMore(_MultipleMatch):
    mayReturnEmpty: bool = ...
    def __init__(self, expr: Any, stopOn: _Optional[Any] = ...) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class _NullToken:
    def __bool__(self): ...
    __nonzero__: Any = ...

class Optional(ParseElementEnhance):
    saveAsList: Any = ...
    defaultValue: Any = ...
    mayReturnEmpty: bool = ...
    def __init__(self, expr: Any, default: Any = ...) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class SkipTo(ParseElementEnhance):
    ignoreExpr: Any = ...
    mayReturnEmpty: bool = ...
    mayIndexError: bool = ...
    includeMatch: Any = ...
    saveAsList: bool = ...
    failOn: Any = ...
    errmsg: Any = ...
    def __init__(self, other: Any, include: bool = ..., ignore: _Optional[Any] = ..., failOn: _Optional[Any] = ...) -> None: ...
    def parseImpl(self, instring: Any, loc: Any, doActions: bool = ...): ...

class Forward(ParseElementEnhance):
    def __init__(self, other: _Optional[Any] = ...) -> None: ...
    expr: Any = ...
    strRepr: Any = ...
    mayIndexError: Any = ...
    mayReturnEmpty: Any = ...
    skipWhitespace: Any = ...
    saveAsList: Any = ...
    def __lshift__(self, other: Any): ...
    def __ilshift__(self, other: Any): ...
    def leaveWhitespace(self): ...
    streamlined: bool = ...
    def streamline(self): ...
    def validate(self, validateTrace: _Optional[Any] = ...) -> None: ...
    def copy(self): ...

class TokenConverter(ParseElementEnhance):
    saveAsList: bool = ...
    def __init__(self, expr: Any, savelist: bool = ...) -> None: ...

class Combine(TokenConverter):
    adjacent: Any = ...
    skipWhitespace: bool = ...
    joinString: Any = ...
    callPreparse: bool = ...
    def __init__(self, expr: Any, joinString: str = ..., adjacent: bool = ...) -> None: ...
    def ignore(self, other: Any): ...
    def postParse(self, instring: Any, loc: Any, tokenlist: Any): ...

class Group(TokenConverter):
    saveAsList: bool = ...
    def __init__(self, expr: Any) -> None: ...
    def postParse(self, instring: Any, loc: Any, tokenlist: Any): ...

class Dict(TokenConverter):
    saveAsList: bool = ...
    def __init__(self, expr: Any) -> None: ...
    def postParse(self, instring: Any, loc: Any, tokenlist: Any): ...

class Suppress(TokenConverter):
    def postParse(self, instring: Any, loc: Any, tokenlist: Any): ...
    def suppress(self): ...

class OnlyOnce:
    callable: Any = ...
    called: bool = ...
    def __init__(self, methodCall: Any) -> None: ...
    def __call__(self, s: Any, l: Any, t: Any): ...
    def reset(self) -> None: ...

def traceParseAction(f: Any): ...
def delimitedList(expr: Any, delim: str = ..., combine: bool = ...): ...
def countedArray(expr: Any, intExpr: _Optional[Any] = ...): ...
def matchPreviousLiteral(expr: Any): ...
def matchPreviousExpr(expr: Any): ...
def oneOf(strs: Any, caseless: bool = ..., useRegex: bool = ..., asKeyword: bool = ...): ...
def dictOf(key: Any, value: Any): ...
def originalTextFor(expr: Any, asString: bool = ...): ...
def ungroup(expr: Any): ...
def locatedExpr(expr: Any): ...

empty: Any
lineStart: Any
lineEnd: Any
stringStart: Any
stringEnd: Any

def srange(s: Any): ...
def matchOnlyAtCol(n: Any): ...
def replaceWith(replStr: Any): ...
def removeQuotes(s: Any, l: Any, t: Any): ...
def tokenMap(func: Any, *args: Any): ...

upcaseTokens: Any
downcaseTokens: Any

def makeHTMLTags(tagStr: Any): ...
def makeXMLTags(tagStr: Any): ...
def withAttribute(*args: Any, **attrDict: Any): ...
def withClass(classname: Any, namespace: str = ...): ...

opAssoc: Any

def infixNotation(baseExpr: Any, opList: Any, lpar: Any = ..., rpar: Any = ...): ...
operatorPrecedence = infixNotation
dblQuotedString: Any
sglQuotedString: Any
quotedString: Any
unicodeString: Any

def nestedExpr(opener: str = ..., closer: str = ..., content: _Optional[Any] = ..., ignoreExpr: Any = ...): ...
def indentedBlock(blockStatementExpr: Any, indentStack: Any, indent: bool = ...): ...

alphas8bit: Any
punc8bit: Any
anyOpenTag: Any
anyCloseTag: Any
commonHTMLEntity: Any

def replaceHTMLEntity(t: Any): ...

cStyleComment: Any
htmlComment: Any
restOfLine: Any
dblSlashComment: Any
cppStyleComment: Any
javaStyleComment = cppStyleComment
pythonStyleComment: Any
commaSeparatedList: Any

class pyparsing_common:
    convertToInteger: Any = ...
    convertToFloat: Any = ...
    integer: Any = ...
    hex_integer: Any = ...
    signed_integer: Any = ...
    fraction: Any = ...
    mixed_integer: Any = ...
    real: Any = ...
    sci_real: Any = ...
    number: Any = ...
    fnumber: Any = ...
    identifier: Any = ...
    ipv4_address: Any = ...
    ipv6_address: Any = ...
    mac_address: Any = ...
    @staticmethod
    def convertToDate(fmt: str = ...): ...
    @staticmethod
    def convertToDatetime(fmt: str = ...): ...
    iso8601_date: Any = ...
    iso8601_datetime: Any = ...
    uuid: Any = ...
    @staticmethod
    def stripHTMLTags(s: Any, l: Any, tokens: Any): ...
    comma_separated_list: Any = ...
    upcaseTokens: Any = ...
    downcaseTokens: Any = ...

class _lazyclassproperty:
    fn: Any = ...
    __doc__: Any = ...
    __name__: Any = ...
    def __init__(self, fn: Any) -> None: ...
    def __get__(self, obj: Any, cls: Any): ...

class unicode_set:
    def printables(cls): ...
    def alphas(cls): ...
    def nums(cls): ...
    def alphanums(cls): ...

class pyparsing_unicode(unicode_set):
    class Latin1(unicode_set): ...
    class LatinA(unicode_set): ...
    class LatinB(unicode_set): ...
    class Greek(unicode_set): ...
    class Cyrillic(unicode_set): ...
    class Chinese(unicode_set): ...
    class Japanese(unicode_set):
        class Kanji(unicode_set): ...
        class Hiragana(unicode_set): ...
        class Katakana(unicode_set): ...
    class Korean(unicode_set): ...
    class CJK(Chinese, Japanese, Korean): ...
    class Thai(unicode_set): ...
    class Arabic(unicode_set): ...
    class Hebrew(unicode_set): ...
    class Devanagari(unicode_set): ...

class pyparsing_test:
    class reset_pyparsing_context:
        def __init__(self) -> None: ...
        def save(self): ...
        def restore(self) -> None: ...
        def __enter__(self): ...
        def __exit__(self, *args: Any): ...
    class TestParseResultsAsserts:
        def assertParseResultsEquals(self, result: Any, expected_list: _Optional[Any] = ..., expected_dict: _Optional[Any] = ..., msg: _Optional[Any] = ...) -> None: ...
        def assertParseAndCheckList(self, expr: Any, test_string: Any, expected_list: Any, msg: _Optional[Any] = ..., verbose: bool = ...) -> None: ...
        def assertParseAndCheckDict(self, expr: Any, test_string: Any, expected_dict: Any, msg: _Optional[Any] = ..., verbose: bool = ...) -> None: ...
        def assertRunTestResults(self, run_tests_report: Any, expected_parse_results: _Optional[Any] = ..., msg: _Optional[Any] = ...) -> None: ...
        def assertRaisesParseException(self, exc_type: Any = ..., msg: _Optional[Any] = ...) -> None: ...

# Names in __all__ with no definition:
#   __author__
#   __version__
