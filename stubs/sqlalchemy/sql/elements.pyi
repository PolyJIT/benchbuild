from . import operators
from .. import util
from .annotation import Annotated
from .base import Executable, Immutable
from .visitors import Visitable
from typing import Any, Optional

def collate(expression: Any, collation: Any): ...
def between(expr: Any, lower_bound: Any, upper_bound: Any, symmetric: bool = ...): ...
def literal(value: Any, type_: Optional[Any] = ...): ...
def outparam(key: Any, type_: Optional[Any] = ...): ...
def not_(clause: Any): ...

class ClauseElement(Visitable):
    __visit_name__: str = ...
    supports_execution: bool = ...
    bind: Any = ...
    is_selectable: bool = ...
    is_clause_element: bool = ...
    description: Any = ...
    def unique_params(self, *optionaldict: Any, **kwargs: Any): ...
    def params(self, *optionaldict: Any, **kwargs: Any): ...
    def compare(self, other: Any, **kw: Any): ...
    def get_children(self, **kwargs: Any): ...
    def self_group(self, against: Optional[Any] = ...): ...
    def compile(self, default: Any, bind: Optional[Any] = ..., dialect: Optional[Any] = ..., **kw: Any): ...
    def __and__(self, other: Any): ...
    def __or__(self, other: Any): ...
    def __invert__(self): ...
    def __bool__(self) -> None: ...
    __nonzero__: Any = ...

class ColumnElement(operators.ColumnOperators, ClauseElement):
    __visit_name__: str = ...
    primary_key: bool = ...
    foreign_keys: Any = ...
    key: Any = ...
    def self_group(self, against: Optional[Any] = ...): ...
    def type(self): ...
    def comparator(self): ...
    def __getattr__(self, key: Any): ...
    def operate(self, op: Any, *other: Any, **kwargs: Any): ...
    def reverse_operate(self, op: Any, other: Any, **kwargs: Any): ...
    @property
    def expression(self): ...
    def base_columns(self): ...
    def proxy_set(self): ...
    def shares_lineage(self, othercolumn: Any): ...
    def compare(self, other: Any, use_proxies: bool = ..., equivalents: Optional[Any] = ..., **kw: Any): ...
    def cast(self, type_: Any): ...
    def label(self, name: Any): ...
    def anon_label(self): ...

class BindParameter(ColumnElement):
    __visit_name__: str = ...
    key: Any = ...
    unique: Any = ...
    value: Any = ...
    callable: Any = ...
    isoutparam: Any = ...
    required: Any = ...
    expanding: Any = ...
    type: Any = ...
    def __init__(self, key: Any, value: Any = ..., type_: Optional[Any] = ..., unique: bool = ..., required: Any = ..., quote: Optional[Any] = ..., callable_: Optional[Any] = ..., expanding: bool = ..., isoutparam: bool = ..., _compared_to_operator: Optional[Any] = ..., _compared_to_type: Optional[Any] = ...) -> None: ...
    @property
    def effective_value(self): ...
    def compare(self, other: Any, **kw: Any): ...

class TypeClause(ClauseElement):
    __visit_name__: str = ...
    type: Any = ...
    def __init__(self, type_: Any) -> None: ...

class TextClause(Executable, ClauseElement):
    __visit_name__: str = ...
    def __and__(self, other: Any): ...
    @property
    def selectable(self): ...
    key: Any = ...
    text: Any = ...
    def __init__(self, text: Any, bind: Optional[Any] = ...): ...
    def bindparams(self, *binds: Any, **names_to_values: Any) -> None: ...
    def columns(self, selectable: Any, *cols: Any, **types: Any): ...
    @property
    def type(self): ...
    @property
    def comparator(self): ...
    def self_group(self, against: Optional[Any] = ...): ...
    def get_children(self, **kwargs: Any): ...
    def compare(self, other: Any): ...

class Null(ColumnElement):
    __visit_name__: str = ...
    def type(self): ...
    def compare(self, other: Any): ...

class False_(ColumnElement):
    __visit_name__: str = ...
    def type(self): ...
    def compare(self, other: Any): ...

class True_(ColumnElement):
    __visit_name__: str = ...
    def type(self): ...
    def compare(self, other: Any): ...

class ClauseList(ClauseElement):
    __visit_name__: str = ...
    operator: Any = ...
    group: Any = ...
    group_contents: Any = ...
    clauses: Any = ...
    def __init__(self, *clauses: Any, **kwargs: Any) -> None: ...
    def __iter__(self) -> Any: ...
    def __len__(self): ...
    def append(self, clause: Any) -> None: ...
    def get_children(self, **kwargs: Any): ...
    def self_group(self, against: Optional[Any] = ...): ...
    def compare(self, other: Any, **kw: Any): ...

class BooleanClauseList(ClauseList, ColumnElement):
    __visit_name__: str = ...
    def __init__(self, *arg: Any, **kw: Any) -> None: ...
    @classmethod
    def and_(cls, *clauses: Any): ...
    @classmethod
    def or_(cls, *clauses: Any): ...
    def self_group(self, against: Optional[Any] = ...): ...

and_: Any
or_: Any

class Tuple(ClauseList, ColumnElement):
    type: Any = ...
    def __init__(self, *clauses: Any, **kw: Any) -> None: ...

class Case(ColumnElement):
    __visit_name__: str = ...
    value: Any = ...
    type: Any = ...
    whens: Any = ...
    else_: Any = ...
    def __init__(self, whens: Any, value: Optional[Any] = ..., else_: Optional[Any] = ...) -> None: ...
    def get_children(self, **kwargs: Any) -> None: ...

def literal_column(text: Any, type_: Optional[Any] = ...): ...

class Cast(ColumnElement):
    __visit_name__: str = ...
    type: Any = ...
    clause: Any = ...
    typeclause: Any = ...
    def __init__(self, expression: Any, type_: Any) -> None: ...
    def get_children(self, **kwargs: Any): ...

class TypeCoerce(ColumnElement):
    __visit_name__: str = ...
    type: Any = ...
    clause: Any = ...
    def __init__(self, expression: Any, type_: Any) -> None: ...
    def get_children(self, **kwargs: Any): ...
    def typed_expression(self): ...

class Extract(ColumnElement):
    __visit_name__: str = ...
    type: Any = ...
    field: Any = ...
    expr: Any = ...
    def __init__(self, field: Any, expr: Any, **kwargs: Any) -> None: ...
    def get_children(self, **kwargs: Any): ...

class _label_reference(ColumnElement):
    __visit_name__: str = ...
    element: Any = ...
    def __init__(self, element: Any) -> None: ...

class _textual_label_reference(ColumnElement):
    __visit_name__: str = ...
    element: Any = ...
    def __init__(self, element: Any) -> None: ...

class UnaryExpression(ColumnElement):
    __visit_name__: str = ...
    operator: Any = ...
    modifier: Any = ...
    element: Any = ...
    type: Any = ...
    negate: Any = ...
    wraps_column_expression: Any = ...
    def __init__(self, element: Any, operator: Optional[Any] = ..., modifier: Optional[Any] = ..., type_: Optional[Any] = ..., negate: Optional[Any] = ..., wraps_column_expression: bool = ...) -> None: ...
    def get_children(self, **kwargs: Any): ...
    def compare(self, other: Any, **kw: Any): ...
    def self_group(self, against: Optional[Any] = ...): ...

class CollectionAggregate(UnaryExpression):
    def operate(self, op: Any, *other: Any, **kwargs: Any): ...
    def reverse_operate(self, op: Any, other: Any, **kwargs: Any) -> None: ...

class AsBoolean(UnaryExpression):
    element: Any = ...
    type: Any = ...
    operator: Any = ...
    negate: Any = ...
    modifier: Any = ...
    wraps_column_expression: bool = ...
    def __init__(self, element: Any, operator: Any, negate: Any) -> None: ...
    def self_group(self, against: Optional[Any] = ...): ...

class BinaryExpression(ColumnElement):
    __visit_name__: str = ...
    left: Any = ...
    right: Any = ...
    operator: Any = ...
    type: Any = ...
    negate: Any = ...
    modifiers: Any = ...
    def __init__(self, left: Any, right: Any, operator: Any, type_: Optional[Any] = ..., negate: Optional[Any] = ..., modifiers: Optional[Any] = ...) -> None: ...
    def __bool__(self): ...
    __nonzero__: Any = ...
    @property
    def is_comparison(self): ...
    def get_children(self, **kwargs: Any): ...
    def compare(self, other: Any, **kw: Any): ...
    def self_group(self, against: Optional[Any] = ...): ...

class Slice(ColumnElement):
    __visit_name__: str = ...
    start: Any = ...
    stop: Any = ...
    step: Any = ...
    type: Any = ...
    def __init__(self, start: Any, stop: Any, step: Any) -> None: ...
    def self_group(self, against: Optional[Any] = ...): ...

class IndexExpression(BinaryExpression): ...

class Grouping(ColumnElement):
    __visit_name__: str = ...
    element: Any = ...
    type: Any = ...
    def __init__(self, element: Any) -> None: ...
    def self_group(self, against: Optional[Any] = ...): ...
    def get_children(self, **kwargs: Any): ...
    def __getattr__(self, attr: Any): ...
    def compare(self, other: Any, **kw: Any): ...

RANGE_UNBOUNDED: Any
RANGE_CURRENT: Any

class Over(ColumnElement):
    __visit_name__: str = ...
    order_by: Any = ...
    partition_by: Any = ...
    element: Any = ...
    range_: Any = ...
    rows: Any = ...
    def __init__(self, element: Any, partition_by: Optional[Any] = ..., order_by: Optional[Any] = ..., range_: Optional[Any] = ..., rows: Optional[Any] = ...) -> None: ...
    @property
    def func(self): ...
    def type(self): ...
    def get_children(self, **kwargs: Any): ...

class WithinGroup(ColumnElement):
    __visit_name__: str = ...
    order_by: Any = ...
    element: Any = ...
    def __init__(self, element: Any, *order_by: Any) -> None: ...
    def over(self, partition_by: Optional[Any] = ..., order_by: Optional[Any] = ..., range_: Optional[Any] = ..., rows: Optional[Any] = ...): ...
    def type(self): ...
    def get_children(self, **kwargs: Any): ...

class FunctionFilter(ColumnElement):
    __visit_name__: str = ...
    criterion: Any = ...
    func: Any = ...
    def __init__(self, func: Any, *criterion: Any) -> None: ...
    def filter(self, *criterion: Any): ...
    def over(self, partition_by: Optional[Any] = ..., order_by: Optional[Any] = ..., range_: Optional[Any] = ..., rows: Optional[Any] = ...): ...
    def self_group(self, against: Optional[Any] = ...): ...
    def type(self): ...
    def get_children(self, **kwargs: Any): ...

class Label(ColumnElement):
    __visit_name__: str = ...
    name: Any = ...
    key: Any = ...
    def __init__(self, name: Any, element: Any, type_: Optional[Any] = ...) -> None: ...
    def __reduce__(self): ...
    def type(self): ...
    def element(self): ...
    def self_group(self, against: Optional[Any] = ...): ...
    @property
    def primary_key(self): ...
    @property
    def foreign_keys(self): ...
    def get_children(self, **kwargs: Any): ...

class ColumnClause(Immutable, ColumnElement):
    __visit_name__: str = ...
    onupdate: Any = ...
    default: Any = ...
    server_default: Any = ...
    server_onupdate: Any = ...
    key: Any = ...
    table: Any = ...
    type: Any = ...
    is_literal: Any = ...
    def __init__(self, text: Any, type_: Optional[Any] = ..., is_literal: bool = ..., _selectable: Optional[Any] = ...) -> None: ...
    def description(self): ...

class CollationClause(ColumnElement):
    __visit_name__: str = ...
    collation: Any = ...
    def __init__(self, collation: Any) -> None: ...

class _IdentifiedClause(Executable, ClauseElement):
    __visit_name__: str = ...
    ident: Any = ...
    def __init__(self, ident: Any) -> None: ...

class SavepointClause(_IdentifiedClause):
    __visit_name__: str = ...

class RollbackToSavepointClause(_IdentifiedClause):
    __visit_name__: str = ...

class ReleaseSavepointClause(_IdentifiedClause):
    __visit_name__: str = ...

class quoted_name(util.MemoizedSlots, util.text_type):
    quote: Any = ...
    def __new__(cls, value: Any, quote: Any): ...
    def __reduce__(self): ...

class _truncated_label(quoted_name):
    def __new__(cls, value: Any, quote: Optional[Any] = ...): ...
    def __reduce__(self): ...
    def apply_map(self, map_: Any): ...

class conv(_truncated_label): ...

class _defer_name(_truncated_label):
    def __new__(cls, value: Any): ...
    def __reduce__(self): ...

class _defer_none_name(_defer_name): ...

class _anonymous_label(_truncated_label):
    def __add__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def apply_map(self, map_: Any): ...

class AnnotatedColumnElement(Annotated):
    def __init__(self, element: Any, values: Any) -> None: ...
    def name(self): ...
    def table(self): ...
    def key(self): ...
    def info(self): ...
    def anon_label(self): ...
