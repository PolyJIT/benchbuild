from .annotation import Annotated
from .base import Executable, Generative, Immutable
from .elements import BindParameter, ClauseElement, Grouping, UnaryExpression
from typing import Any, Optional

class _OffsetLimitParam(BindParameter): ...

def subquery(alias: Any, *args: Any, **kwargs: Any): ...

class Selectable(ClauseElement):
    __visit_name__: str = ...
    is_selectable: bool = ...
    @property
    def selectable(self): ...

class HasPrefixes:
    def prefix_with(self, *expr: Any, **kw: Any) -> None: ...

class HasSuffixes:
    def suffix_with(self, *expr: Any, **kw: Any) -> None: ...

class FromClause(Selectable):
    __visit_name__: str = ...
    named_with_column: bool = ...
    schema: Any = ...
    def count(self, functions: Any, whereclause: Optional[Any] = ..., **params: Any): ...
    def select(self, whereclause: Optional[Any] = ..., **params: Any): ...
    def join(self, right: Any, onclause: Optional[Any] = ..., isouter: bool = ..., full: bool = ...): ...
    def outerjoin(self, right: Any, onclause: Optional[Any] = ..., full: bool = ...): ...
    def alias(self, name: Optional[Any] = ..., flat: bool = ...): ...
    def lateral(self, name: Optional[Any] = ...): ...
    def tablesample(self, sampling: Any, name: Optional[Any] = ..., seed: Optional[Any] = ...): ...
    def is_derived_from(self, fromclause: Any): ...
    def replace_selectable(self, sqlutil: Any, old: Any, alias: Any): ...
    def correspond_on_equivalents(self, column: Any, equivalents: Any): ...
    def corresponding_column(self, column: Any, require_embedded: bool = ...): ...
    @property
    def description(self): ...
    def columns(self): ...
    def primary_key(self): ...
    def foreign_keys(self): ...
    c: Any = ...

class Join(FromClause):
    __visit_name__: str = ...
    left: Any = ...
    right: Any = ...
    onclause: Any = ...
    isouter: Any = ...
    full: Any = ...
    def __init__(self, left: Any, right: Any, onclause: Optional[Any] = ..., isouter: bool = ..., full: bool = ...) -> None: ...
    @property
    def description(self): ...
    def is_derived_from(self, fromclause: Any): ...
    def self_group(self, against: Optional[Any] = ...): ...
    def get_children(self, **kwargs: Any): ...
    def select(self, whereclause: Optional[Any] = ..., **kwargs: Any): ...
    @property
    def bind(self): ...
    def alias(self, sqlutil: Any, name: Optional[Any] = ..., flat: bool = ...): ...

class Alias(FromClause):
    __visit_name__: str = ...
    named_with_column: bool = ...
    def __init__(self, *arg: Any, **kw: Any) -> None: ...
    def self_group(self, against: Optional[Any] = ...): ...
    @property
    def description(self): ...
    def as_scalar(self): ...
    def is_derived_from(self, fromclause: Any): ...
    def get_children(self, column_collections: bool = ..., **kw: Any) -> None: ...
    @property
    def bind(self): ...

class Lateral(Alias):
    __visit_name__: str = ...

class TableSample(Alias):
    __visit_name__: str = ...

class CTE(Generative, HasPrefixes, HasSuffixes, Alias):
    __visit_name__: str = ...
    def alias(self, name: Optional[Any] = ..., flat: bool = ...): ...
    def union(self, other: Any): ...
    def union_all(self, other: Any): ...

class HasCTE:
    def cte(self, name: Optional[Any] = ..., recursive: bool = ...): ...

class FromGrouping(FromClause):
    __visit_name__: str = ...
    element: Any = ...
    def __init__(self, element: Any) -> None: ...
    @property
    def columns(self): ...
    @property
    def primary_key(self): ...
    @property
    def foreign_keys(self): ...
    def is_derived_from(self, element: Any): ...
    def alias(self, **kw: Any): ...
    def get_children(self, **kwargs: Any): ...
    def __getattr__(self, attr: Any): ...

class TableClause(Immutable, FromClause):
    __visit_name__: str = ...
    named_with_column: bool = ...
    implicit_returning: bool = ...
    name: Any = ...
    primary_key: Any = ...
    foreign_keys: Any = ...
    def __init__(self, name: Any, *columns: Any) -> None: ...
    def description(self): ...
    def append_column(self, c: Any) -> None: ...
    def get_children(self, column_collections: bool = ..., **kwargs: Any): ...
    def insert(self, dml: Any, values: Optional[Any] = ..., inline: bool = ..., **kwargs: Any): ...
    def update(self, dml: Any, whereclause: Optional[Any] = ..., values: Optional[Any] = ..., inline: bool = ..., **kwargs: Any): ...
    def delete(self, dml: Any, whereclause: Optional[Any] = ..., **kwargs: Any): ...

class ForUpdateArg(ClauseElement):
    @classmethod
    def parse_legacy_select(self, arg: Any): ...
    @property
    def legacy_for_update_value(self): ...
    def __eq__(self, other: Any) -> Any: ...
    def __hash__(self) -> Any: ...
    nowait: Any = ...
    read: Any = ...
    skip_locked: Any = ...
    key_share: Any = ...
    of: Any = ...
    def __init__(self, nowait: bool = ..., read: bool = ..., of: Optional[Any] = ..., skip_locked: bool = ..., key_share: bool = ...) -> None: ...

class SelectBase(HasCTE, Executable, FromClause):
    def as_scalar(self): ...
    def label(self, name: Any): ...
    def autocommit(self) -> None: ...

class GenerativeSelect(SelectBase):
    use_labels: Any = ...
    def __init__(self, use_labels: bool = ..., for_update: bool = ..., limit: Optional[Any] = ..., offset: Optional[Any] = ..., order_by: Optional[Any] = ..., group_by: Optional[Any] = ..., bind: Optional[Any] = ..., autocommit: Optional[Any] = ...) -> None: ...
    @property
    def for_update(self): ...
    @for_update.setter
    def for_update(self, value: Any) -> None: ...
    def with_for_update(self, nowait: bool = ..., read: bool = ..., of: Optional[Any] = ..., skip_locked: bool = ..., key_share: bool = ...) -> None: ...
    def apply_labels(self) -> None: ...
    def limit(self, limit: Any) -> None: ...
    def offset(self, offset: Any) -> None: ...
    def order_by(self, *clauses: Any) -> None: ...
    def group_by(self, *clauses: Any) -> None: ...
    def append_order_by(self, *clauses: Any) -> None: ...
    def append_group_by(self, *clauses: Any) -> None: ...

class CompoundSelect(GenerativeSelect):
    __visit_name__: str = ...
    UNION: Any = ...
    UNION_ALL: Any = ...
    EXCEPT: Any = ...
    EXCEPT_ALL: Any = ...
    INTERSECT: Any = ...
    INTERSECT_ALL: Any = ...
    keyword: Any = ...
    selects: Any = ...
    def __init__(self, keyword: Any, *selects: Any, **kwargs: Any) -> None: ...
    def self_group(self, against: Optional[Any] = ...): ...
    def is_derived_from(self, fromclause: Any): ...
    def get_children(self, column_collections: bool = ..., **kwargs: Any): ...
    def bind(self): ...
    bind: Any = ...

class Select(HasPrefixes, HasSuffixes, GenerativeSelect):
    __visit_name__: str = ...
    def __init__(self, columns: Optional[Any] = ..., whereclause: Optional[Any] = ..., from_obj: Optional[Any] = ..., distinct: bool = ..., having: Optional[Any] = ..., correlate: bool = ..., prefixes: Optional[Any] = ..., suffixes: Optional[Any] = ..., **kwargs: Any) -> None: ...
    @property
    def froms(self): ...
    def with_statement_hint(self, text: Any, dialect_name: str = ...): ...
    def with_hint(self, selectable: Any, text: Any, dialect_name: str = ...) -> None: ...
    @property
    def type(self) -> None: ...
    def locate_all_froms(self): ...
    @property
    def inner_columns(self): ...
    def is_derived_from(self, fromclause: Any): ...
    def get_children(self, column_collections: bool = ..., **kwargs: Any): ...
    def column(self, column: Any) -> None: ...
    def reduce_columns(self, sqlutil: Any, only_synonyms: bool = ...): ...
    def with_only_columns(self, columns: Any) -> None: ...
    def where(self, whereclause: Any) -> None: ...
    def having(self, having: Any) -> None: ...
    def distinct(self, *expr: Any) -> None: ...
    def select_from(self, fromclause: Any) -> None: ...
    def correlate(self, *fromclauses: Any) -> None: ...
    def correlate_except(self, *fromclauses: Any) -> None: ...
    def append_correlation(self, fromclause: Any) -> None: ...
    def append_column(self, column: Any) -> None: ...
    def append_prefix(self, clause: Any) -> None: ...
    def append_whereclause(self, whereclause: Any) -> None: ...
    def append_having(self, having: Any) -> None: ...
    def append_from(self, fromclause: Any) -> None: ...
    def self_group(self, against: Optional[Any] = ...): ...
    def union(self, other: Any, **kwargs: Any): ...
    def union_all(self, other: Any, **kwargs: Any): ...
    def except_(self, other: Any, **kwargs: Any): ...
    def except_all(self, other: Any, **kwargs: Any): ...
    def intersect(self, other: Any, **kwargs: Any): ...
    def intersect_all(self, other: Any, **kwargs: Any): ...
    def bind(self): ...
    bind: Any = ...

class ScalarSelect(Generative, Grouping):
    element: Any = ...
    type: Any = ...
    def __init__(self, element: Any) -> None: ...
    @property
    def columns(self) -> None: ...
    c: Any = ...
    def where(self, crit: Any) -> None: ...
    def self_group(self, **kwargs: Any): ...

class Exists(UnaryExpression):
    __visit_name__: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def select(self, whereclause: Optional[Any] = ..., **params: Any): ...
    def correlate(self, *fromclause: Any): ...
    def correlate_except(self, *fromclause: Any): ...
    def select_from(self, clause: Any): ...
    def where(self, clause: Any): ...

class TextAsFrom(SelectBase):
    __visit_name__: str = ...
    element: Any = ...
    column_args: Any = ...
    positional: Any = ...
    def __init__(self, text: Any, columns: Any, positional: bool = ...) -> None: ...
    def bindparams(self, *binds: Any, **bind_as_values: Any) -> None: ...

class AnnotatedFromClause(Annotated):
    def __init__(self, element: Any, values: Any) -> None: ...
